     1                                  ;多处理器多任务内核，2022-04-23
     2                                  
     3                                  %include "..\common\global_defs.wid"
     4                              <1> ;系统全局使用的常量定义，2021-09-05
     5                              <1> 
     6                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     7                              <1> 
     8                              <1> %ifndef _GLOBAL_DEFS_
     9                              <1>    %define _GLOBAL_DEFS_
    10                              <1> 
    11                              <1>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    12                              <1>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    13                              <1>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    14                              <1>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    15                              <1>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    16                              <1>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    17                              <1>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    18                              <1>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    19                              <1>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    20                              <1>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    21                              <1>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    22                              <1> 
    23                              <1>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    24                              <1>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    25                              <1> 
    26                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    27                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    28                              <1> 
    29                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    30                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    31                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    32                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    33                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    34                              <1> 
    35                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    36                              <1>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    37                              <1>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    38                              <1>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    39                              <1>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    40                              <1>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    41                              <1> 
    42                              <1>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    43                              <1>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    44                              <1>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    45                              <1> 
    46                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    47                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    48                              <1> 
    49                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    50                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    51                              <1> 
    52                              <1>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    53                              <1> 
    54                              <1>    SUGG_PREEM_SLICE    equ     1000                      ;推荐的任务/线程抢占时间片长度（毫秒）
    55                              <1> 
    56                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    57                              <1>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
    58                              <1>             %%spin_lock:
    59                              <1>                        cmp %2, 0                       ;锁是释放状态吗？
    60                              <1>                        je %%get_lock                   ;获取锁
    61                              <1>                        pause
    62                              <1>                        jmp %%spin_lock                 ;继续尝试获取锁
    63                              <1>             %%get_lock:
    64                              <1>                        mov %1, 1
    65                              <1>                        xchg %1, %2
    66                              <1>                        cmp %1, 0                       ;交换前为零？
    67                              <1>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
    68                              <1>    %endmacro
    69                              <1> 
    70                              <1> %endif
     4                                  
     5                                  ;===============================================================================
     6                                  section core_header                               ;内核程序头部
     7 00000000 [00000000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
     8 00000004 [E9110000]                init_entry   dd init                            ;#4：内核入口点
     9 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    10                                  
    11                                  ;===============================================================================
    12                                  section core_data                                 ;内核数据段
    13 00000000 41435049206973206E-       acpi_error    db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    13 00000009 6F7420737570706F72-
    13 00000012 746564206F72206461-
    13 0000001B 7461206572726F722E-
    13 00000024 0D0A00             
    14                                  
    15 00000027 00                        num_cpus     db 0                               ;逻辑处理器数量
    16 00000028 00<rep 100h>              cpu_list     times 256 db 0                     ;Local APIC ID的列表
    17 00000128 00000000                  lapic_addr   dd 0                               ;Local APIC的物理地址
    18                                  
    19 0000012C 00000000                  ioapic_addr  dd 0                               ;I/O APIC的物理地址
    20 00000130 00                        ioapic_id    db 0                               ;I/O APIC ID
    21                                  
    22 00000131 00                        ack_cpus     db 0                               ;处理器初始化应答计数
    23                                  
    24 00000132 00000000                  clocks_1ms   dd 0                               ;处理器在1ms内经历的时钟数
    25                                  
    26 00000136 457865637574696E67-       welcome      db "Executing in 64-bit mode.Init MP", 249, 0
    26 0000013F 20696E2036342D6269-
    26 00000148 74206D6F64652E496E-
    26 00000151 6974204D50F900     
    27 00000158 204350552873292072-       cpu_init_ok  db " CPU(s) ready.", 0x0d, 0x0a, 0
    27 00000161 656164792E0D0A00   
    28                                  
    29 00000169 00<rep 100h>              buffer       times 256 db 0
    30                                  
    31 00000269 [7F0B000000000000]        sys_entry    dq get_screen_row
    32 00000271 [D00A000000000000]                     dq get_cmos_time
    33 00000279 [1901000000000000]                     dq put_cstringxy64
    34 00000281 [5B10000000000000]                     dq create_process
    35 00000289 [F10F000000000000]                     dq get_current_pid
    36 00000291 [0810000000000000]                     dq terminate_process
    37 00000299 [8A0B000000000000]                     dq get_cpu_number
    38 000002A1 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    39                                  
    40                                  ;===============================================================================
    41                                  section core_code                                 ;内核代码段
    42                                  
    43                                  %include "..\common\core_utils64_mp.wid"          ;引入内核用到的例程
    44                              <1> ;文件core_utils64_mp.wid是供64位内核使用的函数集，多处理器环境专用。
    45                              <1> ;创建时间：2022，李忠
    46                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，
    47                              <1> ;方便内核代码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    48                              <1> 
    49                              <1> %include "..\common\global_defs.wid"
    50                              <2> ;系统全局使用的常量定义，2021-09-05
    51                              <2> 
    52                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    53                              <2> 
    54                              <2> %ifndef _GLOBAL_DEFS_
    55                              <2>    %define _GLOBAL_DEFS_
    56                              <2> 
    57                              <2>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    58                              <2>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    59                              <2>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    60                              <2>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    61                              <2>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    62                              <2>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    63                              <2>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    64                              <2>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    65                              <2>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    66                              <2>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    67                              <2>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    68                              <2> 
    69                              <2>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    70                              <2>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    71                              <2> 
    72                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    73                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    74                              <2> 
    75                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    76                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    77                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    78                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    79                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    80                              <2> 
    81                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    82                              <2>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    83                              <2>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    84                              <2>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    85                              <2>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    86                              <2>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    87                              <2> 
    88                              <2>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    89                              <2>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    90                              <2>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    91                              <2> 
    92                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    93                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    94                              <2> 
    95                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    96                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    97                              <2> 
    98                              <2>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    99                              <2> 
   100                              <2>    SUGG_PREEM_SLICE    equ     1000                      ;推荐的任务/线程抢占时间片长度（毫秒）
   101                              <2> 
   102                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
   103                              <2>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
   104                              <2>             %%spin_lock:
   105                              <2>                        cmp %2, 0                       ;锁是释放状态吗？
   106                              <2>                        je %%get_lock                   ;获取锁
   107                              <2>                        pause
   108                              <2>                        jmp %%spin_lock                 ;继续尝试获取锁
   109                              <2>             %%get_lock:
   110                              <2>                        mov %1, 1
   111                              <2>                        xchg %1, %2
   112                              <2>                        cmp %1, 0                       ;交换前为零？
   113                              <2>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
   114                              <2>    %endmacro
   115                              <2> 
   116                              <2> %endif
    50                              <1> 
    51                              <1>          bits 64
    52                              <1> 
    53                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    54 00000000 0000000000000000    <1> _prn_str_locker dq 0                              ;打印锁
    55                              <1> 
    56                              <1> put_string64:                                     ;显示0终止的字符串并移动光标
    57                              <1>                                                   ;输入：RBX=字符串的线性地址
    58 00000008 53                  <1>          push rbx
    59 00000009 51                  <1>          push rcx
    60                              <1> 
    61 0000000A 9C                  <1>          pushfq                                   ;-->A
    62 0000000B FA                  <1>          cli
    63                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    58                              <2>  %%spin_lock:
    59 0000000C 48833DECFFFFFF00    <2>  cmp %2, 0
    60 00000014 7404                <2>  je %%get_lock
    61 00000016 F390                <2>  pause
    62 00000018 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000001A B901000000          <2>  mov %1, 1
    65 0000001F 48870DDAFFFFFF      <2>  xchg %1, %2
    66 00000026 4883F900            <2>  cmp %1, 0
    67 0000002A 75E0                <2>  jne %%spin_lock
    64                              <1> 
    65                              <1>   .getc:
    66 0000002C 8A0B                <1>          mov cl, [rbx]
    67 0000002E 08C9                <1>          or cl, cl                                ;检测串结束标志（0）
    68 00000030 740A                <1>          jz .exit                                 ;显示完毕，返回
    69 00000032 E814000000          <1>          call put_char
    70 00000037 48FFC3              <1>          inc rbx
    71 0000003A EBF0                <1>          jmp .getc
    72                              <1> 
    73                              <1>   .exit:
    74 0000003C 48C705B9FFFFFF0000- <1>          mov qword [rel _prn_str_locker], 0       ;释放锁
    74 00000045 0000                <1>
    75 00000047 9D                  <1>          popfq                                    ;A
    76                              <1> 
    77 00000048 59                  <1>          pop rcx
    78 00000049 5B                  <1>          pop rbx
    79                              <1> 
    80 0000004A C3                  <1>          ret                                      ;段内返回
    81                              <1> 
    82                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    83                              <1> put_char:                                         ;在当前光标处显示一个字符,并推进
    84                              <1>                                                   ;光标。
    85                              <1>                                                   ;输入：CL=字符ASCII码
    86 0000004B 50                  <1>          push rax
    87 0000004C 53                  <1>          push rbx
    88 0000004D 51                  <1>          push rcx
    89 0000004E 52                  <1>          push rdx
    90 0000004F 56                  <1>          push rsi
    91 00000050 57                  <1>          push rdi
    92                              <1> 
    93                              <1>          ;以下取当前光标位置
    94 00000051 66BAD403            <1>          mov dx, 0x3d4
    95 00000055 B00E                <1>          mov al, 0x0e
    96 00000057 EE                  <1>          out dx, al
    97 00000058 66FFC2              <1>          inc dx                                   ;0x3d5
    98 0000005B EC                  <1>          in al, dx                                ;高字
    99 0000005C 88C4                <1>          mov ah, al
   100                              <1> 
   101 0000005E 66FFCA              <1>          dec dx                                   ;0x3d4
   102 00000061 B00F                <1>          mov al, 0x0f
   103 00000063 EE                  <1>          out dx, al
   104 00000064 66FFC2              <1>          inc dx                                   ;0x3d5
   105 00000067 EC                  <1>          in al, dx                                ;低字
   106 00000068 6689C3              <1>          mov bx, ax                               ;BX=代表光标位置的16位数
   107 0000006B 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff              ;准备使用64位寻址方式访问显存
   108                              <1> 
   109 00000072 80F90D              <1>          cmp cl, 0x0d                             ;回车符？
   110 00000075 750E                <1>          jnz .put_0a
   111 00000077 6689D8              <1>          mov ax, bx
   112 0000007A B350                <1>          mov bl, 80
   113 0000007C F6F3                <1>          div bl
   114 0000007E F6E3                <1>          mul bl
   115 00000080 6689C3              <1>          mov bx, ax
   116 00000083 EB6C                <1>          jmp .set_cursor
   117                              <1> 
   118                              <1>   .put_0a:
   119 00000085 80F90A              <1>          cmp cl, 0x0a                             ;换行符？
   120 00000088 7506                <1>          jnz .put_other
   121 0000008A 6683C350            <1>          add bx, 80
   122 0000008E EB16                <1>          jmp .roll_screen
   123                              <1> 
   124                              <1>   .put_other:                                     ;正常显示字符
   125 00000090 66D1E3              <1>          shl bx, 1
   126 00000093 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO                ;在global_defs.wid中定义
   126 0000009C FF                  <1>
   127 0000009D 880C18              <1>          mov [rax + rbx], cl
   128                              <1> 
   129                              <1>          ;以下将光标位置推进一个字符
   130 000000A0 66D1EB              <1>          shr bx, 1
   131 000000A3 66FFC3              <1>          inc bx
   132                              <1> 
   133                              <1>   .roll_screen:
   134 000000A6 6681FBD007          <1>          cmp bx, 2000                             ;光标超出屏幕？滚屏
   135 000000AB 7C44                <1>          jl .set_cursor
   136                              <1> 
   137 000000AD 6653                <1>          push bx
   138                              <1> 
   139 000000AF FC                  <1>          cld
   140 000000B0 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0         ;小心！64位模式下movsq
   140 000000B9 FF                  <1>
   141 000000BA 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO                ;使用的是rsi/rdi/rcx
   141 000000C3 FF                  <1>
   142 000000C4 B9E0010000          <1>          mov rcx, 480
   143 000000C9 F348A5              <1>          rep movsq
   144 000000CC 66BB000F            <1>          mov bx, 3840                             ;清除屏幕最底一行
   145 000000D0 B950000000          <1>          mov rcx, 80                              ;64位程序应该使用RCX
   146                              <1>   .cls:
   147 000000D5 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   147 000000DE FF                  <1>
   148 000000DF 66C704182007        <1>          mov word[rax + rbx], 0x0720
   149 000000E5 6683C302            <1>          add bx, 2
   150 000000E9 E2EA                <1>          loop .cls
   151                              <1> 
   152 000000EB 665B                <1>          pop bx
   153 000000ED 6683EB50            <1>          sub bx, 80
   154                              <1> 
   155                              <1>   .set_cursor:
   156 000000F1 66BAD403            <1>          mov dx, 0x3d4
   157 000000F5 B00E                <1>          mov al, 0x0e
   158 000000F7 EE                  <1>          out dx, al
   159 000000F8 66FFC2              <1>          inc dx                                   ;0x3d5
   160 000000FB 88F8                <1>          mov al, bh
   161 000000FD EE                  <1>          out dx, al
   162 000000FE 66FFCA              <1>          dec dx                                   ;0x3d4
   163 00000101 B00F                <1>          mov al, 0x0f
   164 00000103 EE                  <1>          out dx, al
   165 00000104 66FFC2              <1>          inc dx                                   ;0x3d5
   166 00000107 88D8                <1>          mov al, bl
   167 00000109 EE                  <1>          out dx, al
   168                              <1> 
   169 0000010A 5F                  <1>          pop rdi
   170 0000010B 5E                  <1>          pop rsi
   171 0000010C 5A                  <1>          pop rdx
   172 0000010D 59                  <1>          pop rcx
   173 0000010E 5B                  <1>          pop rbx
   174 0000010F 58                  <1>          pop rax
   175                              <1> 
   176 00000110 C3                  <1>          ret
   177                              <1> 
   178                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   179                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的
   180                              <1> ;坐标位置不同，互不干扰，不需要加锁和互斥。
   181 00000111 0000000000000000    <1> _prnxy_locker dq 0
   182                              <1> 
   183                              <1> put_cstringxy64:                                  ;输入：RBX=字符串首地址
   184                              <1>                                                   ;DH=行，DL=列
   185                              <1>                                                   ;R9B=颜色属性
   186 00000119 50                  <1>          push rax
   187 0000011A 53                  <1>          push rbx
   188 0000011B 51                  <1>          push rcx
   189 0000011C 52                  <1>          push rdx
   190 0000011D 4150                <1>          push r8
   191                              <1> 
   192                              <1>          ;指定坐标位置在显存内的偏移量
   193 0000011F 88F0                <1>          mov al, dh
   194 00000121 B5A0                <1>          mov ch, 160                              ;每一行80个字符，占用160个字节
   195 00000123 F6E5                <1>          mul ch
   196 00000125 D0E2                <1>          shl dl, 1                                ;每个字符（列）占用2个字节，要乘以2
   197 00000127 6681E2FF00          <1>          and dx, 0x00ff
   198 0000012C 6601D0              <1>          add ax, dx                               ;得到指定坐标位置在显存内的偏移量
   199 0000012F 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   200                              <1> 
   201 00000135 9C                  <1>          pushfq                                   ;-->A
   202 00000136 FA                  <1>          cli
   203                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
    58                              <2>  %%spin_lock:
    59 00000137 48833DD2FFFFFF00    <2>  cmp %2, 0
    60 0000013F 7404                <2>  je %%get_lock
    61 00000141 F390                <2>  pause
    62 00000143 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000145 41B801000000        <2>  mov %1, 1
    65 0000014B 4C8705BFFFFFFF      <2>  xchg %1, %2
    66 00000152 4983F800            <2>  cmp %1, 0
    67 00000156 75DF                <2>  jne %%spin_lock
   204                              <1> 
   205 00000158 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO                 ;显存的起始线性地址
   205 00000161 FF                  <1>
   206                              <1>   .nextc:
   207 00000162 8A13                <1>          mov dl, [rbx]                            ;取得将要显示的字符
   208 00000164 08D2                <1>          or dl, dl
   209 00000166 7412                <1>          jz .exit
   210 00000168 41881400            <1>          mov byte [r8 + rax], dl
   211 0000016C 45884C0001          <1>          mov byte [r8 + rax + 1], r9b             ;字符颜色
   212 00000171 48FFC3              <1>          inc rbx
   213 00000174 4883C002            <1>          add rax, 2                               ;增加一个字符的位置（2个字节）
   214 00000178 EBE8                <1>          jmp .nextc
   215                              <1>   .exit:
   216 0000017A 4D31C0              <1>          xor r8, r8
   217                              <1> 
   218 0000017D 48C70589FFFFFF0000- <1>          mov qword [rel _prnxy_locker], 0         ;释放锁
   218 00000186 0000                <1>
   219 00000188 9D                  <1>          popfq                                    ;A
   220                              <1> 
   221 00000189 4158                <1>          pop r8
   222 0000018B 5A                  <1>          pop rdx
   223 0000018C 59                  <1>          pop rcx
   224 0000018D 5B                  <1>          pop rbx
   225 0000018E 58                  <1>          pop rax
   226                              <1> 
   227 0000018F C3                  <1>          ret
   228                              <1> 
   229                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   230                              <1> make_call_gate:                                   ;创建64位的调用门
   231                              <1>                                                   ;输入：RAX=例程的线性地址
   232                              <1>                                                   ;输出：RDI:RSI=调用门
   233 00000190 4889C7              <1>          mov rdi, rax
   234 00000193 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   235                              <1> 
   236 00000197 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   237 00000198 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   238 0000019F 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   239 000001A3 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00               ;添加P=1，TYPE=64位调用门
   240 000001AA 5E                  <1>          pop rsi
   241                              <1> 
   242 000001AB C3                  <1>          ret
   243                              <1> 
   244                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   245                              <1> make_interrupt_gate:                              ;创建64位的中断门
   246                              <1>                                                   ;输入：RAX=例程的线性地址
   247                              <1>                                                   ;输出：RDI:RSI=中断门
   248 000001AC 4889C7              <1>          mov rdi, rax
   249 000001AF 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   250                              <1> 
   251 000001B3 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   252 000001B4 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   253 000001BB 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   254 000001BF 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00               ;添加P=1，TYPE=64位中断门
   255 000001C6 5E                  <1>          pop rsi
   256                              <1> 
   257 000001C7 C3                  <1>          ret
   258                              <1> 
   259                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   260                              <1> make_trap_gate:                                   ;创建64位的陷阱门
   261                              <1>                                                   ;输入：RAX=例程的线性地址
   262                              <1>                                                   ;输出：RDI:RSI=陷阱门
   263 000001C8 4889C7              <1>          mov rdi, rax
   264 000001CB 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   265                              <1> 
   266 000001CF 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   267 000001D0 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   268 000001D7 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   269 000001DB 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00               ;添加P=1，TYPE=64位陷阱门
   270 000001E2 5E                  <1>          pop rsi
   271                              <1> 
   272 000001E3 C3                  <1>          ret
   273                              <1> 
   274                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   275                              <1> make_tss_descriptor:                              ;创建64位的TSS描述符
   276                              <1>                                                   ;输入：RAX=TSS的线性地址
   277                              <1>                                                   ;输出：RDI:RSI=TSS描述符
   278 000001E4 50                  <1>          push rax
   279                              <1> 
   280 000001E5 4889C7              <1>          mov rdi, rax
   281 000001E8 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   282                              <1> 
   283 000001EC 50                  <1>          push rax                                 ;先将部分线性地址移到适当位置
   284 000001ED 48C1242410          <1>          shl qword [rsp], 16                      ;将线性地址的位23~00移到正确位置
   285 000001F2 66C704246800        <1>          mov word [rsp], 104                      ;段界限的标准长度
   286 000001F8 8A442405            <1>          mov al, [rsp + 5]
   287 000001FC 88442407            <1>          mov [rsp + 7], al                        ;将线性地址的位31~24移到正确位置
   288 00000200 C644240589          <1>          mov byte [rsp + 5], 0x89                 ;P=1，DPL=00，TYPE=1001（64位TSS）
   289 00000205 C644240600          <1>          mov byte [rsp + 6], 0                    ;G、0、0、AVL和limit
   290 0000020A 5E                  <1>          pop rsi                                  ;门的低64位
   291                              <1> 
   292 0000020B 58                  <1>          pop rax
   293                              <1> 
   294 0000020C C3                  <1>          ret
   295                              <1> 
   296                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   297                              <1> mount_idt_entry:                                  ;在中断描述符表IDT中安装门描述符
   298                              <1>                                                   ;R8=中断向量
   299                              <1>                                                   ;RDI:RSI=门描述符
   300 0000020D 4150                <1>          push r8
   301 0000020F 4151                <1>          push r9
   302                              <1> 
   303 00000211 49C1E004            <1>          shl r8, 4                                ;中断号乘以16，得到表内偏移
   304 00000215 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR                 ;中断描述符表的高端线性地址
   304 0000021E FF                  <1>
   305 0000021F 4B893401            <1>          mov [r9 + r8], rsi
   306 00000223 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   307                              <1> 
   308 00000228 4159                <1>          pop r9
   309 0000022A 4158                <1>          pop r8
   310                              <1> 
   311 0000022C C3                  <1>          ret
   312                              <1> 
   313                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   314                              <1> init_8259:                                        ;初始化8259中断控制器，包括重新设置向量号
   315 0000022D 50                  <1>          push rax
   316                              <1> 
   317 0000022E B011                <1>          mov al, 0x11
   318 00000230 E620                <1>          out 0x20, al                             ;ICW1：边沿触发/级联方式
   319 00000232 B020                <1>          mov al, 0x20
   320 00000234 E621                <1>          out 0x21, al                             ;ICW2:起始中断向量（避开前31个异常的向量）
   321 00000236 B004                <1>          mov al, 0x04
   322 00000238 E621                <1>          out 0x21, al                             ;ICW3:从片级联到IR2
   323 0000023A B001                <1>          mov al, 0x01
   324 0000023C E621                <1>          out 0x21, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   325                              <1> 
   326 0000023E B011                <1>          mov al, 0x11
   327 00000240 E6A0                <1>          out 0xa0, al                             ;ICW1：边沿触发/级联方式
   328 00000242 B028                <1>          mov al, 0x28
   329 00000244 E6A1                <1>          out 0xa1, al                             ;ICW2:起始中断向量-->0x28
   330 00000246 B002                <1>          mov al, 0x02
   331 00000248 E6A1                <1>          out 0xa1, al                             ;ICW3:从片识别标志，级联到主片IR2
   332 0000024A B001                <1>          mov al, 0x01
   333 0000024C E6A1                <1>          out 0xa1, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   334                              <1> 
   335 0000024E 58                  <1>          pop rax
   336 0000024F C3                  <1>          ret
   337                              <1> 
   338                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   339 00000250 0000000000000000    <1> _read_hdd_locker dq 0                              ;读硬盘锁
   340                              <1> 
   341                              <1> read_hard_disk_0:                                 ;从硬盘读取一个逻辑扇区
   342                              <1>                                                   ;RAX=逻辑扇区号
   343                              <1>                                                   ;RBX=目标缓冲区线性地址
   344                              <1>                                                   ;返回：RBX=RBX+512
   345 00000258 50                  <1>          push rax
   346 00000259 51                  <1>          push rcx
   347 0000025A 52                  <1>          push rdx
   348                              <1> 
   349 0000025B 9C                  <1>          pushfq                                   ;-->A
   350 0000025C FA                  <1>          cli
   351                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
    58                              <2>  %%spin_lock:
    59 0000025D 48833DEBFFFFFF00    <2>  cmp %2, 0
    60 00000265 7404                <2>  je %%get_lock
    61 00000267 F390                <2>  pause
    62 00000269 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000026B BA01000000          <2>  mov %1, 1
    65 00000270 488715D9FFFFFF      <2>  xchg %1, %2
    66 00000277 4883FA00            <2>  cmp %1, 0
    67 0000027B 75E0                <2>  jne %%spin_lock
   352                              <1> 
   353 0000027D 50                  <1>          push rax
   354                              <1> 
   355 0000027E 66BAF201            <1>          mov dx, 0x1f2
   356 00000282 B001                <1>          mov al, 1
   357 00000284 EE                  <1>          out dx, al                               ;读取的扇区数
   358                              <1> 
   359 00000285 66FFC2              <1>          inc dx                                   ;0x1f3
   360 00000288 58                  <1>          pop rax
   361 00000289 EE                  <1>          out dx, al                               ;LBA地址7~0
   362                              <1> 
   363 0000028A 66FFC2              <1>          inc dx                                   ;0x1f4
   364 0000028D B108                <1>          mov cl, 8
   365 0000028F 48D3E8              <1>          shr rax, cl
   366 00000292 EE                  <1>          out dx, al                               ;LBA地址15~8
   367                              <1> 
   368 00000293 66FFC2              <1>          inc dx                                   ;0x1f5
   369 00000296 48D3E8              <1>          shr rax, cl
   370 00000299 EE                  <1>          out dx, al                               ;LBA地址23~16
   371                              <1> 
   372 0000029A 66FFC2              <1>          inc dx                                   ;0x1f6
   373 0000029D 48D3E8              <1>          shr rax, cl
   374 000002A0 0CE0                <1>          or al, 0xe0                              ;第一硬盘  LBA地址27~24
   375 000002A2 EE                  <1>          out dx, al
   376                              <1> 
   377 000002A3 66FFC2              <1>          inc dx                                   ;0x1f7
   378 000002A6 B020                <1>          mov al, 0x20                             ;读命令
   379 000002A8 EE                  <1>          out dx, al
   380                              <1> 
   381                              <1>   .waits:
   382 000002A9 EC                  <1>          in al, dx
   383                              <1>          ;and al, 0x88
   384                              <1>          ;cmp al, 0x08
   385 000002AA A808                <1>          test al, 8
   386 000002AC 74FB                <1>          jz .waits                               ;不忙，且硬盘已准备好数据传输
   387                              <1> 
   388 000002AE B900010000          <1>          mov rcx, 256                             ;总共要读取的字数
   389 000002B3 66BAF001            <1>          mov dx, 0x1f0
   390                              <1>   .readw:
   391 000002B7 66ED                <1>          in ax, dx
   392 000002B9 668903              <1>          mov [rbx], ax
   393 000002BC 4883C302            <1>          add rbx, 2
   394 000002C0 E2F5                <1>          loop .readw
   395                              <1> 
   396 000002C2 48C70583FFFFFF0000- <1>          mov qword [rel _read_hdd_locker], 0      ;释放锁
   396 000002CB 0000                <1>
   397 000002CD 9D                  <1>          popfq                                    ;A
   398                              <1> 
   399 000002CE 5A                  <1>          pop rdx
   400 000002CF 59                  <1>          pop rcx
   401 000002D0 58                  <1>          pop rax
   402                              <1> 
   403 000002D1 C3                  <1>          ret
   404                              <1> 
   405                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   406 000002D2 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          ;对应物理内存的前512个页面（2MB）
   407 00000312 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 ;对应后续的页面
   408                              <1>   _page_map_len  equ $ - _page_bit_map
   409                              <1> 
   410                              <1> allocate_a_4k_page:                               ;分配一个4KB的页
   411                              <1>                                                   ;输入：无
   412                              <1>                                                   ;输出：RAX=页的物理地址
   413 000006D2 4831C0              <1>          xor rax, rax
   414                              <1>   .b1:
   415 000006D5 F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax
   416 000006DE 730B                <1>          jnc .b2
   417 000006E0 48FFC0              <1>          inc rax
   418 000006E3 483D00200000        <1>          cmp rax, _page_map_len * 8               ;立即数符号扩展到64位进行比较
   419 000006E9 7CEA                <1>          jl .b1
   420                              <1> 
   421                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的
   422                              <1>          ;系统来说，如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注
   423                              <1>          ;销的页面，或者执行页面的换入和换出。
   424                              <1> 
   425                              <1>   .b2:
   426 000006EB 48C1E00C            <1>          shl rax, 12                              ;乘以4096（0x1000）
   427                              <1> 
   428 000006EF C3                  <1>          ret
   429                              <1> 
   430                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   431                              <1> lin_to_lin_of_pml4e:                              ;返回指定的线性地址所对应的4级头表项的线性地址
   432                              <1>                                                   ;输入：R13=线性地址
   433                              <1>                                                   ;输出：R14=对应的4级头表项的线性地址
   434 000006F0 4155                <1>          push r13
   435                              <1> 
   436 000006F2 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000           ;保留4级头表索引部分
   436 000006FB 00                  <1>
   437 000006FC 4D21F5              <1>          and r13, r14
   438 000006FF 49C1ED24            <1>          shr r13, 36                              ;原4级头表索引变成页内偏移
   439                              <1> 
   440 00000703 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000           ;访问4级头表所用的地址前缀
   441 0000070A 4D01EE              <1>          add r14, r13
   442                              <1> 
   443 0000070D 415D                <1>          pop r13
   444                              <1> 
   445 0000070F C3                  <1>          ret
   446                              <1> 
   447                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   448                              <1> lin_to_lin_of_pdpte:                              ;返回指定的线性地址所对应的页目录指针项的线性地址
   449                              <1>                                                   ;输入：R13=线性地址
   450                              <1>                                                   ;输出：R14=对应的页目录指针项的线性地址
   451 00000710 4155                <1>          push r13
   452                              <1> 
   453 00000712 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000           ;保留4级头表索引和页目录指针表索引部分
   453 0000071B 00                  <1>
   454 0000071C 4D21F5              <1>          and r13, r14
   455 0000071F 49C1ED1B            <1>          shr r13, 27                              ;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   456                              <1> 
   457 00000723 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000           ;访问页目录指针表所用的地址前缀
   458 0000072A 4D01EE              <1>          add r14, r13
   459                              <1> 
   460 0000072D 415D                <1>          pop r13
   461                              <1> 
   462 0000072F C3                  <1>          ret
   463                              <1> 
   464                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   465                              <1> lin_to_lin_of_pdte:                               ;返回指定的线性地址所对应的页目录项的线性地址
   466                              <1>                                                   ;输入：R13=线性地址
   467                              <1>                                                   ;输出：R14=对应的页目录项的线性地址
   468 00000730 4155                <1>          push r13
   469                              <1> 
   470 00000732 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000           ;保留4级头表索引、页目录指针表索引和页目录表索引部分
   470 0000073B 00                  <1>
   471 0000073C 4D21F5              <1>          and r13, r14
   472 0000073F 49C1ED12            <1>          shr r13, 18                              ;原4级头表索引变成页目录表索引，原页目录指针表索引变
   473                              <1>                                                   ;页表索引，原页目录表索引变页内偏移
   474 00000743 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000           ;访问页目录表所用的地址前缀
   475 0000074A 4D01EE              <1>          add r14, r13
   476                              <1> 
   477 0000074D 415D                <1>          pop r13
   478                              <1> 
   479 0000074F C3                  <1>          ret
   480                              <1> 
   481                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   482                              <1> lin_to_lin_of_pte:                                ;返回指定的线性地址所对应的页表项的线性地址
   483                              <1>                                                   ;输入：R13=线性地址
   484                              <1>                                                   ;输出：R14=对应的页表项的线性地址
   485 00000750 4155                <1>          push r13
   486                              <1> 
   487 00000752 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000           ;保留4级头表、页目录指针表、页目录表和页表的索引部分
   487 0000075B 00                  <1>
   488 0000075C 4D21F5              <1>          and r13, r14
   489 0000075F 49C1ED09            <1>          shr r13, 9                               ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   490                              <1>                                                   ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   491 00000763 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000           ;访问页表所用的地址前缀
   491 0000076C FF                  <1>
   492 0000076D 4D01EE              <1>          add r14, r13
   493                              <1> 
   494 00000770 415D                <1>          pop r13
   495                              <1> 
   496 00000772 C3                  <1>          ret
   497                              <1> 
   498                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   499 00000773 0000000000000000    <1> _spaging_locker dq 0
   500                              <1> 
   501                              <1> setup_paging_for_laddr:                           ;为指定的线性地址安装分页系统（表项）
   502                              <1>                                                   ;输入：R13=线性地址
   503 0000077B 51                  <1>          push rcx
   504 0000077C 50                  <1>          push rax
   505 0000077D 4156                <1>          push r14
   506                              <1> 
   507 0000077F 9C                  <1>          pushfq                                   ;-->A
   508 00000780 FA                  <1>          cli
   509                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
    58                              <2>  %%spin_lock:
    59 00000781 48833DEAFFFFFF00    <2>  cmp %2, 0
    60 00000789 7404                <2>  je %%get_lock
    61 0000078B F390                <2>  pause
    62 0000078D EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000078F 41BE01000000        <2>  mov %1, 1
    65 00000795 4C8735D7FFFFFF      <2>  xchg %1, %2
    66 0000079C 4983FE00            <2>  cmp %1, 0
    67 000007A0 75DF                <2>  jne %%spin_lock
   510                              <1> 
   511                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   512                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   513 000007A2 E849FFFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   514 000007A7 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   515 000007AE 752B                <1>          jnz .b0
   516                              <1> 
   517                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   518 000007B0 E81DFFFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   519 000007B5 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   520 000007B9 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   521                              <1> 
   522                              <1>          ;清空刚分配的页目录指针表
   523 000007BC E84FFFFFFF          <1>          call lin_to_lin_of_pdpte
   524 000007C1 49C1EE0C            <1>          shr r14, 12
   525 000007C5 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   526 000007C9 B900020000          <1>          mov rcx, 512
   527                              <1>   .cls0:
   528 000007CE 49C70600000000      <1>          mov qword [r14], 0
   529 000007D5 4983C608            <1>          add r14, 8
   530 000007D9 E2F3                <1>          loop .cls0
   531                              <1> ;-------------------------------------------------
   532                              <1>   .b0:
   533                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   534 000007DB E830FFFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   535 000007E0 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   536 000007E7 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   537                              <1> 
   538                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   539 000007E9 E8E4FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   540 000007EE 4883C807            <1>          or rax, 0x07                             ;添加属性位
   541 000007F2 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   542                              <1> 
   543                              <1>          ;清空刚分配的页目录表
   544 000007F5 E836FFFFFF          <1>          call lin_to_lin_of_pdte
   545 000007FA 49C1EE0C            <1>          shr r14, 12
   546 000007FE 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   547 00000802 B900020000          <1>          mov rcx, 512
   548                              <1>   .cls1:
   549 00000807 49C70600000000      <1>          mov qword [r14], 0
   550 0000080E 4983C608            <1>          add r14, 8
   551 00000812 E2F3                <1>          loop .cls1
   552                              <1> ;-------------------------------------------------
   553                              <1>   .b1:
   554                              <1>          ;检查该线性地址所对应的页目录项是否存在
   555 00000814 E817FFFFFF          <1>          call lin_to_lin_of_pdte
   556 00000819 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   557 00000820 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   558                              <1> 
   559                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   560 00000822 E8ABFEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   561 00000827 4883C807            <1>          or rax, 0x07                             ;添加属性位
   562 0000082B 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   563                              <1> 
   564                              <1>          ;清空刚分配的页表
   565 0000082E E81DFFFFFF          <1>          call lin_to_lin_of_pte
   566 00000833 49C1EE0C            <1>          shr r14, 12
   567 00000837 49C1E60C            <1>          shl r14, 12                             ;得到页表的线性地址
   568 0000083B B900020000          <1>          mov rcx, 512
   569                              <1>   .cls2:
   570 00000840 49C70600000000      <1>          mov qword [r14], 0
   571 00000847 4983C608            <1>          add r14, 8
   572 0000084B E2F3                <1>          loop .cls2
   573                              <1> ;-------------------------------------------------
   574                              <1>   .b2:
   575                              <1>          ;检查该线性地址所对应的页表项是否存在
   576 0000084D E8FEFEFFFF          <1>          call lin_to_lin_of_pte
   577 00000852 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   578 00000859 750C                <1>          jnz .b3                                  ;页表项已经存在，转.b3
   579                              <1> 
   580                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   581 0000085B E872FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页
   582 00000860 4883C807            <1>          or rax, 0x07                             ;添加属性位
   583 00000864 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   584                              <1> 
   585                              <1>   .b3:
   586 00000867 48C70501FFFFFF0000- <1>          mov qword [rel _spaging_locker], 0
   586 00000870 0000                <1>
   587 00000872 9D                  <1>          popfq                                    ;A
   588                              <1> 
   589 00000873 415E                <1>          pop r14
   590 00000875 58                  <1>          pop rax
   591 00000876 59                  <1>          pop rcx
   592                              <1> 
   593 00000877 C3                  <1>          ret
   594                              <1> 
   595                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   596 00000878 0000000000000000    <1> _mapping_locker dq 0
   597                              <1> 
   598                              <1> mapping_laddr_to_page:                            ;建立线性地址到物理页的映射
   599                              <1>                                                   ;即，为指定的线性地址安装指定的物理页
   600                              <1>                                                   ;输入：R13=线性地址
   601                              <1>                                                   ;      RAX=页的物理地址（含属性）
   602 00000880 51                  <1>          push rcx
   603 00000881 4156                <1>          push r14
   604                              <1> 
   605 00000883 9C                  <1>          pushfq
   606 00000884 FA                  <1>          cli
   607                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
    58                              <2>  %%spin_lock:
    59 00000885 48833DEBFFFFFF00    <2>  cmp %2, 0
    60 0000088D 7404                <2>  je %%get_lock
    61 0000088F F390                <2>  pause
    62 00000891 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000893 41BE01000000        <2>  mov %1, 1
    65 00000899 4C8735D8FFFFFF      <2>  xchg %1, %2
    66 000008A0 4983FE00            <2>  cmp %1, 0
    67 000008A4 75DF                <2>  jne %%spin_lock
   608                              <1> 
   609 000008A6 50                  <1>          push rax
   610                              <1> 
   611                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   612                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   613 000008A7 E844FEFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   614 000008AC 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   615 000008B3 752B                <1>          jnz .b0
   616                              <1> 
   617                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   618 000008B5 E818FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   619 000008BA 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   620 000008BE 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   621                              <1> 
   622                              <1>          ;清空刚分配的页目录指针表
   623 000008C1 E84AFEFFFF          <1>          call lin_to_lin_of_pdpte
   624 000008C6 49C1EE0C            <1>          shr r14, 12
   625 000008CA 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   626 000008CE B900020000          <1>          mov rcx, 512
   627                              <1>   .cls0:
   628 000008D3 49C70600000000      <1>          mov qword [r14], 0
   629 000008DA 4983C608            <1>          add r14, 8
   630 000008DE E2F3                <1>          loop .cls0
   631                              <1> ;-------------------------------------------------
   632                              <1>   .b0:
   633                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   634 000008E0 E82BFEFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   635 000008E5 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   636 000008EC 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   637                              <1> 
   638                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   639 000008EE E8DFFDFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   640 000008F3 4883C807            <1>          or rax, 0x07                             ;添加属性位
   641 000008F7 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   642                              <1> 
   643                              <1>          ;清空刚分配的页目录表
   644 000008FA E831FEFFFF          <1>          call lin_to_lin_of_pdte
   645 000008FF 49C1EE0C            <1>          shr r14, 12
   646 00000903 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   647 00000907 B900020000          <1>          mov rcx, 512
   648                              <1>   .cls1:
   649 0000090C 49C70600000000      <1>          mov qword [r14], 0
   650 00000913 4983C608            <1>          add r14, 8
   651 00000917 E2F3                <1>          loop .cls1
   652                              <1> ;-------------------------------------------------
   653                              <1>   .b1:
   654                              <1>          ;检查该线性地址所对应的页目录项是否存在
   655 00000919 E812FEFFFF          <1>          call lin_to_lin_of_pdte
   656 0000091E 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   657 00000925 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   658                              <1> 
   659                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   660 00000927 E8A6FDFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   661 0000092C 4883C807            <1>          or rax, 0x07                             ;添加属性位
   662 00000930 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   663                              <1> 
   664                              <1>          ;清空刚分配的页表
   665 00000933 E818FEFFFF          <1>          call lin_to_lin_of_pte
   666 00000938 49C1EE0C            <1>          shr r14, 12
   667 0000093C 49C1E60C            <1>          shl r14, 12                              ;得到页表的线性地址
   668 00000940 B900020000          <1>          mov rcx, 512
   669                              <1>   .cls2:
   670 00000945 49C70600000000      <1>          mov qword [r14], 0
   671 0000094C 4983C608            <1>          add r14, 8
   672 00000950 E2F3                <1>          loop .cls2
   673                              <1> ;-------------------------------------------------
   674                              <1>   .b2:
   675 00000952 E8F9FDFFFF          <1>          call lin_to_lin_of_pte                   ;得到页表项的线性地址
   676 00000957 58                  <1>          pop rax
   677 00000958 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   678                              <1> 
   679 0000095B 48C70512FFFFFF0000- <1>          mov qword [rel _mapping_locker], 0
   679 00000964 0000                <1>
   680 00000966 9D                  <1>          popfq
   681                              <1> 
   682 00000967 415E                <1>          pop r14
   683 00000969 59                  <1>          pop rcx
   684                              <1> 
   685 0000096A C3                  <1>          ret
   686                              <1> 
   687                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   688 0000096B 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START          ;下一次分配时可用的起始线性地址
   689 00000973 0000000000000000    <1>   _core_alloc_locker dq 0
   690                              <1> 
   691                              <1> core_memory_allocate:                             ;在虚拟地址空间的高端（内核）分配内存
   692                              <1>                                                   ;输入：RCX=请求分配的字节数
   693                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   694                              <1>                                                   ;      R14=下次分配的起始线性地址
   695 0000097B 9C                  <1>          pushfq                                   ;A-->
   696 0000097C FA                  <1>          cli
   697                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
    58                              <2>  %%spin_lock:
    59 0000097D 48833DEEFFFFFF00    <2>  cmp %2, 0
    60 00000985 7404                <2>  je %%get_lock
    61 00000987 F390                <2>  pause
    62 00000989 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000098B 41BE01000000        <2>  mov %1, 1
    65 00000991 4C8735DBFFFFFF      <2>  xchg %1, %2
    66 00000998 4983FE00            <2>  cmp %1, 0
    67 0000099C 75DF                <2>  jne %%spin_lock
   698                              <1> 
   699 0000099E 4C8B2DC6FFFFFF      <1>          mov r13, [rel _core_next_linear]         ;获得本次分配的起始线性地址
   700 000009A5 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   701                              <1> 
   702 000009AA 49F7C607000000      <1>          test r14, 0x07                           ;最低3位是000吗（是否按8字节对齐）？
   703 000009B1 740C                <1>          jz .algn
   704 000009B3 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   705 000009B7 49C1EE03            <1>          shr r14, 3
   706 000009BB 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   707                              <1> 
   708                              <1>   .algn:
   709 000009BF 4C8935A5FFFFFF      <1>          mov [rel _core_next_linear], r14         ;写回。
   710                              <1> 
   711 000009C6 48C705A2FFFFFF0000- <1>          mov qword [rel _core_alloc_locker], 0    ;释放锁
   711 000009CF 0000                <1>
   712 000009D1 9D                  <1>          popfq                                    ;A
   713                              <1> 
   714 000009D2 4155                <1>          push r13
   715 000009D4 4156                <1>          push r14
   716                              <1> 
   717                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   718 000009D6 49C1ED0C            <1>          shr r13, 12
   719 000009DA 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   720 000009DE 49C1EE0C            <1>          shr r14, 12
   721 000009E2 49C1E60C            <1>          shl r14, 12                              ;too
   722                              <1>   .next:
   723 000009E6 E890FDFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   724 000009EB 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   725 000009F2 4D39F5              <1>          cmp r13, r14
   726 000009F5 7EEF                <1>          jle .next
   727                              <1> 
   728 000009F7 415E                <1>          pop r14
   729 000009F9 415D                <1>          pop r13
   730                              <1> 
   731 000009FB C3                  <1>          ret
   732                              <1> 
   733                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   734                              <1> user_memory_allocate:                             ;在用户任务的私有空间（低端）分配内存
   735                              <1>                                                   ;输入：R11=任务控制块PCB的线性地址
   736                              <1>                                                   ;      RCX=希望分配的字节数
   737                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   738                              <1>                                                   ;      R14=下次分配的起始线性地址
   739                              <1>          ;获得本次内存分配的起始线性地址
   740 000009FC 4D8B6B18            <1>          mov r13, [r11 + 24]                      ;获得本次分配的起始线性地址
   741 00000A00 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   742                              <1> 
   743 00000A05 49F7C607000000      <1>          test r14, 0x07                           ;能够被8整除吗（是否按8字节对齐）？
   744 00000A0C 740C                <1>          jz .algn
   745 00000A0E 49C1EE03            <1>          shr r14, 3
   746 00000A12 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   747 00000A16 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   748                              <1> 
   749                              <1>   .algn:
   750 00000A1A 4D897318            <1>          mov [r11 + 24], r14                      ;写回PCB中。
   751                              <1> 
   752 00000A1E 4155                <1>          push r13
   753 00000A20 4156                <1>          push r14
   754                              <1> 
   755                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   756 00000A22 49C1ED0C            <1>          shr r13, 12
   757 00000A26 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   758 00000A2A 49C1EE0C            <1>          shr r14, 12
   759 00000A2E 49C1E60C            <1>          shl r14, 12                              ;too
   760                              <1>   .next:
   761 00000A32 E844FDFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   762 00000A37 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   763 00000A3E 4D39F5              <1>          cmp r13, r14
   764 00000A41 7EEF                <1>          jle .next
   765                              <1> 
   766 00000A43 415E                <1>          pop r14
   767 00000A45 415D                <1>          pop r13
   768                              <1> 
   769 00000A47 C3                  <1>          ret
   770                              <1> 
   771                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   772 00000A48 0000000000000000    <1> _copy_locker dq 0
   773                              <1> 
   774                              <1> copy_current_pml4:                                ;创建新的4级头表，并复制当前4级头表的内容
   775                              <1>                                                   ;输入：无
   776                              <1>                                                   ;输出：RAX=新4级头表的物理地址及属性
   777 00000A50 56                  <1>          push rsi
   778 00000A51 57                  <1>          push rdi
   779 00000A52 4155                <1>          push r13
   780 00000A54 51                  <1>          push rcx
   781                              <1> 
   782 00000A55 9C                  <1>          pushfq                                   ;-->A
   783 00000A56 FA                  <1>          cli
   784                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
    58                              <2>  %%spin_lock:
    59 00000A57 48833DE9FFFFFF00    <2>  cmp %2, 0
    60 00000A5F 7404                <2>  je %%get_lock
    61 00000A61 F390                <2>  pause
    62 00000A63 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000A65 B901000000          <2>  mov %1, 1
    65 00000A6A 48870DD7FFFFFF      <2>  xchg %1, %2
    66 00000A71 4883F900            <2>  cmp %1, 0
    67 00000A75 75E0                <2>  jne %%spin_lock
   785                              <1> 
   786 00000A77 E856FCFFFF          <1>          call allocate_a_4k_page                  ;分配一个物理页
   787 00000A7C 4883C807            <1>          or rax, 0x07                             ;立即数符号扩展到64位参与操作
   788 00000A80 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR                 ;用指定的线性地址映射和访问这个页
   788 00000A89 FF                  <1>
   789 00000A8A E8F1FDFFFF          <1>          call mapping_laddr_to_page
   790                              <1> 
   791                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   792 00000A8F 410F017D00          <1>          invlpg [r13]
   793                              <1> 
   794 00000A94 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000           ;RSI->当前活动4级头表的线性地址
   795 00000A9B 4C89EF              <1>          mov rdi, r13                             ;RDI->新4级头表的线性地址
   796 00000A9E B900020000          <1>          mov rcx, 512                             ;RCX=要复制的目录项数
   797 00000AA3 FC                  <1>          cld
   798 00000AA4 F348A5              <1>          repe movsq
   799                              <1> 
   800 00000AA7 498985F80F0000      <1>          mov [r13 + 0xff8], rax                   ;新4级头表的511号表项指向它自己
   801 00000AAE 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   802                              <1> 
   803 00000AB6 48C70587FFFFFF0000- <1>          mov qword [rel _copy_locker], 0
   803 00000ABF 0000                <1>
   804 00000AC1 9D                  <1>          popfq                                    ;A
   805                              <1> 
   806 00000AC2 59                  <1>          pop rcx
   807 00000AC3 415D                <1>          pop r13
   808 00000AC5 5F                  <1>          pop rdi
   809 00000AC6 5E                  <1>          pop rsi
   810                              <1> 
   811 00000AC7 C3                  <1>          ret
   812                              <1> 
   813                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   814 00000AC8 0000000000000000    <1> _cmos_locker dq 0
   815                              <1> 
   816                              <1> get_cmos_time:                                    ;从CMOS中获取当前时间
   817                              <1>                                                   ;输入：RBX=缓冲区线性地址
   818 00000AD0 50                  <1>          push rax
   819                              <1> 
   820 00000AD1 9C                  <1>          pushfq                                   ;-->A
   821 00000AD2 FA                  <1>          cli
   822                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
    58                              <2>  %%spin_lock:
    59 00000AD3 48833DEDFFFFFF00    <2>  cmp %2, 0
    60 00000ADB 7404                <2>  je %%get_lock
    61 00000ADD F390                <2>  pause
    62 00000ADF EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000AE1 B801000000          <2>  mov %1, 1
    65 00000AE6 488705DBFFFFFF      <2>  xchg %1, %2
    66 00000AED 4883F800            <2>  cmp %1, 0
    67 00000AF1 75E0                <2>  jne %%spin_lock
   823                              <1> 
   824                              <1>   .w0:
   825 00000AF3 B08A                <1>          mov al, 0x8a
   826 00000AF5 E670                <1>          out 0x70, al
   827 00000AF7 E471                <1>          in al, 0x71                              ;读寄存器A
   828 00000AF9 A880                <1>          test al, 0x80                            ;测试第7位UIP，等待更新周期结束。
   829 00000AFB 75F6                <1>          jnz .w0
   830                              <1> 
   831 00000AFD B084                <1>          mov al, 0x84
   832 00000AFF E670                <1>          out 0x70, al
   833 00000B01 E471                <1>          in al, 0x71                              ;读RTC当前时间(时)
   834 00000B03 88C4                <1>          mov ah, al
   835                              <1> 
   836 00000B05 C0EC04              <1>          shr ah, 4
   837 00000B08 80E40F              <1>          and ah, 0x0f
   838 00000B0B 80C430              <1>          add ah, 0x30
   839 00000B0E 8823                <1>          mov [rbx], ah
   840                              <1> 
   841 00000B10 240F                <1>          and al, 0x0f
   842 00000B12 0430                <1>          add al, 0x30
   843 00000B14 884301              <1>          mov [rbx + 1], al
   844                              <1> 
   845 00000B17 C643023A            <1>          mov byte [rbx + 2], ':'
   846                              <1> 
   847 00000B1B B082                <1>          mov al, 0x82
   848 00000B1D E670                <1>          out 0x70, al
   849 00000B1F E471                <1>          in al, 0x71                              ;读RTC当前时间(分)
   850 00000B21 88C4                <1>          mov ah, al
   851                              <1> 
   852 00000B23 C0EC04              <1>          shr ah, 4
   853 00000B26 80E40F              <1>          and ah, 0x0f
   854 00000B29 80C430              <1>          add ah, 0x30
   855 00000B2C 886303              <1>          mov [rbx + 3], ah
   856                              <1> 
   857 00000B2F 240F                <1>          and al, 0x0f
   858 00000B31 0430                <1>          add al, 0x30
   859 00000B33 884304              <1>          mov [rbx + 4], al
   860                              <1> 
   861 00000B36 C643053A            <1>          mov byte [rbx + 5], ':'
   862                              <1> 
   863 00000B3A B080                <1>          mov al, 0x80
   864 00000B3C E670                <1>          out 0x70, al
   865 00000B3E E471                <1>          in al, 0x71                              ;读RTC当前时间(秒)
   866 00000B40 88C4                <1>          mov ah, al                               ;分拆成两个数字
   867                              <1> 
   868 00000B42 C0EC04              <1>          shr ah, 4                                ;逻辑右移4位
   869 00000B45 80E40F              <1>          and ah, 0x0f
   870 00000B48 80C430              <1>          add ah, 0x30
   871 00000B4B 886306              <1>          mov [rbx + 6], ah
   872                              <1> 
   873 00000B4E 240F                <1>          and al, 0x0f                             ;仅保留低4位
   874 00000B50 0430                <1>          add al, 0x30                             ;转换成ASCII
   875 00000B52 884307              <1>          mov [rbx + 7], al
   876                              <1> 
   877 00000B55 C6430800            <1>          mov byte [rbx + 8], 0                    ;空字符终止
   878                              <1> 
   879 00000B59 48C70564FFFFFF0000- <1>          mov qword [rel _cmos_locker], 0
   879 00000B62 0000                <1>
   880 00000B64 9D                  <1>          popfq                                    ;A
   881                              <1> 
   882 00000B65 58                  <1>          pop rax
   883                              <1> 
   884 00000B66 C3                  <1>          ret
   885                              <1> 
   886                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   887 00000B67 0000000000000000    <1>   _process_id        dq 0
   888                              <1> generate_process_id:                              ;生成唯一的进程标识
   889                              <1>                                                   ;返回：RAX=进程标识
   890 00000B6F B801000000          <1>          mov rax, 1
   891 00000B74 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   892                              <1> 
   893 00000B7D C3                  <1>          ret
   894                              <1> 
   895                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   896                              <1> ;  _thread_id dq 0
   897                              <1> 
   898                              <1> ;generate_thread_id:                               ;生成唯一的线程标识
   899                              <1>                                                   ;返回：RAX=线程标识
   900                              <1> ;         mov rax, 1
   901                              <1> ;         lock xadd qword [rel _thread_id], rax
   902                              <1> 
   903                              <1> ;         ret
   904                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   905 00000B7E 08                  <1>   _screen_row        db 8
   906                              <1> get_screen_row:                                   ;返回下一个屏幕坐标行的行号
   907                              <1>                                                   ;返回：DH=行号
   908 00000B7F B601                <1>          mov dh, 1
   909 00000B81 F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   910                              <1> 
   911 00000B89 C3                  <1>          ret
   912                              <1> 
   913                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   914                              <1> get_cpu_number:                                   ;返回当前处理器的编号
   915                              <1>                                                   ;返回：RAX=处理器编号
   916 00000B8A 9C                  <1>          pushfq
   917 00000B8B FA                  <1>          cli
   918 00000B8C 0F01F8              <1>          swapgs
   919 00000B8F 65488B042510000000  <1>          mov rax, [gs:16]                         ;从处理器专属数据区取回
   920 00000B98 0F01F8              <1>          swapgs
   921 00000B9B 9D                  <1>          popfq
   922 00000B9C C3                  <1>          ret
   923                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   924                              <1> 
    44                                  %include "..\common\user_static64.lib"
    45                              <1> ;用户程序使用的例程库，用来模拟高级语言的静态库。有些功能直接在本文件中实现，但
    46                              <1> ;有些功能需要通过syscall指令使用内核提供的系统调用。
    47                              <1> ;创建时间：2022-01-30 18:30，李忠
    48                              <1> ;此文件需要用预处理指令%include引入用户程序。
    49                              <1> 
    50                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    51                              <1>          bits 64
    52                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    53                              <1> bin64_to_dec:                                     ;将二进制数转换为十进制字符串。
    54                              <1>                                                   ;输入：R8=64位二进制数
    55                              <1>                                                   ;      RBX=目标缓冲区线性地址
    56 00000B9D 50                  <1>          push rax
    57 00000B9E 53                  <1>          push rbx
    58 00000B9F 51                  <1>          push rcx
    59 00000BA0 52                  <1>          push rdx
    60 00000BA1 4150                <1>          push r8
    61                              <1> 
    62 00000BA3 4C89C0              <1>          mov rax, r8                              ;!!
    63 00000BA6 41B80A000000        <1>          mov r8, 10
    64 00000BAC 4831C9              <1>          xor rcx, rcx
    65                              <1> 
    66                              <1>   .next_div:
    67 00000BAF 4831D2              <1>          xor rdx, rdx
    68 00000BB2 49F7F0              <1>          div r8
    69 00000BB5 52                  <1>          push rdx                                 ;保存分解的数位
    70 00000BB6 48FFC1              <1>          inc rcx                                  ;递增压栈的次数
    71 00000BB9 4809C0              <1>          or rax, rax                              ;商为0？
    72 00000BBC 7402                <1>          jz .rotate
    73 00000BBE EBEF                <1>          jmp .next_div
    74                              <1> 
    75                              <1>   .rotate:
    76 00000BC0 5A                  <1>          pop rdx
    77 00000BC1 80C230              <1>          add dl, 0x30                             ;数位转换成ASCII编码
    78 00000BC4 8813                <1>          mov [rbx], dl
    79 00000BC6 48FFC3              <1>          inc rbx
    80 00000BC9 E2F5                <1>          loop .rotate
    81                              <1> 
    82 00000BCB C60300              <1>          mov byte [rbx], 0
    83                              <1> 
    84 00000BCE 4158                <1>          pop r8
    85 00000BD0 5A                  <1>          pop rdx
    86 00000BD1 59                  <1>          pop rcx
    87 00000BD2 5B                  <1>          pop rbx
    88 00000BD3 58                  <1>          pop rax
    89                              <1> 
    90 00000BD4 C3                  <1>          ret                                      ;段内返回
    91                              <1> 
    92                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    93                              <1> string_concatenates:                              ;将源字符串连接到目的字符串的尾部
    94                              <1>                                                   ;输入：RSI=源字符串的线性地址
    95                              <1>                                                   ;      RDI=目的字符串的线性地址
    96 00000BD5 50                  <1>          push rax
    97 00000BD6 56                  <1>          push rsi
    98 00000BD7 57                  <1>          push rdi
    99                              <1> 
   100                              <1>   .r0:
   101 00000BD8 803F00              <1>          cmp byte [rdi], 0
   102 00000BDB 7405                <1>          jz .r1
   103 00000BDD 48FFC7              <1>          inc rdi
   104 00000BE0 EBF6                <1>          jmp .r0
   105                              <1> 
   106                              <1>   .r1:
   107 00000BE2 8A06                <1>          mov al, [rsi]
   108 00000BE4 8807                <1>          mov [rdi], al
   109 00000BE6 3C00                <1>          cmp al, 0
   110 00000BE8 7408                <1>          jz .r2
   111 00000BEA 48FFC6              <1>          inc rsi
   112 00000BED 48FFC7              <1>          inc rdi
   113 00000BF0 EBF0                <1>          jmp .r1
   114                              <1> 
   115                              <1>   .r2:
   116 00000BF2 5F                  <1>          pop rdi
   117 00000BF3 5E                  <1>          pop rsi
   118 00000BF4 58                  <1>          pop rax
   119                              <1> 
   120 00000BF5 C3                  <1>          ret
   121                              <1> 
   122                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   123                              <1> 
    45                                           bits 64
    46                                  
    47                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    48 00000BF6 F900                      _ap_string      db 249, 0
    49                                  
    50                                  ap_to_core_entry:                                 ;应用处理器（AP）进入内核的入口点
    51                                           ;启用GDT的高端线性地址并加载IDTR
    52 00000BF8 48B8007E00000080FF-              mov rax, UPPER_SDA_LINEAR
    52 00000C01 FF                 
    53 00000C02 0F015002                         lgdt [rax + 2]                           ;只有在64位模式下才能加载64位线性地址部分
    54 00000C06 0F01580C                         lidt [rax + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
    55                                  
    56                                           ;为当前处理器创建64位模式下的专属栈
    57 00000C0A B900100000                       mov rcx, 4096
    58 00000C0F E867FDFFFF                       call core_memory_allocate
    59 00000C14 4C89F4                           mov rsp, r14
    60                                  
    61                                           ;创建当前处理器的专属存储区（含TSS），并安装TSS描述符到GDT
    62 00000C17 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
    63 00000C1C E85AFDFFFF                       call core_memory_allocate
    64 00000C21 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
    65 00000C28 E8B7F5FFFF                       call make_tss_descriptor
    66                                  
    67 00000C2D 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区的高端线性地址（低端亦可）
    67 00000C36 FF                 
    68                                  
    69 00000C37 4D8B4704                         mov r8, [r15 + 4]                        ;R8=GDT的线性地址
    70 00000C3B 490FB74F02                       movzx rcx, word [r15 + 2]                ;RCX=GDT的界限值
    71 00000C40 4989740801                       mov [r8 + rcx + 1], rsi                  ;TSS描述符的低64位
    72 00000C45 49897C0809                       mov [r8 + rcx + 9], rdi                  ;TSS描述符的高64位
    73                                  
    74 00000C4A 664183470210                     add word [r15 + 2], 16
    75 00000C50 410F015702                       lgdt [r15 + 2]                           ;重新加载GDTR
    76                                  
    77 00000C55 66C1E903                         shr cx, 3                                ;除以8（消除余数），得到索引号
    78 00000C59 66FFC1                           inc cx                                   ;索引号递增
    79 00000C5C 66C1E103                         shl cx, 3                                ;将索引号移到正确位置
    80                                  
    81 00000C60 0F00D9                           ltr cx                                   ;为当前处理器加载任务寄存器TR
    82                                  
    83                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
    84 00000C63 B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
    85 00000C68 4C89E8                           mov rax, r13                             ;只用EAX
    86 00000C6B 4C89EA                           mov rdx, r13
    87 00000C6E 48C1EA20                         shr rdx, 32                              ;只用EDX
    88 00000C72 0F30                             wrmsr
    89                                  
    90                                           ;为快速系统调用SYSCALL和SYSRET准备参数
    91 00000C74 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
    92 00000C79 0F32                             rdmsr
    93 00000C7B 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
    94 00000C7F 0F30                             wrmsr
    95                                  
    96 00000C81 B9810000C0                       mov ecx, 0xc0000081                      ;STAR
    97 00000C86 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
    98 00000C8B 31C0                             xor eax, eax
    99 00000C8D 0F30                             wrmsr
   100                                  
   101 00000C8F B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   102 00000C94 488B05(08000000)                 mov rax, [rel position]
   103 00000C9B 488D80[AD110000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   104 00000CA2 4889C2                           mov rdx, rax
   105 00000CA5 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   106 00000CA9 0F30                             wrmsr
   107                                  
   108 00000CAB B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   109 00000CB0 31D2                             xor edx, edx
   110 00000CB2 B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   111 00000CB7 0F30                             wrmsr
   112                                  
   113 00000CB9 4C8B3D(08000000)                 mov r15, [rel position]
   114 00000CC0 498D9F[F60B0000]                 lea rbx, [r15 + _ap_string]
   115 00000CC7 E83CF3FFFF                       call put_string64                        ;位于core_utils64.wid
   116                                  
   117 00000CCC 0F01F8                           swapgs                                   ;准备用GS操作当前处理器的专属数据
   118 00000CCF 6548C7042508000000-              mov qword [gs:8], 0                      ;没有正在执行的任务
   118 00000CD8 00000000           
   119 00000CDC 4831C0                           xor rax, rax
   120 00000CDF 8A05(31010000)                   mov al, byte [rel ack_cpus]
   121 00000CE5 654889042510000000               mov [gs:16], rax                         ;设置当前处理器的编号
   122 00000CEE 654889242518000000               mov [gs:24], rsp                         ;保存当前处理器的固有栈指针
   123 00000CF7 0F01F8                           swapgs
   124                                  
   125 00000CFA FE05(31010000)                   inc byte [rel ack_cpus]                  ;递增应答计数值
   126                                  
   127 00000D00 C60425[82F00000]00               mov byte [AP_START_UP_ADDR + lock_var], 0;释放自旋锁
   128                                  
   129 00000D08 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   129 00000D11 FF                 
   130 00000D12 0FBAAEF000000008                 bts dword [rsi + 0xf0], 8                ;设置SVR寄存器，允许LAPIC
   131                                  
   132 00000D1A FB                               sti                                      ;开放中断
   133                                  
   134                                    .do_idle:
   135 00000D1B F4                               hlt
   136 00000D1C EBFD                             jmp .do_idle
   137                                  
   138                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   139                                  general_interrupt_handler:                        ;通用中断处理过程
   140 00000D1E 48CF                             iretq
   141                                  
   142                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   143                                  general_exception_handler:                        ;通用异常处理过程
   144                                                                                    ;在24行0列显示红底白字的错误信息
   145 00000D20 4C8B3D(08000000)                 mov r15, [rel position]
   146 00000D27 498D9F[3C0D0000]                 lea rbx, [r15 + exceptm]
   147 00000D2E B618                             mov dh, 24
   148 00000D30 B200                             mov dl, 0
   149 00000D32 41B14F                           mov r9b, 0x4f
   150 00000D35 E8DFF3FFFF                       call put_cstringxy64                     ;位于core_utils64.wid
   151                                  
   152 00000D3A FA                               cli
   153 00000D3B F4                               hlt                                      ;停机且不接受外部硬件中断
   154                                  
   155 00000D3C 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
   155 00000D45 6F6E20726169736564-
   155 00000D4E 2C68616C742E00     
   156                                  
   157                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   158                                  search_for_a_ready_task:                          ;查找一个就绪的任务并将其置为忙
   159                                                                                    ;返回：R11=就绪任务的PCB线性地址
   160                                           ;此例程通常是在中断处理过程内调用，默认中断是关闭状态。
   161 00000D55 50                               push rax
   162 00000D56 53                               push rbx
   163 00000D57 51                               push rcx
   164                                  
   165 00000D58 B901000000                       mov rcx, 1                               ;RCX=任务的“忙”状态
   166                                  
   167 00000D5D 0F01F8                           swapgs
   168 00000D60 65488B1C2508000000               mov rbx, [gs:8]                          ;取得当前任务的PCB线性地址
   169 00000D69 0F01F8                           swapgs
   170 00000D6C 4989DB                           mov r11, rbx
   171 00000D6F 4883FB00                         cmp rbx, 0                               ;处理器当前未在执行任务？
   172 00000D73 750A                             jne .again
   173 00000D75 488B1D(A1020000)                 mov rbx, [rel pcb_ptr]                   ;是的。从链表首节点开始搜索。
   174 00000D7C 4989DB                           mov r11, rbx
   175                                    .again:
   176 00000D7F 4D8B9B18010000                   mov r11, [r11 + 280]                     ;取得下一个节点
   177 00000D86 4831C0                           xor rax, rax
   178 00000D89 F0490FB14B10                     lock cmpxchg [r11 + 16], rcx             ;开发无锁算法的挑战并不是完全
   179                                           ;消除竞争，它可以归结为将代码的关键部分减少到由CPU本身提供的单个原子操作。
   180 00000D8F 740A                             jz .retrn
   181 00000D91 4939DB                           cmp r11, rbx                             ;是否转一圈回到当前节点？
   182 00000D94 7402                             je .fmiss                                ;是。未找到就绪任务（节点）
   183 00000D96 EBE7                             jmp .again
   184                                  
   185                                    .fmiss:
   186 00000D98 4D31DB                           xor r11, r11
   187                                    .retrn:
   188 00000D9B 59                               pop rcx
   189 00000D9C 5B                               pop rbx
   190 00000D9D 58                               pop rax
   191 00000D9E C3                               ret
   192                                  
   193                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   194                                  resume_execute_a_task:                            ;恢复执行一个任务
   195                                                                                    ;传入：R11=指定任务的PCB线性地址
   196                                           ;此例程在中断处理过程内调用，默认中断是关闭状态。
   197 00000D9F 8B05(32010000)                   mov eax, [rel clocks_1ms]                ;以下计算新任务运行时间
   198 00000DA5 418B9BF0000000                   mov ebx, [r11 + 240]                     ;为任务指定的时间片
   199 00000DAC F7E3                             mul ebx
   200                                  
   201 00000DAE 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   201 00000DB7 FF                 
   202 00000DB8 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;1分频
   202 00000DC1 00                 
   203 00000DC2 C78620030000FD0000-              mov dword [rsi + 0x320], 0xfd            ;单次击发模式，Fixed，中断号0xfd
   203 00000DCB 00                 
   204                                  
   205 00000DCC 498B5B38                         mov rbx, [r11 + 56]
   206 00000DD0 0F22DB                           mov cr3, rbx                             ;切换地址空间
   207                                  
   208 00000DD3 0F01F8                           swapgs
   209 00000DD6 654C891C2508000000               mov [gs:8], r11                          ;将新任务设置为当前任务
   210                                           ;mov qword [r11 + 16], 1                  ;置任务状态为忙
   211 00000DDF 498B5B20                         mov rbx, [r11 + 32]                      ;取PCB中的RSP0
   212 00000DE3 6548891C2584000000               mov [gs:128 + 4], rbx                    ;置TSS的RSP0
   213 00000DEC 0F01F8                           swapgs
   214                                  
   215 00000DEF 498B4B50                         mov rcx, [r11 + 80]
   216 00000DF3 498B5358                         mov rdx, [r11 + 88]
   217 00000DF7 498B7B68                         mov rdi, [r11 + 104]
   218 00000DFB 498B6B70                         mov rbp, [r11 + 112]
   219 00000DFF 498B6378                         mov rsp, [r11 + 120]
   220 00000E03 4D8B8380000000                   mov r8, [r11 + 128]
   221 00000E0A 4D8B8B88000000                   mov r9, [r11 + 136]
   222 00000E11 4D8B9390000000                   mov r10, [r11 + 144]
   223 00000E18 4D8BA3A0000000                   mov r12, [r11 + 160]
   224 00000E1F 4D8BABA8000000                   mov r13, [r11 + 168]
   225 00000E26 4D8BB3B0000000                   mov r14, [r11 + 176]
   226 00000E2D 4D8BBBB8000000                   mov r15, [r11 + 184]
   227 00000E34 41FFB3D0000000                   push qword [r11 + 208]                   ;SS
   228 00000E3B 41FF7378                         push qword [r11 + 120]                   ;RSP
   229 00000E3F 41FFB3E8000000                   push qword [r11 + 232]                   ;RFLAGS
   230 00000E46 41FFB3C8000000                   push qword [r11 + 200]                   ;CS
   231 00000E4D 41FFB3C0000000                   push qword [r11 + 192]                   ;RIP
   232                                  
   233 00000E54 898680030000                     mov dword [rsi + 0x380], eax             ;开始计时
   234                                  
   235 00000E5A 498B4340                         mov rax, [r11 + 64]
   236 00000E5E 498B5B48                         mov rbx, [r11 + 72]
   237 00000E62 498B7360                         mov rsi, [r11 + 96]
   238 00000E66 4D8B9B98000000                   mov r11, [r11 + 152]
   239                                  
   240 00000E6D 48CF                             iretq                                    ;转入新任务的空间执行
   241                                  
   242                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   243                                  time_slice_out_handler:                           ;时间片到期中断的处理过程
   244 00000E6F 50                               push rax
   245 00000E70 53                               push rbx
   246 00000E71 4153                             push r11
   247                                  
   248 00000E73 49BB00E0FFFF7FFFFF-              mov r11, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
   248 00000E7C FF                 
   249 00000E7D 41C783B00000000000-              mov dword [r11 + 0xb0], 0
   249 00000E86 0000               
   250                                  
   251 00000E88 E8C8FEFFFF                       call search_for_a_ready_task
   252 00000E8D 4D09DB                           or r11, r11
   253 00000E90 0F8494000000                     jz .return                               ;未找到就绪的任务
   254                                  
   255 00000E96 0F01F8                           swapgs
   256 00000E99 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   257 00000EA2 0F01F8                           swapgs
   258                                  
   259                                           ;保存当前任务的状态以便将来恢复执行。
   260 00000EA5 0F20DB                           mov rbx, cr3                             ;保存原任务的分页系统
   261 00000EA8 48895838                         mov qword [rax + 56], rbx
   262                                           ;mov [rax + 64], rax                      ;不需设置，将来恢复执行时从栈中弹出
   263                                           ;mov [rax + 72], rbx                      ;不需设置，将来恢复执行时从栈中弹出
   264 00000EAC 48894850                         mov [rax + 80], rcx
   265 00000EB0 48895058                         mov [rax + 88], rdx
   266 00000EB4 48897060                         mov [rax + 96], rsi
   267 00000EB8 48897868                         mov [rax + 104], rdi
   268 00000EBC 48896870                         mov [rax + 112], rbp
   269 00000EC0 48896078                         mov [rax + 120], rsp
   270 00000EC4 4C898080000000                   mov [rax + 128], r8
   271 00000ECB 4C898888000000                   mov [rax + 136], r9
   272 00000ED2 4C899090000000                   mov [rax + 144], r10
   273                                           ;mov [rax + 152], r11                     ;不需设置，将来恢复执行时从栈中弹出
   274 00000ED9 4C89A0A0000000                   mov [rax + 160], r12
   275 00000EE0 4C89A8A8000000                   mov [rax + 168], r13
   276 00000EE7 4C89B0B0000000                   mov [rax + 176], r14
   277 00000EEE 4C89B8B8000000                   mov [rax + 184], r15
   278 00000EF5 488B1D(08000000)                 mov rbx, [rel position]
   279 00000EFC 488D9B[2A0F0000]                 lea rbx, [rbx + .return]                 ;将来恢复执行时，是从中断返回也～
   280 00000F03 488998C0000000                   mov [rax + 192], rbx                     ;RIP域为中断返回点
   281 00000F0A 8C88C8000000                     mov [rax + 200], cs
   282 00000F10 8C90D0000000                     mov [rax + 208], ss
   283 00000F16 9C                               pushfq
   284 00000F17 8F80E8000000                     pop qword [rax + 232]
   285                                  
   286 00000F1D 48C7401000000000                 mov qword [rax + 16], 0                  ;置任务状态为就绪
   287                                  
   288 00000F25 E975FEFFFF                       jmp resume_execute_a_task                ;恢复并执行新任务
   289                                  
   290                                    .return:
   291 00000F2A 415B                             pop r11
   292 00000F2C 5B                               pop rbx
   293 00000F2D 58                               pop rax
   294 00000F2E 48CF                             iretq
   295                                  
   296                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   297                                  ;新任务创建后，将广播新任务创建消息给所有处理器，所有处理器执行此中断服务例程。
   298                                  new_task_notify_handler:                          ;任务认领中断的处理过程
   299 00000F30 56                               push rsi
   300 00000F31 4153                             push r11
   301                                  
   302 00000F33 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   302 00000F3C FF                 
   303 00000F3D C786B0000000000000-              mov dword [rsi + 0xb0], 0                ;发送EOI
   303 00000F46 00                 
   304                                  
   305 00000F47 0F01F8                           swapgs
   306 00000F4A 6548833C2508000000-              cmp qword [gs:8], 0                      ;当前处理器没有任务执行吗？
   306 00000F53 00                 
   307 00000F54 0F01F8                           swapgs
   308 00000F57 7522                             jne .return                              ;是的（忙）。不打扰了 :)
   309                                  
   310 00000F59 E8F7FDFFFF                       call search_for_a_ready_task
   311 00000F5E 4D09DB                           or r11, r11
   312 00000F61 7418                             jz .return                               ;未找到就绪的任务
   313                                  
   314 00000F63 0F01F8                           swapgs
   315 00000F66 4883C410                         add rsp, 16                              ;去掉进入例程时压入的两个参数
   316 00000F6A 654889242518000000               mov qword [gs:24], rsp                   ;保存固有栈当前指针以便将来返回
   317 00000F73 0F01F8                           swapgs
   318                                  
   319 00000F76 E924FEFFFF                       jmp resume_execute_a_task                ;恢复并执行新任务
   320                                  
   321                                    .return:
   322 00000F7B 415B                             pop r11
   323 00000F7D 5E                               pop rsi
   324                                  
   325 00000F7E 48CF                             iretq
   326                                  
   327                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   328 00000F80 0000000000000000          _append_lock  dq 0
   329                                  
   330                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   331                                                                                    ;输入：R11=PCB线性基地址
   332 00000F88 50                               push rax
   333 00000F89 53                               push rbx
   334                                  
   335 00000F8A 9C                               pushfq                                   ;-->A
   336 00000F8B FA                               cli
   337                                           SET_SPIN_LOCK rax, qword [rel _append_lock]
    58                              <1>  %%spin_lock:
    59 00000F8C 48833DECFFFFFF00    <1>  cmp %2, 0
    60 00000F94 7404                <1>  je %%get_lock
    61 00000F96 F390                <1>  pause
    62 00000F98 EBF2                <1>  jmp %%spin_lock
    63                              <1>  %%get_lock:
    64 00000F9A B801000000          <1>  mov %1, 1
    65 00000F9F 488705DAFFFFFF      <1>  xchg %1, %2
    66 00000FA6 4883F800            <1>  cmp %1, 0
    67 00000FAA 75E0                <1>  jne %%spin_lock
   338                                  
   339 00000FAC 488B1D(A1020000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   340 00000FB3 4809DB                           or rbx, rbx
   341 00000FB6 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   342 00000FB8 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   343 00000FBB 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   344 00000FC2 4C891D(A1020000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   345 00000FC9 EB17                             jmp .return
   346                                  
   347                                    .not_empty:
   348 00000FCB 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   349                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   350 00000FCE 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   351 00000FD5 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   352 00000FDC 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   353 00000FDF 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   354                                  
   355                                    .return:
   356 00000FE2 48C70593FFFFFF0000-              mov qword [rel _append_lock], 0          ;释放锁
   356 00000FEB 0000               
   357 00000FED 9D                               popfq                                    ;A
   358                                  
   359 00000FEE 5B                               pop rbx
   360 00000FEF 58                               pop rax
   361                                  
   362 00000FF0 C3                               ret
   363                                  
   364                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   365                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   366 00000FF1 9C                               pushfq
   367 00000FF2 FA                               cli
   368 00000FF3 0F01F8                           swapgs
   369 00000FF6 65488B042508000000               mov rax, [gs:8]
   370 00000FFF 488B4008                         mov rax, [rax + 8]
   371 00001003 0F01F8                           swapgs
   372 00001006 9D                               popfq
   373                                  
   374 00001007 C3                               ret
   375                                  
   376                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   377                                  terminate_process:                                ;终止当前任务
   378 00001008 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   378 00001011 FF                 
   379 00001012 C78620030000000001-              mov dword [rsi + 0x320], 0x00010000      ;屏蔽定时器中断
   379 0000101B 00                 
   380                                  
   381 0000101C FA                               cli
   382                                  
   383 0000101D 0F01F8                           swapgs
   384 00001020 65488B042508000000               mov rax, [gs:8]                          ;定位到当前任务的PCB节点
   385 00001029 48C7401002000000                 mov qword [rax + 16], 2                  ;状态=终止
   386 00001031 6548C7042500000000-              mov qword [gs:0], 0
   386 0000103A 00000000           
   387 0000103E 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   388 00001047 0F01F8                           swapgs
   389                                  
   390 0000104A E806FDFFFF                       call search_for_a_ready_task
   391 0000104F 4D09DB                           or r11, r11
   392 00001052 7405                             jz .sleep                                ;未找到就绪的任务
   393                                  
   394 00001054 E946FDFFFF                       jmp resume_execute_a_task                ;恢复并执行新任务
   395                                  
   396                                    .sleep:
   397 00001059 48CF                             iretq                                    ;回到不执行任务的日子:)
   398                                  
   399                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   400                                  create_process:                                   ;创建新的任务
   401                                                                                    ;输入：R8=程序的起始逻辑扇区号
   402 0000105B 50                               push rax
   403 0000105C 53                               push rbx
   404 0000105D 51                               push rcx
   405 0000105E 52                               push rdx
   406 0000105F 56                               push rsi
   407 00001060 57                               push rdi
   408 00001061 55                               push rbp
   409 00001062 4150                             push r8
   410 00001064 4151                             push r9
   411 00001066 4152                             push r10
   412 00001068 4153                             push r11
   413 0000106A 4154                             push r12
   414 0000106C 4155                             push r13
   415 0000106E 4156                             push r14
   416 00001070 4157                             push r15
   417                                  
   418                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   419 00001072 B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   420 00001077 E8FFF8FFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   421                                  
   422 0000107C 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   423                                  
   424 0000107F 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   425                                  
   426                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   427 00001087 E8C4F9FFFF                       call copy_current_pml4
   428 0000108C 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   429                                  
   430                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
   431                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
   432                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈是位于地址空间高端的栈。
   433                                  
   434 00001090 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   435 00001094 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   436                                  
   437                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   438 00001097 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   439 0000109E B900010000                       mov rcx, 256
   440                                    .clsp:
   441 000010A3 48C70000000000                   mov qword [rax], 0
   442 000010AA 4883C008                         add rax, 8
   443 000010AE E2F3                             loop .clsp
   444                                  
   445 000010B0 0F20D8                           mov rax, cr3                             ;刷新TLB
   446 000010B3 0F22D8                           mov cr3, rax
   447                                  
   448 000010B6 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   449 000010BB E8BBF8FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   450 000010C0 4D897320                         mov [r11 + 32], r14                      ;填写PCB中的RSP0域的值
   451                                  
   452 000010C4 B900000100                       mov rcx, 4096 * 16                       ;为用户程序开辟栈空间
   453 000010C9 E82EF9FFFF                       call user_memory_allocate
   454 000010CE 4D897378                         mov [r11 + 120], r14                     ;用户程序执行时的RSP。
   455                                  
   456 000010D2 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=就绪
   457                                  
   458                                           ;以下开始加载用户程序
   459 000010DA B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   460 000010DF E818F9FFFF                       call user_memory_allocate
   461 000010E4 4C89EB                           mov rbx, r13
   462 000010E7 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   463 000010EA E869F1FFFF                       call read_hard_disk_0
   464                                  
   465 000010EF 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   466 000010F3 4D89EE                           mov r14, r13
   467 000010F6 4D037508                         add r14, [r13 + 8]
   468 000010FA 4D89B3C0000000                   mov [r11 + 192], r14                     ;在PCB中登记程序的入口点线性地址
   469                                  
   470                                           ;以下判断整个程序有多大
   471 00001101 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   472 00001105 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   473 0000110C 740F                             jz .y512
   474 0000110E 48C1E909                         shr rcx, 9                               ;不能？凑整。
   475 00001112 48C1E109                         shl rcx, 9
   476 00001116 4881C100020000                   add rcx, 512
   477                                    .y512:
   478 0000111D 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   479 00001124 7416                             jz .rdok
   480 00001126 E8D1F8FFFF                       call user_memory_allocate
   481                                           ;mov rbx, r13
   482 0000112B 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   483 0000112F 48FFC0                           inc rax                                  ;起始扇区号
   484                                    .b1:
   485 00001132 E821F1FFFF                       call read_hard_disk_0
   486 00001137 48FFC0                           inc rax
   487 0000113A E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   488                                  
   489                                    .rdok:
   490 0000113C 49C783C80000003B00-              mov qword [r11 + 200], USER_CODE64_SEL   ;新任务的代码段选择子
   490 00001145 0000               
   491 00001147 49C783D00000003300-              mov qword [r11 + 208], USER_STACK64_SEL  ;新任务的栈段选择子
   491 00001150 0000               
   492                                  
   493 00001152 9C                               pushfq
   494 00001153 418F83E8000000                   pop qword [r11 + 232]
   495                                  
   496 0000115A 49C783F0000000E803-              mov qword [r11 + 240], SUGG_PREEM_SLICE  ;推荐的任务执行时间片，来自global_defs.wid
   496 00001163 0000               
   497                                  
   498 00001165 E805FAFFFF                       call generate_process_id
   499 0000116A 49894308                         mov [r11 + 8], rax                       ;记录当前任务的标识
   500                                  
   501 0000116E E815FEFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   502                                  
   503 00001173 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   504                                  
   505 00001177 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   505 00001180 FF                 
   506 00001181 C78610030000000000-              mov dword [rsi + 0x310], 0
   506 0000118A 00                 
   507 0000118B C78600030000FE4008-              mov dword [rsi + 0x300], 0x000840fe      ;向所有处理器发送任务认领中断
   507 00001194 00                 
   508                                  
   509 00001195 415F                             pop r15
   510 00001197 415E                             pop r14
   511 00001199 415D                             pop r13
   512 0000119B 415C                             pop r12
   513 0000119D 415B                             pop r11
   514 0000119F 415A                             pop r10
   515 000011A1 4159                             pop r9
   516 000011A3 4158                             pop r8
   517 000011A5 5D                               pop rbp
   518 000011A6 5F                               pop rdi
   519 000011A7 5E                               pop rsi
   520 000011A8 5A                               pop rdx
   521 000011A9 59                               pop rcx
   522 000011AA 5B                               pop rbx
   523 000011AB 58                               pop rax
   524                                  
   525 000011AC C3                               ret
   526                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   527                                  syscall_procedure:                                ;系统调用的处理过程
   528                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；进入时中断是禁止状态
   529 000011AD 0F01F8                           swapgs                                   ;切换GS到当前处理器的数据区
   530 000011B0 654889242500000000               mov [gs:0], rsp                          ;临时保存当前的3特权级栈指针
   531 000011B9 65488B242584000000               mov rsp, [gs:128+4]                      ;使用TSS的RSP0作为安全栈指针
   532 000011C2 65FF342500000000                 push qword [gs:0]
   533 000011CA 0F01F8                           swapgs
   534 000011CD FB                               sti                                      ;准备工作全部完成，中断和任务切换无虞
   535                                  
   536 000011CE 4157                             push r15
   537 000011D0 4C8B3D(08000000)                 mov r15, [rel position]
   538 000011D7 4D03BCC7[69020000]               add r15, [r15 + rax * 8 + sys_entry]     ;得到指定的那个系统调用功能的线性地址
   539 000011DF 41FFD7                           call r15
   540 000011E2 415F                             pop r15
   541                                  
   542 000011E4 FA                               cli
   543 000011E5 5C                               pop rsp                                  ;恢复原先的3特权级栈指针
   544 000011E6 480F07                           o64 sysret
   545                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   546                                  init:    ;初始化内核的工作环境
   547                                  
   548                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   549                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   550 000011E9 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   550 000011F2 FF                 
   551 000011F3 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   552                                  
   553 000011FB 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   554                                  
   555                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   556                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   557 00001203 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   557 0000120C FF                 
   558 0000120D 4801C4                           add rsp, rax                             ;栈指针必须转换为高端地址且必须是扩高地址
   559                                  
   560                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   561 00001210 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   561 00001219 FF                 
   562 0000121A 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   563                                  
   564                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   565 00001221 488B05(08000000)                 mov rax, [rel position]
   566 00001228 4805[30120000]                   add rax, .to_upper
   567 0000122E FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   568                                  
   569                                    .to_upper:
   570                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   571                                  
   572                                           ;为32个异常创建通用处理过程的中断门
   573 00001230 4C8B0D(08000000)                 mov r9, [rel position]
   574 00001237 498D81[200D0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   575 0000123E E869EFFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   576                                  
   577 00001243 4D31C0                           xor r8, r8
   578                                    .idt0:
   579 00001246 E8C2EFFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   580 0000124B 49FFC0                           inc r8
   581 0000124E 4983F81F                         cmp r8, 31
   582 00001252 7EF2                             jle .idt0
   583                                  
   584                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   585 00001254 498D81[1E0D0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   586 0000125B E84CEFFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   587                                  
   588 00001260 41B820000000                     mov r8, 32
   589                                    .idt1:
   590 00001266 E8A2EFFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   591 0000126B 49FFC0                           inc r8
   592 0000126E 4981F8FF000000                   cmp r8, 255
   593 00001275 7EEF                             jle .idt1
   594                                  
   595 00001277 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   595 00001280 FF                 
   596 00001281 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   596 0000128A FF                 
   597 0000128B 4889430E                         mov qword [rbx + 0x0e], rax
   598 0000128F 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   599                                  
   600 00001295 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   601                                  
   602 00001299 B0FF                             mov al, 0xff                             ;屏蔽所有发往8259A主芯片的中断信号
   603 0000129B E621                             out 0x21, al                             ;多处理器环境下不再使用8259芯片
   604                                  
   605                                           ;在64位模式下显示的第一条信息!
   606 0000129D 4C8B3D(08000000)                 mov r15, [rel position]
   607 000012A4 498D9F[36010000]                 lea rbx, [r15 + welcome]
   608 000012AB E858EDFFFF                       call put_string64                        ;位于core_utils64_mp.wid
   609                                  
   610                                           ;安装系统服务（SYSCALL/SYSRET）所需要的代码段和栈段描述符
   611 000012B0 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区SDA的线性地址
   611 000012B9 FF                 
   612 000012BA 4831DB                           xor rbx, rbx
   613 000012BD 66418B5F02                       mov bx, [r15 + 2]                        ;BX=GDT的界限值
   614 000012C2 66FFC3                           inc bx                                   ;BX=GDT的长度
   615 000012C5 49035F04                         add rbx, [r15 + 4]                       ;RBX=新描述符的追加位置
   616                                  
   617 000012C9 C703FFFF0000                     mov dword [rbx], 0x0000ffff              ;64位模式下不支持64位立即数传送
   618 000012CF C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   619 000012D6 C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   620 000012DD C7430C00000000                   mov dword [rbx + 12], 0
   621 000012E4 C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   622 000012EB C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   623 000012F2 C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   624 000012F9 C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   625                                  
   626                                           ;我们为每个逻辑处理器都准备一个专属数据区，它是由每个处理器的GS所指向的。
   627                                           ;为当前处理器（BSP）准备专属数据区，设置GS并安装任务状态段TSS的描述符
   628 00001300 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
   629 00001305 E871F6FFFF                       call core_memory_allocate
   630 0000130A 49C7450800000000                 mov qword [r13 + 8], 0                   ;提前将“当前任务的PCB指针域”清零
   631 00001312 49C7451000000000                 mov qword [r13 + 16], 0                  ;将当前处理器的编号设置为#0
   632 0000131A 49896518                         mov [r13 + 24], rsp                      ;设置当前处理器的专属栈
   633 0000131E 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
   634 00001325 E8BAEEFFFF                       call make_tss_descriptor
   635 0000132A 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   636 0000132E 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   637                                  
   638 00001332 664183470230                     add word [r15 + 2], 48                   ;4个段描述符和1个TSS描述符的总字节数
   639 00001338 410F015702                       lgdt [r15 + 2]
   640                                  
   641 0000133D 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   642 00001341 0F00D9                           ltr cx
   643                                  
   644                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
   645 00001344 B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
   646 00001349 4C89E8                           mov rax, r13                             ;只用EAX
   647 0000134C 4C89EA                           mov rdx, r13
   648 0000134F 48C1EA20                         shr rdx, 32                              ;只用EDX
   649 00001353 0F30                             wrmsr
   650                                  
   651                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   652 00001355 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   653 0000135A 0F32                             rdmsr
   654 0000135C 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   655 00001360 0F30                             wrmsr
   656                                  
   657 00001362 B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   658 00001367 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   659 0000136C 31C0                             xor eax, eax
   660 0000136E 0F30                             wrmsr
   661                                  
   662 00001370 B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   663 00001375 488B05(08000000)                 mov rax, [rel position]
   664 0000137C 488D80[AD110000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   665 00001383 4889C2                           mov rdx, rax
   666 00001386 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   667 0000138A 0F30                             wrmsr
   668                                  
   669 0000138C B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   670 00001391 31D2                             xor edx, edx
   671 00001393 B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   672 00001398 0F30                             wrmsr
   673                                  
   674                                           ;以下初始化高级可编程中断控制器APIC。在计算机启动后，BIOS已经对LAPIC和IOAPIC做了
   675                                           ;初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理器和
   676                                           ;APIC信息。英特尔架构的个人计算机（IA-PC）从1MB物理内存中搜索获取；启用可扩展固件
   677                                           ;接口（EFI或者叫UEFI）的计算机需使用EFI传递的EFI系统表指针定位相关表格并从中获取
   678                                           ;多处理器和APIC信息。为简单起见，我们采用前一种传统的方式。请注意虚拟机的配置！
   679                                  
   680                                           ;ACPI申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
   681                                           ;位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
   682 0000139A 66833C25167E000000               cmp word [SDA_PHY_ADDR + 0x16], 0
   683 000013A3 7411                             jz .acpi_err                             ;不正确的ACPI数据，可能不支持ACPI
   684 000013A5 BE187E0000                       mov rsi, SDA_PHY_ADDR + 0x18             ;系统数据区：地址范围描述结构的起始地址
   685                                    .looking:
   686 000013AA 837E1003                         cmp dword [rsi + 16], 3                  ;3:ACPI申领的内存（AddressRangeACPI）
   687 000013AE 741B                             jz .looked
   688 000013B0 4883C620                         add rsi, 32                              ;32:每个地址范围描述结构的长度
   689 000013B4 E2F4                             loop .looking
   690                                  
   691                                    .acpi_err:
   692 000013B6 4C8B3D(08000000)                 mov r15, [rel position]
   693 000013BD 498D9F[00000000]                 lea rbx, [r15 + acpi_error]
   694 000013C4 E83FECFFFF                       call put_string64                        ;位于core_utils64_mp.wid
   695 000013C9 FA                               cli
   696 000013CA F4                               hlt
   697                                  
   698                                    .looked:
   699 000013CB 488B1E                           mov rbx, [rsi]                           ;ACPI申领的起始物理地址
   700 000013CE 488B4E08                         mov rcx, [rsi + 8]                       ;ACPI申领的内存数量，以字节计
   701 000013D2 4801D9                           add rcx, rbx                             ;ACPI申领的内存上边界
   702 000013D5 48C7C200F0FFFF                   mov rdx, 0xffff_ffff_ffff_f000           ;用于生成页地址的掩码
   703                                    .maping:
   704 000013DC 4989DD                           mov r13, rbx                             ;R13:本次映射的线性地址
   705 000013DF 4889D8                           mov rax, rbx
   706 000013E2 4821D0                           and rax, rdx
   707 000013E5 4883C807                         or rax, 0x07                             ;RAX:本次映射的物理地址及属性
   708 000013E9 E892F4FFFF                       call mapping_laddr_to_page
   709 000013EE 4881C300100000                   add rbx, 0x1000
   710 000013F5 4839CB                           cmp rbx, rcx
   711 000013F8 7EE2                             jle .maping
   712                                  
   713                                           ;从物理地址0x60000开始，搜索根系统描述指针结构（RSDP）
   714 000013FA BB00000600                       mov rbx, 0x60000
   715 000013FF 48B952534420505452-              mov rcx, 'RSD PTR '                      ;结构的起始标记（注意尾部的空格）
   715 00001408 20                 
   716                                    .searc:
   717 00001409 48390B                           cmp qword [rbx], rcx
   718 0000140C 740F                             je .finda
   719 0000140E 4883C310                         add rbx, 16                              ;结构的标记总是位于16字节边界处
   720 00001412 4881FBF0FF0F00                   cmp rbx, 0xffff0                         ;低端1MB物理内存的上边界
   721 00001419 7CEE                             jl .searc
   722 0000141B EB99                             jmp .acpi_err                            ;未找到RSDP，报错停机处理。
   723                                  
   724                                    .finda:
   725                                           ;RSDT和XSDT都指向MADT，但RSDT给出的是32位物理地址，而XDST给出64位物理地址。
   726                                           ;只有VCPI 2.0及更高版本才有XSDT。典型地，VBox支持ACPI 2.0而Bochs仅支持1.0
   727 0000141D 807B0F02                         cmp byte [rbx + 15], 2                   ;检测ACPI的版本是否为2
   728 00001421 752B                             jne .vcpi_1
   729 00001423 488B5B18                         mov rbx, [rbx + 24]                      ;得到扩展的系统描述表（XSDT）的物理地址
   730                                  
   731                                           ;以下，开始在XSDT中遍历搜索多APIC描述表（MADT）
   732 00001427 4831FF                           xor rdi, rdi
   733 0000142A 8B7B04                           mov edi, [rbx + 4]                       ;获得XSDT的长度（以字节计）
   734 0000142D 4801DF                           add rdi, rbx                             ;计算XSDT上边界的物理位置
   735 00001430 4883C324                         add rbx, 36                              ;XSDT尾部数组的物理位置
   736                                    .madt0:
   737 00001434 4C8B1B                           mov r11, [rbx]
   738 00001437 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   739 0000143E 7436                             je .findm
   740 00001440 4883C308                         add rbx, 8                               ;下一个元素
   741 00001444 4839FB                           cmp rbx, rdi
   742 00001447 7CEB                             jl .madt0
   743 00001449 E968FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   744                                  
   745                                           ;以下按VCPI 1.0处理，开始在RSDT中遍历搜索多APIC描述表（MADT）
   746                                    .vcpi_1:
   747 0000144E 8B5B10                           mov ebx, [rbx + 16]                      ;得到根系统描述表（RSDT）的物理地址
   748                                           ;以下，开始在RSDT中遍历搜索多APIC描述表（MADT）
   749 00001451 678B7B04                         mov edi, [ebx + 4]                       ;获得RSDT的长度（以字节计）
   750 00001455 01DF                             add edi, ebx                             ;计算RSDT上边界的物理位置
   751 00001457 83C324                           add ebx, 36                              ;RSDT尾部数组的物理位置
   752 0000145A 4D31DB                           xor r11, r11
   753                                    .madt1:
   754 0000145D 67448B1B                         mov r11d, [ebx]
   755 00001461 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   756 00001468 740C                             je .findm
   757 0000146A 83C304                           add ebx, 4                               ;下一个元素
   758 0000146D 39FB                             cmp ebx, edi
   759 0000146F 7CEC                             jl .madt1
   760 00001471 E940FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   761                                  
   762                                    .findm:
   763                                           ;此时，R11是MADT的物理地址
   764 00001476 418B5324                         mov edx, [r11 + 36]                      ;预置的LAPIC物理地址
   765 0000147A 8915(28010000)                   mov [rel lapic_addr], edx
   766                                  
   767                                           ;以下开始遍历系统中的逻辑处理器（其LAPID ID）和I/O APIC。
   768 00001480 4C8B3D(08000000)                 mov r15, [rel position]                  ;为访问cpu_list准备线性地址
   769 00001487 4D8DBF[28000000]                 lea r15, [r15 + cpu_list]
   770                                  
   771 0000148E 4831FF                           xor rdi, rdi
   772 00001491 418B7B04                         mov edi, [r11 + 4]                       ;EDI:MADT的长度，以字节计
   773 00001495 4C01DF                           add rdi, r11                             ;RDI:MADT上部边界的物理地址
   774 00001498 4983C32C                         add r11, 44                              ;R11:指向MADT尾部的中断控制器结构列表
   775                                    .enumd:
   776 0000149C 41803B00                         cmp byte [r11], 0                        ;列表项类型：Processor Local APIC
   777 000014A0 7408                             je .l_apic
   778 000014A2 41803B01                         cmp byte [r11], 1                        ;列表项类型：I/O APIC
   779 000014A6 741B                             je .ioapic
   780 000014A8 EB2D                             jmp .m_end
   781                                    .l_apic:
   782 000014AA 41837B0400                       cmp dword [r11 + 4], 0                   ;Local APIC Flags
   783 000014AF 7426                             jz .m_end
   784 000014B1 418A4303                         mov al, [r11 + 3]                        ;local APIC ID
   785 000014B5 418807                           mov [r15], al                            ;保存local APIC ID到cpu_list
   786 000014B8 49FFC7                           inc r15
   787 000014BB FE05(27000000)                   inc byte [rel num_cpus]                  ;可用的CPU数量递增
   788 000014C1 EB14                             jmp .m_end
   789                                    .ioapic:
   790 000014C3 418A4302                         mov al, [r11 + 2]                        ;取出I/O APIC ID
   791 000014C7 8805(30010000)                   mov [rel ioapic_id], al                  ;保存I/O APIC ID
   792 000014CD 418B4304                         mov eax, [r11 + 4]                       ;取出I/O APIC物理地址
   793 000014D1 8905(2C010000)                   mov [rel ioapic_addr], eax               ;保存I/O APIC物理地址
   794                                     .m_end:
   795 000014D7 4831C0                           xor rax, rax
   796 000014DA 418A4301                         mov al, [r11 + 1]
   797 000014DE 4901C3                           add r11, rax                             ;计算下一个中断控制器结构列表项的地址
   798 000014E1 4939FB                           cmp r11, rdi
   799 000014E4 7CB6                             jl .enumd
   800                                  
   801                                           ;将Local APIC的物理地址映射到预定义的线性地址LAPIC_START_ADDR
   802 000014E6 49BD00E0FFFF7FFFFF-              mov r13, LAPIC_START_ADDR                ;在global_defs.wid中定义
   802 000014EF FF                 
   803 000014F0 4831C0                           xor rax, rax
   804 000014F3 8B05(28010000)                   mov eax, [rel lapic_addr]                ;取出LAPIC的物理地址
   805 000014F9 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   806 000014FC E87FF3FFFF                       call mapping_laddr_to_page
   807                                  
   808                                           ;将I/O APIC的物理地址映射到预定义的线性地址IOAPIC_START_ADDR
   809 00001501 49BD00D0FFFF7FFFFF-              mov r13, IOAPIC_START_ADDR               ;在global_defs.wid中定义
   809 0000150A FF                 
   810 0000150B 4831C0                           xor rax, rax
   811 0000150E 8B05(2C010000)                   mov eax, [rel ioapic_addr]               ;取出I/O APIC的物理地址
   812 00001514 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   813 00001517 E864F3FFFF                       call mapping_laddr_to_page
   814                                  
   815                                           ;以下测量当前处理器在1毫秒的时间里经历多少时钟周期，作为后续的定时基准。
   816 0000151C 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   816 00001525 FF                 
   817                                  
   818 00001526 C78620030000000001-              mov dword [rsi + 0x320], 0x10000         ;定时器的本地向量表入口寄存器。单次击发（one shot）模式
   818 0000152F 00                 
   819 00001530 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;定时器的分频配置寄存器：1分频（不分频）
   819 00001539 00                 
   820                                  
   821 0000153A B00B                             mov al, 0x0b                             ;RTC寄存器B
   822 0000153C 0C80                             or al, 0x80                              ;阻断NMI
   823 0000153E E670                             out 0x70, al
   824 00001540 B052                             mov al, 0x52                             ;设置寄存器B，开放周期性中断，开放更
   825 00001542 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   826                                  
   827 00001544 B08A                             mov al, 0x8a                             ;CMOS寄存器A
   828 00001546 E670                             out 0x70, al
   829                                           ;in al, 0x71
   830 00001548 B02D                             mov al, 0x2d                             ;32kHz，125ms的周期性中断
   831 0000154A E671                             out 0x71, al                             ;写回CMOS寄存器A
   832                                  
   833 0000154C B08C                             mov al, 0x8c
   834 0000154E E670                             out 0x70, al
   835 00001550 E471                             in al, 0x71                              ;读寄存器C
   836                                    .w0:
   837 00001552 E471                             in al, 0x71                              ;读寄存器C
   838 00001554 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   839 00001559 73F7                             jnc .w0
   840 0000155B C78680030000FFFFFF-              mov dword [rsi + 0x380], 0xffff_ffff     ;定时器初始计数寄存器：置初值并开始计数
   840 00001564 FF                 
   841                                    .w1:
   842 00001565 E471                             in al, 0x71                              ;读寄存器C
   843 00001567 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   844 0000156C 73F7                             jnc .w1
   845 0000156E 8B9690030000                     mov edx, [rsi + 0x390]                   ;定时器当前计数寄存器：读当前计数值
   846                                  
   847 00001574 B8FFFFFFFF                       mov eax, 0xffff_ffff
   848 00001579 29D0                             sub eax, edx
   849 0000157B 31D2                             xor edx, edx
   850 0000157D BB7D000000                       mov ebx, 125                             ;125毫秒
   851 00001582 F7F3                             div ebx                                  ;EAX=当前处理器在1ms内的时钟数
   852                                  
   853 00001584 8905(32010000)                   mov [rel clocks_1ms], eax                ;登记起来用于其它定时的场合
   854                                  
   855 0000158A B00B                             mov al, 0x0b                             ;RTC寄存器B
   856 0000158C 0C80                             or al, 0x80                              ;阻断NMI
   857 0000158E E670                             out 0x70, al
   858 00001590 B012                             mov al, 0x12                             ;设置寄存器B，只允许更新周期结束中断
   859 00001592 E671                             out 0x71, al
   860                                  
   861                                           ;以下安装新任务认领中断的处理过程
   862 00001594 4C8B0D(08000000)                 mov r9, [rel position]
   863 0000159B 498D81[300F0000]                 lea rax, [r9 + new_task_notify_handler]  ;得到中断处理过程的线性地址
   864 000015A2 E805ECFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   865                                  
   866 000015A7 FA                               cli
   867 000015A8 41B8FE000000                     mov r8, 0xfe
   868 000015AE E85AECFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   869 000015B3 FB                               sti
   870                                  
   871                                           ;以下安装时间片到期中断的处理过程
   872 000015B4 4C8B0D(08000000)                 mov r9, [rel position]
   873 000015BB 498D81[6F0E0000]                 lea rax, [r9 + time_slice_out_handler]   ;得到中断处理过程的线性地址
   874 000015C2 E8E5EBFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   875                                  
   876 000015C7 FA                               cli
   877 000015C8 41B8FD000000                     mov r8, 0xfd
   878 000015CE E83AECFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   879 000015D3 FB                               sti
   880                                  
   881                                           ;以下开始初始化应用处理器AP。先将初始化代码复制到物理内存最低端的选定位置
   882 000015D4 488B35(08000000)                 mov rsi, [rel position]
   883 000015DB 488DB6[00000000]                 lea rsi, [rsi + section.ap_init_block.start]
   884 000015E2 BF00F00000                       mov rdi, AP_START_UP_ADDR
   885 000015E7 B983000000                       mov rcx, ap_init_tail - ap_init
   886 000015EC FC                               cld
   887 000015ED F3A4                             repe movsb
   888                                  
   889                                           ;所有处理器都应当在初始化期间递增应答计数值
   890 000015EF FE05(31010000)                   inc byte [rel ack_cpus]                  ;BSP自己的应答计数值
   891                                  
   892                                           ;给其它处理器发送INIT IPI和SIPI，命令它们初始化自己
   893 000015F5 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   893 000015FE FF                 
   894 000015FF C78610030000000000-              mov dword [rsi + 0x310], 0
   894 00001608 00                 
   895 00001609 C7860003000000450C-              mov dword [rsi + 0x300], 0x000c4500      ;先发送INIT IPI
   895 00001612 00                 
   896 00001613 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
   896 0000161C 00                 
   897 0000161D C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
   897 00001626 00                 
   898                                  
   899 00001627 8A05(27000000)                   mov al, [rel num_cpus]
   900                                    .wcpus:
   901 0000162D 3A05(31010000)                   cmp al, [rel ack_cpus]
   902 00001633 75F8                             jne .wcpus                               ;等待所有应用处理器的应答
   903                                  
   904                                           ;显示已应答的处理器的数量信息
   905 00001635 4C8B3D(08000000)                 mov r15, [rel position]
   906                                  
   907 0000163C 4D31C0                           xor r8, r8
   908 0000163F 448A05(31010000)                 mov r8b, [rel ack_cpus]
   909 00001646 498D9F[69010000]                 lea rbx, [r15 + buffer]
   910 0000164D E84BF5FFFF                       call bin64_to_dec
   911 00001652 E8B1E9FFFF                       call put_string64
   912                                  
   913 00001657 498D9F[58010000]                 lea rbx, [r15 + cpu_init_ok]
   914 0000165E E8A5E9FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   915                                  
   916                                           ;以下开始创建系统外壳任务（进程）
   917 00001663 41B832000000                     mov r8, 50
   918 00001669 E8EDF9FFFF                       call create_process
   919                                  
   920 0000166E E9A8F6FFFF                       jmp ap_to_core_entry.do_idle             ;去处理器集结休息区 :)
   921                                  
   922                                  ;===============================================================================
   923                                  section ap_init_block vstart=0
   924                                  
   925                                           bits 16                                  ;应用处理器AP从实模式开始执行
   926                                  
   927                                  ap_init:                                          ;应用处理器AP的初始化代码
   928 00000000 B8000F                           mov ax, AP_START_UP_ADDR >> 4
   929 00000003 8ED8                             mov ds, ax
   930                                  
   931                                           SET_SPIN_LOCK al, byte [lock_var]        ;自旋直至获得锁
    58                              <1>  %%spin_lock:
    59 00000005 803E[8200]00        <1>  cmp %2, 0
    60 0000000A 7404                <1>  je %%get_lock
    61 0000000C F390                <1>  pause
    62 0000000E EBF5                <1>  jmp %%spin_lock
    63                              <1>  %%get_lock:
    64 00000010 B001                <1>  mov %1, 1
    65 00000012 8606[8200]          <1>  xchg %1, %2
    66 00000016 3C00                <1>  cmp %1, 0
    67 00000018 75EB                <1>  jne %%spin_lock
   932                                  
   933 0000001A B8E007                           mov ax, SDA_PHY_ADDR >> 4                ;切换到系统数据区
   934 0000001D 8ED8                             mov ds, ax
   935                                  
   936                                           ;加载描述符表寄存器GDTR
   937 0000001F 0F01160200                       lgdt [2]                                 ;实模式下只加载6个字节的内容
   938                                  
   939 00000024 E492                             in al, 0x92                              ;南桥芯片内的端口
   940 00000026 0C02                             or al, 0000_0010B
   941 00000028 E692                             out 0x92, al                             ;打开A20
   942                                  
   943 0000002A FA                               cli                                      ;中断机制尚未工作
   944                                  
   945 0000002B 0F20C0                           mov eax, cr0
   946 0000002E 6683C801                         or eax, 1
   947 00000032 0F22C0                           mov cr0, eax                             ;设置PE位
   948                                  
   949                                           ;以下进入保护模式... ...
   950 00000035 EA[3AF0]0800                     jmp 0x0008: AP_START_UP_ADDR + .flush    ;清流水线并串行化处理器
   951                                  
   952                                           [bits 32]
   953                                    .flush:
   954 0000003A B810000000                       mov eax, 0x0010                          ;加载数据段(4GB)选择子
   955 0000003F 8ED0                             mov ss, eax                              ;加载堆栈段(4GB)选择子
   956 00000041 BC007E0000                       mov esp, 0x7e00                          ;堆栈指针
   957                                  
   958                                           ;令CR3寄存器指向4级头表（保护模式下的32位CR3）
   959 00000046 B800A00000                       mov eax, PML4_PHY_ADDR                   ;PCD=PWT=0
   960 0000004B 0F22D8                           mov cr3, eax
   961                                  
   962                                           ;开启物理地址扩展PAE
   963 0000004E 0F20E0                           mov eax, cr4
   964 00000051 0FBAE805                         bts eax, 5
   965 00000055 0F22E0                           mov cr4, eax
   966                                  
   967                                           ;设置型号专属寄存器IA32_EFER.LME，允许IA_32e模式
   968 00000058 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   969 0000005D 0F32                             rdmsr
   970 0000005F 0FBAE808                         bts eax, 8                               ;设置LME位
   971 00000063 0F30                             wrmsr
   972                                  
   973                                           ;开启分页功能
   974 00000065 0F20C0                           mov eax, cr0
   975 00000068 0FBAE81F                         bts eax, 31                              ;置位CR0.PG
   976 0000006C 0F22C0                           mov cr0, eax
   977                                  
   978                                           ;进入64位模式
   979 0000006F EA[76F00000]1800                 jmp CORE_CODE64_SEL:AP_START_UP_ADDR + .to64
   980                                    .to64:
   981                                  
   982                                           bits 64
   983                                  
   984                                           ;转入内核中继续初始化（使用高端线性地址）
   985 00000076 48BB-                            mov rbx, UPPER_CORE_LINEAR + ap_to_core_entry
   985 00000078 [F80B02000080FFFF] 
   986 00000080 FFE3                             jmp rbx
   987                                  
   988 00000082 00                        lock_var  db 0
   989                                  
   990                                  ap_init_tail:
   991                                  
   992                                  ;===============================================================================
   993                                  section core_tail
   994                                  core_end:
