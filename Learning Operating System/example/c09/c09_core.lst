     1                                  ;多处理器多线程内核，2022-10-29
     2                                  
     3                                  %include "..\common\global_defs.wid"
     4                              <1> ;系统全局使用的常量定义，2021-09-05
     5                              <1> 
     6                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     7                              <1> 
     8                              <1> %ifndef _GLOBAL_DEFS_
     9                              <1>    %define _GLOBAL_DEFS_
    10                              <1> 
    11                              <1>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    12                              <1>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    13                              <1>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    14                              <1>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    15                              <1>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    16                              <1>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    17                              <1>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    18                              <1>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    19                              <1>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    20                              <1>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    21                              <1>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    22                              <1> 
    23                              <1>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    24                              <1>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    25                              <1> 
    26                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    27                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    28                              <1> 
    29                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    30                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    31                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    32                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    33                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    34                              <1> 
    35                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    36                              <1>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    37                              <1>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    38                              <1>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    39                              <1>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    40                              <1>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    41                              <1> 
    42                              <1>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    43                              <1>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    44                              <1>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    45                              <1> 
    46                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    47                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    48                              <1> 
    49                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    50                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    51                              <1> 
    52                              <1>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    53                              <1> 
    54                              <1>    SUGG_PREEM_SLICE    equ     55                      ;推荐的任务/线程抢占时间片长度（毫秒）
    55                              <1> 
    56                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    57                              <1>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
    58                              <1>             %%spin_lock:
    59                              <1>                        cmp %2, 0                       ;锁是释放状态吗？
    60                              <1>                        je %%get_lock                   ;获取锁
    61                              <1>                        pause
    62                              <1>                        jmp %%spin_lock                 ;继续尝试获取锁
    63                              <1>             %%get_lock:
    64                              <1>                        mov %1, 1
    65                              <1>                        xchg %1, %2
    66                              <1>                        cmp %1, 0                       ;交换前为零？
    67                              <1>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
    68                              <1>    %endmacro
    69                              <1> 
    70                              <1> %endif
     4                                  
     5                                  ;===============================================================================
     6                                  section core_header                               ;内核程序头部
     7 00000000 [00000000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
     8 00000004 [1D140000]                init_entry   dd init                            ;#4：内核入口点
     9 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    10                                  
    11                                  ;===============================================================================
    12                                  section core_data                                 ;内核数据段
    13 00000000 41435049206973206E-       acpi_error    db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    13 00000009 6F7420737570706F72-
    13 00000012 746564206F72206461-
    13 0000001B 7461206572726F722E-
    13 00000024 0D0A00             
    14                                  
    15 00000027 00                        num_cpus     db 0                               ;逻辑处理器数量
    16 00000028 00<rep 100h>              cpu_list     times 256 db 0                     ;Local APIC ID的列表
    17 00000128 00000000                  lapic_addr   dd 0                               ;Local APIC的物理地址
    18                                  
    19 0000012C 00000000                  ioapic_addr  dd 0                               ;I/O APIC的物理地址
    20 00000130 00                        ioapic_id    db 0                               ;I/O APIC ID
    21                                  
    22 00000131 00                        ack_cpus     db 0                               ;处理器初始化应答计数
    23                                  
    24 00000132 00000000                  clocks_1ms   dd 0                               ;处理器在1ms内经历的时钟数
    25                                  
    26 00000136 457865637574696E67-       welcome      db "Executing in 64-bit mode.Init MP", 249, 0
    26 0000013F 20696E2036342D6269-
    26 00000148 74206D6F64652E496E-
    26 00000151 6974204D50F900     
    27 00000158 204350552873292072-       cpu_init_ok  db " CPU(s) ready.", 0x0d, 0x0a, 0
    27 00000161 656164792E0D0A00   
    28                                  
    29 00000169 00<rep 100h>              buffer       times 256 db 0
    30                                  
    31 00000269 [960B000000000000]        sys_entry    dq get_screen_row                  ;#0
    32 00000271 [D00A000000000000]                     dq get_cmos_time                   ;#1
    33 00000279 [1901000000000000]                     dq put_cstringxy64                 ;#2
    34 00000281 [5A12000000000000]                     dq create_process                  ;#3
    35 00000289 [9710000000000000]                     dq get_current_pid                 ;#4
    36 00000291 [E410000000000000]                     dq terminate_process               ;#5
    37 00000299 [A10B000000000000]                     dq get_cpu_number                  ;#6
    38 000002A1 [4811000000000000]                     dq create_thread                   ;#7
    39 000002A9 [8010000000000000]                     dq get_current_tid                 ;#8
    40 000002B1 [AE10000000000000]                     dq thread_exit                     ;#9
    41 000002B9 [B40B000000000000]                     dq memory_allocate                 ;#10
    42 000002C1 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    43                                  
    44                                  ;===============================================================================
    45                                  section core_code                                 ;内核代码段
    46                                  
    47                                  %include "..\common\core_utils64_mp.wid"          ;引入内核用到的例程
    48                              <1> ;文件core_utils64_mp.wid是供64位内核使用的函数集，多处理器环境专用。
    49                              <1> ;创建时间：2022，李忠
    50                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，
    51                              <1> ;方便内核代码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    52                              <1> 
    53                              <1> %include "..\common\global_defs.wid"
    54                              <2> ;系统全局使用的常量定义，2021-09-05
    55                              <2> 
    56                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    57                              <2> 
    58                              <2> %ifndef _GLOBAL_DEFS_
    59                              <2>    %define _GLOBAL_DEFS_
    60                              <2> 
    61                              <2>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    62                              <2>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    63                              <2>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    64                              <2>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    65                              <2>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    66                              <2>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    67                              <2>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    68                              <2>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    69                              <2>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    70                              <2>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    71                              <2>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    72                              <2> 
    73                              <2>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    74                              <2>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    75                              <2> 
    76                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    77                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    78                              <2> 
    79                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    80                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    81                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    82                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    83                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    84                              <2> 
    85                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    86                              <2>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    87                              <2>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    88                              <2>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    89                              <2>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    90                              <2>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    91                              <2> 
    92                              <2>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    93                              <2>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    94                              <2>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    95                              <2> 
    96                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    97                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    98                              <2> 
    99                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
   100                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
   101                              <2> 
   102                              <2>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
   103                              <2> 
   104                              <2>    SUGG_PREEM_SLICE    equ     55                      ;推荐的任务/线程抢占时间片长度（毫秒）
   105                              <2> 
   106                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
   107                              <2>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
   108                              <2>             %%spin_lock:
   109                              <2>                        cmp %2, 0                       ;锁是释放状态吗？
   110                              <2>                        je %%get_lock                   ;获取锁
   111                              <2>                        pause
   112                              <2>                        jmp %%spin_lock                 ;继续尝试获取锁
   113                              <2>             %%get_lock:
   114                              <2>                        mov %1, 1
   115                              <2>                        xchg %1, %2
   116                              <2>                        cmp %1, 0                       ;交换前为零？
   117                              <2>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
   118                              <2>    %endmacro
   119                              <2> 
   120                              <2> %endif
    54                              <1> 
    55                              <1>          bits 64
    56                              <1> 
    57                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    58 00000000 0000000000000000    <1> _prn_str_locker dq 0                              ;打印锁
    59                              <1> 
    60                              <1> put_string64:                                     ;显示0终止的字符串并移动光标
    61                              <1>                                                   ;输入：RBX=字符串的线性地址
    62 00000008 53                  <1>          push rbx
    63 00000009 51                  <1>          push rcx
    64                              <1> 
    65 0000000A 9C                  <1>          pushfq                                   ;-->A
    66 0000000B FA                  <1>          cli
    67                              <1>          SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    58                              <2>  %%spin_lock:
    59 0000000C 48833DECFFFFFF00    <2>  cmp %2, 0
    60 00000014 7404                <2>  je %%get_lock
    61 00000016 F390                <2>  pause
    62 00000018 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000001A B901000000          <2>  mov %1, 1
    65 0000001F 48870DDAFFFFFF      <2>  xchg %1, %2
    66 00000026 4883F900            <2>  cmp %1, 0
    67 0000002A 75E0                <2>  jne %%spin_lock
    68                              <1> 
    69                              <1>   .getc:
    70 0000002C 8A0B                <1>          mov cl, [rbx]
    71 0000002E 08C9                <1>          or cl, cl                                ;检测串结束标志（0）
    72 00000030 740A                <1>          jz .exit                                 ;显示完毕，返回
    73 00000032 E814000000          <1>          call put_char
    74 00000037 48FFC3              <1>          inc rbx
    75 0000003A EBF0                <1>          jmp .getc
    76                              <1> 
    77                              <1>   .exit:
    78 0000003C 48C705B9FFFFFF0000- <1>          mov qword [rel _prn_str_locker], 0       ;释放锁
    78 00000045 0000                <1>
    79 00000047 9D                  <1>          popfq                                    ;A
    80                              <1> 
    81 00000048 59                  <1>          pop rcx
    82 00000049 5B                  <1>          pop rbx
    83                              <1> 
    84 0000004A C3                  <1>          ret                                      ;段内返回
    85                              <1> 
    86                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    87                              <1> put_char:                                         ;在当前光标处显示一个字符,并推进
    88                              <1>                                                   ;光标。
    89                              <1>                                                   ;输入：CL=字符ASCII码
    90 0000004B 50                  <1>          push rax
    91 0000004C 53                  <1>          push rbx
    92 0000004D 51                  <1>          push rcx
    93 0000004E 52                  <1>          push rdx
    94 0000004F 56                  <1>          push rsi
    95 00000050 57                  <1>          push rdi
    96                              <1> 
    97                              <1>          ;以下取当前光标位置
    98 00000051 66BAD403            <1>          mov dx, 0x3d4
    99 00000055 B00E                <1>          mov al, 0x0e
   100 00000057 EE                  <1>          out dx, al
   101 00000058 66FFC2              <1>          inc dx                                   ;0x3d5
   102 0000005B EC                  <1>          in al, dx                                ;高字
   103 0000005C 88C4                <1>          mov ah, al
   104                              <1> 
   105 0000005E 66FFCA              <1>          dec dx                                   ;0x3d4
   106 00000061 B00F                <1>          mov al, 0x0f
   107 00000063 EE                  <1>          out dx, al
   108 00000064 66FFC2              <1>          inc dx                                   ;0x3d5
   109 00000067 EC                  <1>          in al, dx                                ;低字
   110 00000068 6689C3              <1>          mov bx, ax                               ;BX=代表光标位置的16位数
   111 0000006B 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff              ;准备使用64位寻址方式访问显存
   112                              <1> 
   113 00000072 80F90D              <1>          cmp cl, 0x0d                             ;回车符？
   114 00000075 750E                <1>          jnz .put_0a
   115 00000077 6689D8              <1>          mov ax, bx
   116 0000007A B350                <1>          mov bl, 80
   117 0000007C F6F3                <1>          div bl
   118 0000007E F6E3                <1>          mul bl
   119 00000080 6689C3              <1>          mov bx, ax
   120 00000083 EB6C                <1>          jmp .set_cursor
   121                              <1> 
   122                              <1>   .put_0a:
   123 00000085 80F90A              <1>          cmp cl, 0x0a                             ;换行符？
   124 00000088 7506                <1>          jnz .put_other
   125 0000008A 6683C350            <1>          add bx, 80
   126 0000008E EB16                <1>          jmp .roll_screen
   127                              <1> 
   128                              <1>   .put_other:                                     ;正常显示字符
   129 00000090 66D1E3              <1>          shl bx, 1
   130 00000093 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO                ;在global_defs.wid中定义
   130 0000009C FF                  <1>
   131 0000009D 880C18              <1>          mov [rax + rbx], cl
   132                              <1> 
   133                              <1>          ;以下将光标位置推进一个字符
   134 000000A0 66D1EB              <1>          shr bx, 1
   135 000000A3 66FFC3              <1>          inc bx
   136                              <1> 
   137                              <1>   .roll_screen:
   138 000000A6 6681FBD007          <1>          cmp bx, 2000                             ;光标超出屏幕？滚屏
   139 000000AB 7C44                <1>          jl .set_cursor
   140                              <1> 
   141 000000AD 6653                <1>          push bx
   142                              <1> 
   143 000000AF FC                  <1>          cld
   144 000000B0 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0         ;小心！64位模式下movsq
   144 000000B9 FF                  <1>
   145 000000BA 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO                ;使用的是rsi/rdi/rcx
   145 000000C3 FF                  <1>
   146 000000C4 B9E0010000          <1>          mov rcx, 480
   147 000000C9 F348A5              <1>          rep movsq
   148 000000CC 66BB000F            <1>          mov bx, 3840                             ;清除屏幕最底一行
   149 000000D0 B950000000          <1>          mov rcx, 80                              ;64位程序应该使用RCX
   150                              <1>   .cls:
   151 000000D5 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   151 000000DE FF                  <1>
   152 000000DF 66C704182007        <1>          mov word[rax + rbx], 0x0720
   153 000000E5 6683C302            <1>          add bx, 2
   154 000000E9 E2EA                <1>          loop .cls
   155                              <1> 
   156 000000EB 665B                <1>          pop bx
   157 000000ED 6683EB50            <1>          sub bx, 80
   158                              <1> 
   159                              <1>   .set_cursor:
   160 000000F1 66BAD403            <1>          mov dx, 0x3d4
   161 000000F5 B00E                <1>          mov al, 0x0e
   162 000000F7 EE                  <1>          out dx, al
   163 000000F8 66FFC2              <1>          inc dx                                   ;0x3d5
   164 000000FB 88F8                <1>          mov al, bh
   165 000000FD EE                  <1>          out dx, al
   166 000000FE 66FFCA              <1>          dec dx                                   ;0x3d4
   167 00000101 B00F                <1>          mov al, 0x0f
   168 00000103 EE                  <1>          out dx, al
   169 00000104 66FFC2              <1>          inc dx                                   ;0x3d5
   170 00000107 88D8                <1>          mov al, bl
   171 00000109 EE                  <1>          out dx, al
   172                              <1> 
   173 0000010A 5F                  <1>          pop rdi
   174 0000010B 5E                  <1>          pop rsi
   175 0000010C 5A                  <1>          pop rdx
   176 0000010D 59                  <1>          pop rcx
   177 0000010E 5B                  <1>          pop rbx
   178 0000010F 58                  <1>          pop rax
   179                              <1> 
   180 00000110 C3                  <1>          ret
   181                              <1> 
   182                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   183                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的
   184                              <1> ;坐标位置不同，互不干扰，不需要加锁和互斥。
   185 00000111 0000000000000000    <1> _prnxy_locker dq 0
   186                              <1> 
   187                              <1> put_cstringxy64:                                  ;输入：RBX=字符串首地址
   188                              <1>                                                   ;DH=行，DL=列
   189                              <1>                                                   ;R9B=颜色属性
   190 00000119 50                  <1>          push rax
   191 0000011A 53                  <1>          push rbx
   192 0000011B 51                  <1>          push rcx
   193 0000011C 52                  <1>          push rdx
   194 0000011D 4150                <1>          push r8
   195                              <1> 
   196                              <1>          ;指定坐标位置在显存内的偏移量
   197 0000011F 88F0                <1>          mov al, dh
   198 00000121 B5A0                <1>          mov ch, 160                              ;每一行80个字符，占用160个字节
   199 00000123 F6E5                <1>          mul ch
   200 00000125 D0E2                <1>          shl dl, 1                                ;每个字符（列）占用2个字节，要乘以2
   201 00000127 6681E2FF00          <1>          and dx, 0x00ff
   202 0000012C 6601D0              <1>          add ax, dx                               ;得到指定坐标位置在显存内的偏移量
   203 0000012F 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   204                              <1> 
   205 00000135 9C                  <1>          pushfq                                   ;-->A
   206 00000136 FA                  <1>          cli
   207                              <1>          SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
    58                              <2>  %%spin_lock:
    59 00000137 48833DD2FFFFFF00    <2>  cmp %2, 0
    60 0000013F 7404                <2>  je %%get_lock
    61 00000141 F390                <2>  pause
    62 00000143 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000145 41B801000000        <2>  mov %1, 1
    65 0000014B 4C8705BFFFFFFF      <2>  xchg %1, %2
    66 00000152 4983F800            <2>  cmp %1, 0
    67 00000156 75DF                <2>  jne %%spin_lock
   208                              <1> 
   209 00000158 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO                 ;显存的起始线性地址
   209 00000161 FF                  <1>
   210                              <1>   .nextc:
   211 00000162 8A13                <1>          mov dl, [rbx]                            ;取得将要显示的字符
   212 00000164 08D2                <1>          or dl, dl
   213 00000166 7412                <1>          jz .exit
   214 00000168 41881400            <1>          mov byte [r8 + rax], dl
   215 0000016C 45884C0001          <1>          mov byte [r8 + rax + 1], r9b             ;字符颜色
   216 00000171 48FFC3              <1>          inc rbx
   217 00000174 4883C002            <1>          add rax, 2                               ;增加一个字符的位置（2个字节）
   218 00000178 EBE8                <1>          jmp .nextc
   219                              <1>   .exit:
   220 0000017A 4D31C0              <1>          xor r8, r8
   221                              <1> 
   222 0000017D 48C70589FFFFFF0000- <1>          mov qword [rel _prnxy_locker], 0         ;释放锁
   222 00000186 0000                <1>
   223 00000188 9D                  <1>          popfq                                    ;A
   224                              <1> 
   225 00000189 4158                <1>          pop r8
   226 0000018B 5A                  <1>          pop rdx
   227 0000018C 59                  <1>          pop rcx
   228 0000018D 5B                  <1>          pop rbx
   229 0000018E 58                  <1>          pop rax
   230                              <1> 
   231 0000018F C3                  <1>          ret
   232                              <1> 
   233                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   234                              <1> make_call_gate:                                   ;创建64位的调用门
   235                              <1>                                                   ;输入：RAX=例程的线性地址
   236                              <1>                                                   ;输出：RDI:RSI=调用门
   237 00000190 4889C7              <1>          mov rdi, rax
   238 00000193 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   239                              <1> 
   240 00000197 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   241 00000198 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   242 0000019F 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   243 000001A3 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00               ;添加P=1，TYPE=64位调用门
   244 000001AA 5E                  <1>          pop rsi
   245                              <1> 
   246 000001AB C3                  <1>          ret
   247                              <1> 
   248                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   249                              <1> make_interrupt_gate:                              ;创建64位的中断门
   250                              <1>                                                   ;输入：RAX=例程的线性地址
   251                              <1>                                                   ;输出：RDI:RSI=中断门
   252 000001AC 4889C7              <1>          mov rdi, rax
   253 000001AF 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   254                              <1> 
   255 000001B3 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   256 000001B4 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   257 000001BB 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   258 000001BF 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00               ;添加P=1，TYPE=64位中断门
   259 000001C6 5E                  <1>          pop rsi
   260                              <1> 
   261 000001C7 C3                  <1>          ret
   262                              <1> 
   263                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   264                              <1> make_trap_gate:                                   ;创建64位的陷阱门
   265                              <1>                                                   ;输入：RAX=例程的线性地址
   266                              <1>                                                   ;输出：RDI:RSI=陷阱门
   267 000001C8 4889C7              <1>          mov rdi, rax
   268 000001CB 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   269                              <1> 
   270 000001CF 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   271 000001D0 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   272 000001D7 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   273 000001DB 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00               ;添加P=1，TYPE=64位陷阱门
   274 000001E2 5E                  <1>          pop rsi
   275                              <1> 
   276 000001E3 C3                  <1>          ret
   277                              <1> 
   278                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   279                              <1> make_tss_descriptor:                              ;创建64位的TSS描述符
   280                              <1>                                                   ;输入：RAX=TSS的线性地址
   281                              <1>                                                   ;输出：RDI:RSI=TSS描述符
   282 000001E4 50                  <1>          push rax
   283                              <1> 
   284 000001E5 4889C7              <1>          mov rdi, rax
   285 000001E8 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   286                              <1> 
   287 000001EC 50                  <1>          push rax                                 ;先将部分线性地址移到适当位置
   288 000001ED 48C1242410          <1>          shl qword [rsp], 16                      ;将线性地址的位23~00移到正确位置
   289 000001F2 66C704246800        <1>          mov word [rsp], 104                      ;段界限的标准长度
   290 000001F8 8A442405            <1>          mov al, [rsp + 5]
   291 000001FC 88442407            <1>          mov [rsp + 7], al                        ;将线性地址的位31~24移到正确位置
   292 00000200 C644240589          <1>          mov byte [rsp + 5], 0x89                 ;P=1，DPL=00，TYPE=1001（64位TSS）
   293 00000205 C644240600          <1>          mov byte [rsp + 6], 0                    ;G、0、0、AVL和limit
   294 0000020A 5E                  <1>          pop rsi                                  ;门的低64位
   295                              <1> 
   296 0000020B 58                  <1>          pop rax
   297                              <1> 
   298 0000020C C3                  <1>          ret
   299                              <1> 
   300                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   301                              <1> mount_idt_entry:                                  ;在中断描述符表IDT中安装门描述符
   302                              <1>                                                   ;R8=中断向量
   303                              <1>                                                   ;RDI:RSI=门描述符
   304 0000020D 4150                <1>          push r8
   305 0000020F 4151                <1>          push r9
   306                              <1> 
   307 00000211 49C1E004            <1>          shl r8, 4                                ;中断号乘以16，得到表内偏移
   308 00000215 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR                 ;中断描述符表的高端线性地址
   308 0000021E FF                  <1>
   309 0000021F 4B893401            <1>          mov [r9 + r8], rsi
   310 00000223 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   311                              <1> 
   312 00000228 4159                <1>          pop r9
   313 0000022A 4158                <1>          pop r8
   314                              <1> 
   315 0000022C C3                  <1>          ret
   316                              <1> 
   317                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   318                              <1> init_8259:                                        ;初始化8259中断控制器，包括重新设置向量号
   319 0000022D 50                  <1>          push rax
   320                              <1> 
   321 0000022E B011                <1>          mov al, 0x11
   322 00000230 E620                <1>          out 0x20, al                             ;ICW1：边沿触发/级联方式
   323 00000232 B020                <1>          mov al, 0x20
   324 00000234 E621                <1>          out 0x21, al                             ;ICW2:起始中断向量（避开前31个异常的向量）
   325 00000236 B004                <1>          mov al, 0x04
   326 00000238 E621                <1>          out 0x21, al                             ;ICW3:从片级联到IR2
   327 0000023A B001                <1>          mov al, 0x01
   328 0000023C E621                <1>          out 0x21, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   329                              <1> 
   330 0000023E B011                <1>          mov al, 0x11
   331 00000240 E6A0                <1>          out 0xa0, al                             ;ICW1：边沿触发/级联方式
   332 00000242 B028                <1>          mov al, 0x28
   333 00000244 E6A1                <1>          out 0xa1, al                             ;ICW2:起始中断向量-->0x28
   334 00000246 B002                <1>          mov al, 0x02
   335 00000248 E6A1                <1>          out 0xa1, al                             ;ICW3:从片识别标志，级联到主片IR2
   336 0000024A B001                <1>          mov al, 0x01
   337 0000024C E6A1                <1>          out 0xa1, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   338                              <1> 
   339 0000024E 58                  <1>          pop rax
   340 0000024F C3                  <1>          ret
   341                              <1> 
   342                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   343 00000250 0000000000000000    <1> _read_hdd_locker dq 0                              ;读硬盘锁
   344                              <1> 
   345                              <1> read_hard_disk_0:                                 ;从硬盘读取一个逻辑扇区
   346                              <1>                                                   ;RAX=逻辑扇区号
   347                              <1>                                                   ;RBX=目标缓冲区线性地址
   348                              <1>                                                   ;返回：RBX=RBX+512
   349 00000258 50                  <1>          push rax
   350 00000259 51                  <1>          push rcx
   351 0000025A 52                  <1>          push rdx
   352                              <1> 
   353 0000025B 9C                  <1>          pushfq                                   ;-->A
   354 0000025C FA                  <1>          cli
   355                              <1>          SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
    58                              <2>  %%spin_lock:
    59 0000025D 48833DEBFFFFFF00    <2>  cmp %2, 0
    60 00000265 7404                <2>  je %%get_lock
    61 00000267 F390                <2>  pause
    62 00000269 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000026B BA01000000          <2>  mov %1, 1
    65 00000270 488715D9FFFFFF      <2>  xchg %1, %2
    66 00000277 4883FA00            <2>  cmp %1, 0
    67 0000027B 75E0                <2>  jne %%spin_lock
   356                              <1> 
   357 0000027D 50                  <1>          push rax
   358                              <1> 
   359 0000027E 66BAF201            <1>          mov dx, 0x1f2
   360 00000282 B001                <1>          mov al, 1
   361 00000284 EE                  <1>          out dx, al                               ;读取的扇区数
   362                              <1> 
   363 00000285 66FFC2              <1>          inc dx                                   ;0x1f3
   364 00000288 58                  <1>          pop rax
   365 00000289 EE                  <1>          out dx, al                               ;LBA地址7~0
   366                              <1> 
   367 0000028A 66FFC2              <1>          inc dx                                   ;0x1f4
   368 0000028D B108                <1>          mov cl, 8
   369 0000028F 48D3E8              <1>          shr rax, cl
   370 00000292 EE                  <1>          out dx, al                               ;LBA地址15~8
   371                              <1> 
   372 00000293 66FFC2              <1>          inc dx                                   ;0x1f5
   373 00000296 48D3E8              <1>          shr rax, cl
   374 00000299 EE                  <1>          out dx, al                               ;LBA地址23~16
   375                              <1> 
   376 0000029A 66FFC2              <1>          inc dx                                   ;0x1f6
   377 0000029D 48D3E8              <1>          shr rax, cl
   378 000002A0 0CE0                <1>          or al, 0xe0                              ;第一硬盘  LBA地址27~24
   379 000002A2 EE                  <1>          out dx, al
   380                              <1> 
   381 000002A3 66FFC2              <1>          inc dx                                   ;0x1f7
   382 000002A6 B020                <1>          mov al, 0x20                             ;读命令
   383 000002A8 EE                  <1>          out dx, al
   384                              <1> 
   385                              <1>   .waits:
   386 000002A9 EC                  <1>          in al, dx
   387                              <1>          ;and al, 0x88
   388                              <1>          ;cmp al, 0x08
   389 000002AA A808                <1>          test al, 8
   390 000002AC 74FB                <1>          jz .waits                               ;不忙，且硬盘已准备好数据传输
   391                              <1> 
   392 000002AE B900010000          <1>          mov rcx, 256                             ;总共要读取的字数
   393 000002B3 66BAF001            <1>          mov dx, 0x1f0
   394                              <1>   .readw:
   395 000002B7 66ED                <1>          in ax, dx
   396 000002B9 668903              <1>          mov [rbx], ax
   397 000002BC 4883C302            <1>          add rbx, 2
   398 000002C0 E2F5                <1>          loop .readw
   399                              <1> 
   400 000002C2 48C70583FFFFFF0000- <1>          mov qword [rel _read_hdd_locker], 0      ;释放锁
   400 000002CB 0000                <1>
   401 000002CD 9D                  <1>          popfq                                    ;A
   402                              <1> 
   403 000002CE 5A                  <1>          pop rdx
   404 000002CF 59                  <1>          pop rcx
   405 000002D0 58                  <1>          pop rax
   406                              <1> 
   407 000002D1 C3                  <1>          ret
   408                              <1> 
   409                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   410 000002D2 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          ;对应物理内存的前512个页面（2MB）
   411 00000312 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 ;对应后续的页面
   412                              <1>   _page_map_len  equ $ - _page_bit_map
   413                              <1> 
   414                              <1> allocate_a_4k_page:                               ;分配一个4KB的页
   415                              <1>                                                   ;输入：无
   416                              <1>                                                   ;输出：RAX=页的物理地址
   417 000006D2 4831C0              <1>          xor rax, rax
   418                              <1>   .b1:
   419 000006D5 F0480FAB05F4FBFFFF  <1>          lock bts [rel _page_bit_map], rax
   420 000006DE 730B                <1>          jnc .b2
   421 000006E0 48FFC0              <1>          inc rax
   422 000006E3 483D00200000        <1>          cmp rax, _page_map_len * 8               ;立即数符号扩展到64位进行比较
   423 000006E9 7CEA                <1>          jl .b1
   424                              <1> 
   425                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的
   426                              <1>          ;系统来说，如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注
   427                              <1>          ;销的页面，或者执行页面的换入和换出。
   428                              <1> 
   429                              <1>   .b2:
   430 000006EB 48C1E00C            <1>          shl rax, 12                              ;乘以4096（0x1000）
   431                              <1> 
   432 000006EF C3                  <1>          ret
   433                              <1> 
   434                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   435                              <1> lin_to_lin_of_pml4e:                              ;返回指定的线性地址所对应的4级头表项的线性地址
   436                              <1>                                                   ;输入：R13=线性地址
   437                              <1>                                                   ;输出：R14=对应的4级头表项的线性地址
   438 000006F0 4155                <1>          push r13
   439                              <1> 
   440 000006F2 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000           ;保留4级头表索引部分
   440 000006FB 00                  <1>
   441 000006FC 4D21F5              <1>          and r13, r14
   442 000006FF 49C1ED24            <1>          shr r13, 36                              ;原4级头表索引变成页内偏移
   443                              <1> 
   444 00000703 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000           ;访问4级头表所用的地址前缀
   445 0000070A 4D01EE              <1>          add r14, r13
   446                              <1> 
   447 0000070D 415D                <1>          pop r13
   448                              <1> 
   449 0000070F C3                  <1>          ret
   450                              <1> 
   451                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   452                              <1> lin_to_lin_of_pdpte:                              ;返回指定的线性地址所对应的页目录指针项的线性地址
   453                              <1>                                                   ;输入：R13=线性地址
   454                              <1>                                                   ;输出：R14=对应的页目录指针项的线性地址
   455 00000710 4155                <1>          push r13
   456                              <1> 
   457 00000712 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000           ;保留4级头表索引和页目录指针表索引部分
   457 0000071B 00                  <1>
   458 0000071C 4D21F5              <1>          and r13, r14
   459 0000071F 49C1ED1B            <1>          shr r13, 27                              ;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   460                              <1> 
   461 00000723 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000           ;访问页目录指针表所用的地址前缀
   462 0000072A 4D01EE              <1>          add r14, r13
   463                              <1> 
   464 0000072D 415D                <1>          pop r13
   465                              <1> 
   466 0000072F C3                  <1>          ret
   467                              <1> 
   468                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   469                              <1> lin_to_lin_of_pdte:                               ;返回指定的线性地址所对应的页目录项的线性地址
   470                              <1>                                                   ;输入：R13=线性地址
   471                              <1>                                                   ;输出：R14=对应的页目录项的线性地址
   472 00000730 4155                <1>          push r13
   473                              <1> 
   474 00000732 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000           ;保留4级头表索引、页目录指针表索引和页目录表索引部分
   474 0000073B 00                  <1>
   475 0000073C 4D21F5              <1>          and r13, r14
   476 0000073F 49C1ED12            <1>          shr r13, 18                              ;原4级头表索引变成页目录表索引，原页目录指针表索引变
   477                              <1>                                                   ;页表索引，原页目录表索引变页内偏移
   478 00000743 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000           ;访问页目录表所用的地址前缀
   479 0000074A 4D01EE              <1>          add r14, r13
   480                              <1> 
   481 0000074D 415D                <1>          pop r13
   482                              <1> 
   483 0000074F C3                  <1>          ret
   484                              <1> 
   485                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   486                              <1> lin_to_lin_of_pte:                                ;返回指定的线性地址所对应的页表项的线性地址
   487                              <1>                                                   ;输入：R13=线性地址
   488                              <1>                                                   ;输出：R14=对应的页表项的线性地址
   489 00000750 4155                <1>          push r13
   490                              <1> 
   491 00000752 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000           ;保留4级头表、页目录指针表、页目录表和页表的索引部分
   491 0000075B 00                  <1>
   492 0000075C 4D21F5              <1>          and r13, r14
   493 0000075F 49C1ED09            <1>          shr r13, 9                               ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   494                              <1>                                                   ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   495 00000763 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000           ;访问页表所用的地址前缀
   495 0000076C FF                  <1>
   496 0000076D 4D01EE              <1>          add r14, r13
   497                              <1> 
   498 00000770 415D                <1>          pop r13
   499                              <1> 
   500 00000772 C3                  <1>          ret
   501                              <1> 
   502                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   503 00000773 0000000000000000    <1> _spaging_locker dq 0
   504                              <1> 
   505                              <1> setup_paging_for_laddr:                           ;为指定的线性地址安装分页系统（表项）
   506                              <1>                                                   ;输入：R13=线性地址
   507 0000077B 51                  <1>          push rcx
   508 0000077C 50                  <1>          push rax
   509 0000077D 4156                <1>          push r14
   510                              <1> 
   511 0000077F 9C                  <1>          pushfq                                   ;-->A
   512 00000780 FA                  <1>          cli
   513                              <1>          SET_SPIN_LOCK r14, qword [rel _spaging_locker]
    58                              <2>  %%spin_lock:
    59 00000781 48833DEAFFFFFF00    <2>  cmp %2, 0
    60 00000789 7404                <2>  je %%get_lock
    61 0000078B F390                <2>  pause
    62 0000078D EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000078F 41BE01000000        <2>  mov %1, 1
    65 00000795 4C8735D7FFFFFF      <2>  xchg %1, %2
    66 0000079C 4983FE00            <2>  cmp %1, 0
    67 000007A0 75DF                <2>  jne %%spin_lock
   514                              <1> 
   515                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   516                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   517 000007A2 E849FFFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   518 000007A7 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   519 000007AE 752B                <1>          jnz .b0
   520                              <1> 
   521                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   522 000007B0 E81DFFFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   523 000007B5 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   524 000007B9 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   525                              <1> 
   526                              <1>          ;清空刚分配的页目录指针表
   527 000007BC E84FFFFFFF          <1>          call lin_to_lin_of_pdpte
   528 000007C1 49C1EE0C            <1>          shr r14, 12
   529 000007C5 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   530 000007C9 B900020000          <1>          mov rcx, 512
   531                              <1>   .cls0:
   532 000007CE 49C70600000000      <1>          mov qword [r14], 0
   533 000007D5 4983C608            <1>          add r14, 8
   534 000007D9 E2F3                <1>          loop .cls0
   535                              <1> ;-------------------------------------------------
   536                              <1>   .b0:
   537                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   538 000007DB E830FFFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   539 000007E0 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   540 000007E7 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   541                              <1> 
   542                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   543 000007E9 E8E4FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   544 000007EE 4883C807            <1>          or rax, 0x07                             ;添加属性位
   545 000007F2 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   546                              <1> 
   547                              <1>          ;清空刚分配的页目录表
   548 000007F5 E836FFFFFF          <1>          call lin_to_lin_of_pdte
   549 000007FA 49C1EE0C            <1>          shr r14, 12
   550 000007FE 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   551 00000802 B900020000          <1>          mov rcx, 512
   552                              <1>   .cls1:
   553 00000807 49C70600000000      <1>          mov qword [r14], 0
   554 0000080E 4983C608            <1>          add r14, 8
   555 00000812 E2F3                <1>          loop .cls1
   556                              <1> ;-------------------------------------------------
   557                              <1>   .b1:
   558                              <1>          ;检查该线性地址所对应的页目录项是否存在
   559 00000814 E817FFFFFF          <1>          call lin_to_lin_of_pdte
   560 00000819 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   561 00000820 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   562                              <1> 
   563                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   564 00000822 E8ABFEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   565 00000827 4883C807            <1>          or rax, 0x07                             ;添加属性位
   566 0000082B 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   567                              <1> 
   568                              <1>          ;清空刚分配的页表
   569 0000082E E81DFFFFFF          <1>          call lin_to_lin_of_pte
   570 00000833 49C1EE0C            <1>          shr r14, 12
   571 00000837 49C1E60C            <1>          shl r14, 12                             ;得到页表的线性地址
   572 0000083B B900020000          <1>          mov rcx, 512
   573                              <1>   .cls2:
   574 00000840 49C70600000000      <1>          mov qword [r14], 0
   575 00000847 4983C608            <1>          add r14, 8
   576 0000084B E2F3                <1>          loop .cls2
   577                              <1> ;-------------------------------------------------
   578                              <1>   .b2:
   579                              <1>          ;检查该线性地址所对应的页表项是否存在
   580 0000084D E8FEFEFFFF          <1>          call lin_to_lin_of_pte
   581 00000852 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   582 00000859 750C                <1>          jnz .b3                                  ;页表项已经存在，转.b3
   583                              <1> 
   584                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   585 0000085B E872FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页
   586 00000860 4883C807            <1>          or rax, 0x07                             ;添加属性位
   587 00000864 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   588                              <1> 
   589                              <1>   .b3:
   590 00000867 48C70501FFFFFF0000- <1>          mov qword [rel _spaging_locker], 0
   590 00000870 0000                <1>
   591 00000872 9D                  <1>          popfq                                    ;A
   592                              <1> 
   593 00000873 415E                <1>          pop r14
   594 00000875 58                  <1>          pop rax
   595 00000876 59                  <1>          pop rcx
   596                              <1> 
   597 00000877 C3                  <1>          ret
   598                              <1> 
   599                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   600 00000878 0000000000000000    <1> _mapping_locker dq 0
   601                              <1> 
   602                              <1> mapping_laddr_to_page:                            ;建立线性地址到物理页的映射
   603                              <1>                                                   ;即，为指定的线性地址安装指定的物理页
   604                              <1>                                                   ;输入：R13=线性地址
   605                              <1>                                                   ;      RAX=页的物理地址（含属性）
   606 00000880 51                  <1>          push rcx
   607 00000881 4156                <1>          push r14
   608                              <1> 
   609 00000883 9C                  <1>          pushfq
   610 00000884 FA                  <1>          cli
   611                              <1>          SET_SPIN_LOCK r14, qword [rel _mapping_locker]
    58                              <2>  %%spin_lock:
    59 00000885 48833DEBFFFFFF00    <2>  cmp %2, 0
    60 0000088D 7404                <2>  je %%get_lock
    61 0000088F F390                <2>  pause
    62 00000891 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000893 41BE01000000        <2>  mov %1, 1
    65 00000899 4C8735D8FFFFFF      <2>  xchg %1, %2
    66 000008A0 4983FE00            <2>  cmp %1, 0
    67 000008A4 75DF                <2>  jne %%spin_lock
   612                              <1> 
   613 000008A6 50                  <1>          push rax
   614                              <1> 
   615                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   616                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   617 000008A7 E844FEFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   618 000008AC 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   619 000008B3 752B                <1>          jnz .b0
   620                              <1> 
   621                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   622 000008B5 E818FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   623 000008BA 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   624 000008BE 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   625                              <1> 
   626                              <1>          ;清空刚分配的页目录指针表
   627 000008C1 E84AFEFFFF          <1>          call lin_to_lin_of_pdpte
   628 000008C6 49C1EE0C            <1>          shr r14, 12
   629 000008CA 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   630 000008CE B900020000          <1>          mov rcx, 512
   631                              <1>   .cls0:
   632 000008D3 49C70600000000      <1>          mov qword [r14], 0
   633 000008DA 4983C608            <1>          add r14, 8
   634 000008DE E2F3                <1>          loop .cls0
   635                              <1> ;-------------------------------------------------
   636                              <1>   .b0:
   637                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   638 000008E0 E82BFEFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   639 000008E5 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   640 000008EC 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   641                              <1> 
   642                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   643 000008EE E8DFFDFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   644 000008F3 4883C807            <1>          or rax, 0x07                             ;添加属性位
   645 000008F7 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   646                              <1> 
   647                              <1>          ;清空刚分配的页目录表
   648 000008FA E831FEFFFF          <1>          call lin_to_lin_of_pdte
   649 000008FF 49C1EE0C            <1>          shr r14, 12
   650 00000903 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   651 00000907 B900020000          <1>          mov rcx, 512
   652                              <1>   .cls1:
   653 0000090C 49C70600000000      <1>          mov qword [r14], 0
   654 00000913 4983C608            <1>          add r14, 8
   655 00000917 E2F3                <1>          loop .cls1
   656                              <1> ;-------------------------------------------------
   657                              <1>   .b1:
   658                              <1>          ;检查该线性地址所对应的页目录项是否存在
   659 00000919 E812FEFFFF          <1>          call lin_to_lin_of_pdte
   660 0000091E 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   661 00000925 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   662                              <1> 
   663                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   664 00000927 E8A6FDFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   665 0000092C 4883C807            <1>          or rax, 0x07                             ;添加属性位
   666 00000930 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   667                              <1> 
   668                              <1>          ;清空刚分配的页表
   669 00000933 E818FEFFFF          <1>          call lin_to_lin_of_pte
   670 00000938 49C1EE0C            <1>          shr r14, 12
   671 0000093C 49C1E60C            <1>          shl r14, 12                              ;得到页表的线性地址
   672 00000940 B900020000          <1>          mov rcx, 512
   673                              <1>   .cls2:
   674 00000945 49C70600000000      <1>          mov qword [r14], 0
   675 0000094C 4983C608            <1>          add r14, 8
   676 00000950 E2F3                <1>          loop .cls2
   677                              <1> ;-------------------------------------------------
   678                              <1>   .b2:
   679 00000952 E8F9FDFFFF          <1>          call lin_to_lin_of_pte                   ;得到页表项的线性地址
   680 00000957 58                  <1>          pop rax
   681 00000958 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   682                              <1> 
   683 0000095B 48C70512FFFFFF0000- <1>          mov qword [rel _mapping_locker], 0
   683 00000964 0000                <1>
   684 00000966 9D                  <1>          popfq
   685                              <1> 
   686 00000967 415E                <1>          pop r14
   687 00000969 59                  <1>          pop rcx
   688                              <1> 
   689 0000096A C3                  <1>          ret
   690                              <1> 
   691                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   692 0000096B 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START          ;下一次分配时可用的起始线性地址
   693 00000973 0000000000000000    <1>   _core_alloc_locker dq 0
   694                              <1> 
   695                              <1> core_memory_allocate:                             ;在虚拟地址空间的高端（内核）分配内存
   696                              <1>                                                   ;输入：RCX=请求分配的字节数
   697                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   698                              <1>                                                   ;      R14=下次分配的起始线性地址
   699 0000097B 9C                  <1>          pushfq                                   ;A-->
   700 0000097C FA                  <1>          cli
   701                              <1>          SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
    58                              <2>  %%spin_lock:
    59 0000097D 48833DEEFFFFFF00    <2>  cmp %2, 0
    60 00000985 7404                <2>  je %%get_lock
    61 00000987 F390                <2>  pause
    62 00000989 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 0000098B 41BE01000000        <2>  mov %1, 1
    65 00000991 4C8735DBFFFFFF      <2>  xchg %1, %2
    66 00000998 4983FE00            <2>  cmp %1, 0
    67 0000099C 75DF                <2>  jne %%spin_lock
   702                              <1> 
   703 0000099E 4C8B2DC6FFFFFF      <1>          mov r13, [rel _core_next_linear]         ;获得本次分配的起始线性地址
   704 000009A5 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   705                              <1> 
   706 000009AA 49F7C607000000      <1>          test r14, 0x07                           ;最低3位是000吗（是否按8字节对齐）？
   707 000009B1 740C                <1>          jz .algn
   708 000009B3 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   709 000009B7 49C1EE03            <1>          shr r14, 3
   710 000009BB 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   711                              <1> 
   712                              <1>   .algn:
   713 000009BF 4C8935A5FFFFFF      <1>          mov [rel _core_next_linear], r14         ;写回。
   714                              <1> 
   715 000009C6 48C705A2FFFFFF0000- <1>          mov qword [rel _core_alloc_locker], 0    ;释放锁
   715 000009CF 0000                <1>
   716 000009D1 9D                  <1>          popfq                                    ;A
   717                              <1> 
   718 000009D2 4155                <1>          push r13
   719 000009D4 4156                <1>          push r14
   720                              <1> 
   721                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   722 000009D6 49C1ED0C            <1>          shr r13, 12
   723 000009DA 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   724 000009DE 49C1EE0C            <1>          shr r14, 12
   725 000009E2 49C1E60C            <1>          shl r14, 12                              ;too
   726                              <1>   .next:
   727 000009E6 E890FDFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   728 000009EB 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   729 000009F2 4D39F5              <1>          cmp r13, r14
   730 000009F5 7EEF                <1>          jle .next
   731                              <1> 
   732 000009F7 415E                <1>          pop r14
   733 000009F9 415D                <1>          pop r13
   734                              <1> 
   735 000009FB C3                  <1>          ret
   736                              <1> 
   737                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   738                              <1> user_memory_allocate:                             ;在用户任务的私有空间（低端）分配内存
   739                              <1>                                                   ;输入：R11=任务控制块PCB的线性地址
   740                              <1>                                                   ;      RCX=希望分配的字节数
   741                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   742                              <1>                                                   ;      R14=下次分配的起始线性地址
   743                              <1>          ;获得本次内存分配的起始线性地址
   744 000009FC 4D8B6B18            <1>          mov r13, [r11 + 24]                      ;获得本次分配的起始线性地址
   745 00000A00 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   746                              <1> 
   747 00000A05 49F7C607000000      <1>          test r14, 0x07                           ;能够被8整除吗（是否按8字节对齐）？
   748 00000A0C 740C                <1>          jz .algn
   749 00000A0E 49C1EE03            <1>          shr r14, 3
   750 00000A12 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   751 00000A16 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   752                              <1> 
   753                              <1>   .algn:
   754 00000A1A 4D897318            <1>          mov [r11 + 24], r14                      ;写回PCB中。
   755                              <1> 
   756 00000A1E 4155                <1>          push r13
   757 00000A20 4156                <1>          push r14
   758                              <1> 
   759                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   760 00000A22 49C1ED0C            <1>          shr r13, 12
   761 00000A26 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   762 00000A2A 49C1EE0C            <1>          shr r14, 12
   763 00000A2E 49C1E60C            <1>          shl r14, 12                              ;too
   764                              <1>   .next:
   765 00000A32 E844FDFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   766 00000A37 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   767 00000A3E 4D39F5              <1>          cmp r13, r14
   768 00000A41 7EEF                <1>          jle .next
   769                              <1> 
   770 00000A43 415E                <1>          pop r14
   771 00000A45 415D                <1>          pop r13
   772                              <1> 
   773 00000A47 C3                  <1>          ret
   774                              <1> 
   775                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   776 00000A48 0000000000000000    <1> _copy_locker dq 0
   777                              <1> 
   778                              <1> copy_current_pml4:                                ;创建新的4级头表，并复制当前4级头表的内容
   779                              <1>                                                   ;输入：无
   780                              <1>                                                   ;输出：RAX=新4级头表的物理地址及属性
   781 00000A50 56                  <1>          push rsi
   782 00000A51 57                  <1>          push rdi
   783 00000A52 4155                <1>          push r13
   784 00000A54 51                  <1>          push rcx
   785                              <1> 
   786 00000A55 9C                  <1>          pushfq                                   ;-->A
   787 00000A56 FA                  <1>          cli
   788                              <1>          SET_SPIN_LOCK rcx, qword [rel _copy_locker]
    58                              <2>  %%spin_lock:
    59 00000A57 48833DE9FFFFFF00    <2>  cmp %2, 0
    60 00000A5F 7404                <2>  je %%get_lock
    61 00000A61 F390                <2>  pause
    62 00000A63 EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000A65 B901000000          <2>  mov %1, 1
    65 00000A6A 48870DD7FFFFFF      <2>  xchg %1, %2
    66 00000A71 4883F900            <2>  cmp %1, 0
    67 00000A75 75E0                <2>  jne %%spin_lock
   789                              <1> 
   790 00000A77 E856FCFFFF          <1>          call allocate_a_4k_page                  ;分配一个物理页
   791 00000A7C 4883C807            <1>          or rax, 0x07                             ;立即数符号扩展到64位参与操作
   792 00000A80 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR                 ;用指定的线性地址映射和访问这个页
   792 00000A89 FF                  <1>
   793 00000A8A E8F1FDFFFF          <1>          call mapping_laddr_to_page
   794                              <1> 
   795                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   796 00000A8F 410F017D00          <1>          invlpg [r13]
   797                              <1> 
   798 00000A94 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000           ;RSI->当前活动4级头表的线性地址
   799 00000A9B 4C89EF              <1>          mov rdi, r13                             ;RDI->新4级头表的线性地址
   800 00000A9E B900020000          <1>          mov rcx, 512                             ;RCX=要复制的目录项数
   801 00000AA3 FC                  <1>          cld
   802 00000AA4 F348A5              <1>          repe movsq
   803                              <1> 
   804 00000AA7 498985F80F0000      <1>          mov [r13 + 0xff8], rax                   ;新4级头表的511号表项指向它自己
   805 00000AAE 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   806                              <1> 
   807 00000AB6 48C70587FFFFFF0000- <1>          mov qword [rel _copy_locker], 0
   807 00000ABF 0000                <1>
   808 00000AC1 9D                  <1>          popfq                                    ;A
   809                              <1> 
   810 00000AC2 59                  <1>          pop rcx
   811 00000AC3 415D                <1>          pop r13
   812 00000AC5 5F                  <1>          pop rdi
   813 00000AC6 5E                  <1>          pop rsi
   814                              <1> 
   815 00000AC7 C3                  <1>          ret
   816                              <1> 
   817                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   818 00000AC8 0000000000000000    <1> _cmos_locker dq 0
   819                              <1> 
   820                              <1> get_cmos_time:                                    ;从CMOS中获取当前时间
   821                              <1>                                                   ;输入：RBX=缓冲区线性地址
   822 00000AD0 50                  <1>          push rax
   823                              <1> 
   824 00000AD1 9C                  <1>          pushfq                                   ;-->A
   825 00000AD2 FA                  <1>          cli
   826                              <1>          SET_SPIN_LOCK rax, qword [rel _cmos_locker]
    58                              <2>  %%spin_lock:
    59 00000AD3 48833DEDFFFFFF00    <2>  cmp %2, 0
    60 00000ADB 7404                <2>  je %%get_lock
    61 00000ADD F390                <2>  pause
    62 00000ADF EBF2                <2>  jmp %%spin_lock
    63                              <2>  %%get_lock:
    64 00000AE1 B801000000          <2>  mov %1, 1
    65 00000AE6 488705DBFFFFFF      <2>  xchg %1, %2
    66 00000AED 4883F800            <2>  cmp %1, 0
    67 00000AF1 75E0                <2>  jne %%spin_lock
   827                              <1> 
   828                              <1>   .w0:
   829 00000AF3 B08A                <1>          mov al, 0x8a
   830 00000AF5 E670                <1>          out 0x70, al
   831 00000AF7 E471                <1>          in al, 0x71                              ;读寄存器A
   832 00000AF9 A880                <1>          test al, 0x80                            ;测试第7位UIP，等待更新周期结束。
   833 00000AFB 75F6                <1>          jnz .w0
   834                              <1> 
   835 00000AFD B084                <1>          mov al, 0x84
   836 00000AFF E670                <1>          out 0x70, al
   837 00000B01 E471                <1>          in al, 0x71                              ;读RTC当前时间(时)
   838 00000B03 88C4                <1>          mov ah, al
   839                              <1> 
   840 00000B05 C0EC04              <1>          shr ah, 4
   841 00000B08 80E40F              <1>          and ah, 0x0f
   842 00000B0B 80C430              <1>          add ah, 0x30
   843 00000B0E 8823                <1>          mov [rbx], ah
   844                              <1> 
   845 00000B10 240F                <1>          and al, 0x0f
   846 00000B12 0430                <1>          add al, 0x30
   847 00000B14 884301              <1>          mov [rbx + 1], al
   848                              <1> 
   849 00000B17 C643023A            <1>          mov byte [rbx + 2], ':'
   850                              <1> 
   851 00000B1B B082                <1>          mov al, 0x82
   852 00000B1D E670                <1>          out 0x70, al
   853 00000B1F E471                <1>          in al, 0x71                              ;读RTC当前时间(分)
   854 00000B21 88C4                <1>          mov ah, al
   855                              <1> 
   856 00000B23 C0EC04              <1>          shr ah, 4
   857 00000B26 80E40F              <1>          and ah, 0x0f
   858 00000B29 80C430              <1>          add ah, 0x30
   859 00000B2C 886303              <1>          mov [rbx + 3], ah
   860                              <1> 
   861 00000B2F 240F                <1>          and al, 0x0f
   862 00000B31 0430                <1>          add al, 0x30
   863 00000B33 884304              <1>          mov [rbx + 4], al
   864                              <1> 
   865 00000B36 C643053A            <1>          mov byte [rbx + 5], ':'
   866                              <1> 
   867 00000B3A B080                <1>          mov al, 0x80
   868 00000B3C E670                <1>          out 0x70, al
   869 00000B3E E471                <1>          in al, 0x71                              ;读RTC当前时间(秒)
   870 00000B40 88C4                <1>          mov ah, al                               ;分拆成两个数字
   871                              <1> 
   872 00000B42 C0EC04              <1>          shr ah, 4                                ;逻辑右移4位
   873 00000B45 80E40F              <1>          and ah, 0x0f
   874 00000B48 80C430              <1>          add ah, 0x30
   875 00000B4B 886306              <1>          mov [rbx + 6], ah
   876                              <1> 
   877 00000B4E 240F                <1>          and al, 0x0f                             ;仅保留低4位
   878 00000B50 0430                <1>          add al, 0x30                             ;转换成ASCII
   879 00000B52 884307              <1>          mov [rbx + 7], al
   880                              <1> 
   881 00000B55 C6430800            <1>          mov byte [rbx + 8], 0                    ;空字符终止
   882                              <1> 
   883 00000B59 48C70564FFFFFF0000- <1>          mov qword [rel _cmos_locker], 0
   883 00000B62 0000                <1>
   884 00000B64 9D                  <1>          popfq                                    ;A
   885                              <1> 
   886 00000B65 58                  <1>          pop rax
   887                              <1> 
   888 00000B66 C3                  <1>          ret
   889                              <1> 
   890                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   891 00000B67 0000000000000000    <1>   _process_id        dq 0
   892                              <1> generate_process_id:                              ;生成唯一的进程标识
   893                              <1>                                                   ;返回：RAX=进程标识
   894 00000B6F B801000000          <1>          mov rax, 1
   895 00000B74 F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _process_id], rax
   896                              <1> 
   897 00000B7D C3                  <1>          ret
   898                              <1> 
   899                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   900 00000B7E 0000000000000000    <1>   _thread_id dq 0
   901                              <1> 
   902                              <1> generate_thread_id:                               ;生成唯一的线程标识
   903                              <1>                                                   ;返回：RAX=线程标识
   904 00000B86 B801000000          <1>          mov rax, 1
   905 00000B8B F0480FC105EAFFFFFF  <1>          lock xadd qword [rel _thread_id], rax
   906                              <1> 
   907 00000B94 C3                  <1>          ret
   908                              <1> 
   909                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   910 00000B95 08                  <1>   _screen_row        db 8
   911                              <1> get_screen_row:                                   ;返回下一个屏幕坐标行的行号
   912                              <1>                                                   ;返回：DH=行号
   913 00000B96 B601                <1>          mov dh, 1
   914 00000B98 F00FC035F5FFFFFF    <1>          lock xadd byte [rel _screen_row], dh
   915                              <1> 
   916 00000BA0 C3                  <1>          ret
   917                              <1> 
   918                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   919                              <1> get_cpu_number:                                   ;返回当前处理器的编号
   920                              <1>                                                   ;返回：RAX=处理器编号
   921 00000BA1 9C                  <1>          pushfq
   922 00000BA2 FA                  <1>          cli
   923 00000BA3 0F01F8              <1>          swapgs
   924 00000BA6 65488B042510000000  <1>          mov rax, [gs:16]                         ;从处理器专属数据区取回
   925 00000BAF 0F01F8              <1>          swapgs
   926 00000BB2 9D                  <1>          popfq
   927 00000BB3 C3                  <1>          ret
   928                              <1> 
   929                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   930                              <1> memory_allocate:                                  ;用户空间的内存分配
   931                              <1>                                                   ;进入：RDX=期望分配的字节数
   932                              <1>                                                   ;输出：R13=所分配内存的起始线性地址
   933 00000BB4 51                  <1>          push rcx
   934 00000BB5 4153                <1>          push r11
   935 00000BB7 4156                <1>          push r14
   936                              <1> 
   937 00000BB9 9C                  <1>          pushfq
   938 00000BBA FA                  <1>          cli
   939 00000BBB 0F01F8              <1>          swapgs
   940 00000BBE 654C8B1C2508000000  <1>          mov r11, [gs:8]
   941 00000BC7 0F01F8              <1>          swapgs
   942 00000BCA 9D                  <1>          popfq
   943                              <1> 
   944 00000BCB 4889D1              <1>          mov rcx, rdx
   945 00000BCE E829FEFFFF          <1>          call user_memory_allocate
   946                              <1> 
   947 00000BD3 415E                <1>          pop r14
   948 00000BD5 415B                <1>          pop r11
   949 00000BD7 59                  <1>          pop rcx
   950                              <1> 
   951 00000BD8 C3                  <1>          ret
   952                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   953                              <1> 
    48                                  %include "..\common\user_static64.lib"
    49                              <1> ;用户程序使用的例程库，用来模拟高级语言的静态库。有些功能直接在本文件中实现，但
    50                              <1> ;有些功能需要通过syscall指令使用内核提供的系统调用。
    51                              <1> ;创建时间：2022-01-30 18:30，李忠
    52                              <1> ;此文件需要用预处理指令%include引入用户程序。
    53                              <1> 
    54                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    55                              <1>          bits 64
    56                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    57                              <1> bin64_to_dec:                                     ;将二进制数转换为十进制字符串。
    58                              <1>                                                   ;输入：R8=64位二进制数
    59                              <1>                                                   ;      RBX=目标缓冲区线性地址
    60 00000BD9 50                  <1>          push rax
    61 00000BDA 53                  <1>          push rbx
    62 00000BDB 51                  <1>          push rcx
    63 00000BDC 52                  <1>          push rdx
    64 00000BDD 4150                <1>          push r8
    65                              <1> 
    66 00000BDF 4C89C0              <1>          mov rax, r8                              ;!!
    67 00000BE2 41B80A000000        <1>          mov r8, 10
    68 00000BE8 4831C9              <1>          xor rcx, rcx
    69                              <1> 
    70                              <1>   .next_div:
    71 00000BEB 4831D2              <1>          xor rdx, rdx
    72 00000BEE 49F7F0              <1>          div r8
    73 00000BF1 52                  <1>          push rdx                                 ;保存分解的数位
    74 00000BF2 48FFC1              <1>          inc rcx                                  ;递增压栈的次数
    75 00000BF5 4809C0              <1>          or rax, rax                              ;商为0？
    76 00000BF8 7402                <1>          jz .rotate
    77 00000BFA EBEF                <1>          jmp .next_div
    78                              <1> 
    79                              <1>   .rotate:
    80 00000BFC 5A                  <1>          pop rdx
    81 00000BFD 80C230              <1>          add dl, 0x30                             ;数位转换成ASCII编码
    82 00000C00 8813                <1>          mov [rbx], dl
    83 00000C02 48FFC3              <1>          inc rbx
    84 00000C05 E2F5                <1>          loop .rotate
    85                              <1> 
    86 00000C07 C60300              <1>          mov byte [rbx], 0
    87                              <1> 
    88 00000C0A 4158                <1>          pop r8
    89 00000C0C 5A                  <1>          pop rdx
    90 00000C0D 59                  <1>          pop rcx
    91 00000C0E 5B                  <1>          pop rbx
    92 00000C0F 58                  <1>          pop rax
    93                              <1> 
    94 00000C10 C3                  <1>          ret                                      ;段内返回
    95                              <1> 
    96                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    97                              <1> string_concatenates:                              ;将源字符串连接到目的字符串的尾部
    98                              <1>                                                   ;输入：RSI=源字符串的线性地址
    99                              <1>                                                   ;      RDI=目的字符串的线性地址
   100 00000C11 50                  <1>          push rax
   101 00000C12 56                  <1>          push rsi
   102 00000C13 57                  <1>          push rdi
   103                              <1> 
   104                              <1>   .r0:
   105 00000C14 803F00              <1>          cmp byte [rdi], 0
   106 00000C17 7405                <1>          jz .r1
   107 00000C19 48FFC7              <1>          inc rdi
   108 00000C1C EBF6                <1>          jmp .r0
   109                              <1> 
   110                              <1>   .r1:
   111 00000C1E 8A06                <1>          mov al, [rsi]
   112 00000C20 8807                <1>          mov [rdi], al
   113 00000C22 3C00                <1>          cmp al, 0
   114 00000C24 7408                <1>          jz .r2
   115 00000C26 48FFC6              <1>          inc rsi
   116 00000C29 48FFC7              <1>          inc rdi
   117 00000C2C EBF0                <1>          jmp .r1
   118                              <1> 
   119                              <1>   .r2:
   120 00000C2E 5F                  <1>          pop rdi
   121 00000C2F 5E                  <1>          pop rsi
   122 00000C30 58                  <1>          pop rax
   123                              <1> 
   124 00000C31 C3                  <1>          ret
   125                              <1> 
   126                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   127                              <1> 
    49                                           bits 64
    50                                  
    51                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    52 00000C32 F900                      _ap_string      db 249, 0
    53                                  
    54                                  ap_to_core_entry:                                 ;应用处理器（AP）进入内核的入口点
    55                                           ;启用GDT的高端线性地址并加载IDTR
    56 00000C34 48B8007E00000080FF-              mov rax, UPPER_SDA_LINEAR
    56 00000C3D FF                 
    57 00000C3E 0F015002                         lgdt [rax + 2]                           ;只有在64位模式下才能加载64位线性地址部分
    58 00000C42 0F01580C                         lidt [rax + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
    59                                  
    60                                           ;为当前处理器创建64位模式下的专属栈
    61 00000C46 B900100000                       mov rcx, 4096
    62 00000C4B E82BFDFFFF                       call core_memory_allocate
    63 00000C50 4C89F4                           mov rsp, r14
    64                                  
    65                                           ;创建当前处理器的专属存储区（含TSS），并安装TSS描述符到GDT
    66 00000C53 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
    67 00000C58 E81EFDFFFF                       call core_memory_allocate
    68 00000C5D 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
    69 00000C64 E87BF5FFFF                       call make_tss_descriptor
    70                                  
    71 00000C69 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区的高端线性地址（低端亦可）
    71 00000C72 FF                 
    72                                  
    73 00000C73 4D8B4704                         mov r8, [r15 + 4]                        ;R8=GDT的线性地址
    74 00000C77 490FB74F02                       movzx rcx, word [r15 + 2]                ;RCX=GDT的界限值
    75 00000C7C 4989740801                       mov [r8 + rcx + 1], rsi                  ;TSS描述符的低64位
    76 00000C81 49897C0809                       mov [r8 + rcx + 9], rdi                  ;TSS描述符的高64位
    77                                  
    78 00000C86 664183470210                     add word [r15 + 2], 16
    79 00000C8C 410F015702                       lgdt [r15 + 2]                           ;重新加载GDTR
    80                                  
    81 00000C91 66C1E903                         shr cx, 3                                ;除以8（消除余数），得到索引号
    82 00000C95 66FFC1                           inc cx                                   ;索引号递增
    83 00000C98 66C1E103                         shl cx, 3                                ;将索引号移到正确位置
    84                                  
    85 00000C9C 0F00D9                           ltr cx                                   ;为当前处理器加载任务寄存器TR
    86                                  
    87                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
    88 00000C9F B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
    89 00000CA4 4C89E8                           mov rax, r13                             ;只用EAX
    90 00000CA7 4C89EA                           mov rdx, r13
    91 00000CAA 48C1EA20                         shr rdx, 32                              ;只用EDX
    92 00000CAE 0F30                             wrmsr
    93                                  
    94                                           ;为快速系统调用SYSCALL和SYSRET准备参数
    95 00000CB0 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
    96 00000CB5 0F32                             rdmsr
    97 00000CB7 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
    98 00000CBB 0F30                             wrmsr
    99                                  
   100 00000CBD B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   101 00000CC2 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   102 00000CC7 31C0                             xor eax, eax
   103 00000CC9 0F30                             wrmsr
   104                                  
   105 00000CCB B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   106 00000CD0 488B05(08000000)                 mov rax, [rel position]
   107 00000CD7 488D80[E1130000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   108 00000CDE 4889C2                           mov rdx, rax
   109 00000CE1 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   110 00000CE5 0F30                             wrmsr
   111                                  
   112 00000CE7 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   113 00000CEC 31D2                             xor edx, edx
   114 00000CEE B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   115 00000CF3 0F30                             wrmsr
   116                                  
   117 00000CF5 4C8B3D(08000000)                 mov r15, [rel position]
   118 00000CFC 498D9F[320C0000]                 lea rbx, [r15 + _ap_string]
   119 00000D03 E800F3FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   120                                  
   121 00000D08 0F01F8                           swapgs                                   ;准备用GS操作当前处理器的专属数据
   122 00000D0B 6548C7042508000000-              mov qword [gs:8], 0                      ;没有正在执行的任务
   122 00000D14 00000000           
   123 00000D18 4831C0                           xor rax, rax
   124 00000D1B 8A05(31010000)                   mov al, byte [rel ack_cpus]
   125 00000D21 654889042510000000               mov [gs:16], rax                         ;设置当前处理器的编号
   126 00000D2A 654889242518000000               mov [gs:24], rsp                         ;保存当前处理器的固有栈指针
   127 00000D33 0F01F8                           swapgs
   128                                  
   129 00000D36 FE05(31010000)                   inc byte [rel ack_cpus]                  ;递增应答计数值
   130                                  
   131 00000D3C C60425[82F00000]00               mov byte [AP_START_UP_ADDR + lock_var], 0;释放自旋锁
   132                                  
   133 00000D44 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   133 00000D4D FF                 
   134 00000D4E 0FBAAEF000000008                 bts dword [rsi + 0xf0], 8                ;设置SVR寄存器，允许LAPIC
   135                                  
   136 00000D56 FB                               sti                                      ;开放中断
   137                                  
   138                                    .do_idle:
   139 00000D57 F4                               hlt
   140 00000D58 EBFD                             jmp .do_idle
   141                                  
   142                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   143                                  general_interrupt_handler:                        ;通用中断处理过程
   144 00000D5A 48CF                             iretq
   145                                  
   146                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   147                                  general_exception_handler:                        ;通用异常处理过程
   148                                                                                    ;在24行0列显示红底白字的错误信息
   149 00000D5C 4C8B3D(08000000)                 mov r15, [rel position]
   150 00000D63 498D9F[780D0000]                 lea rbx, [r15 + exceptm]
   151 00000D6A B618                             mov dh, 24
   152 00000D6C B200                             mov dl, 0
   153 00000D6E 41B14F                           mov r9b, 0x4f
   154 00000D71 E8A3F3FFFF                       call put_cstringxy64                     ;位于core_utils64_mp.wid
   155                                  
   156 00000D76 FA                               cli
   157 00000D77 F4                               hlt                                      ;停机且不接受外部硬件中断
   158                                  
   159 00000D78 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
   159 00000D81 6F6E20726169736564-
   159 00000D8A 2C68616C742E00     
   160                                  
   161                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   162                                  search_for_a_ready_thread:                        ;查找一个就绪的线程并将其置为忙
   163                                                                                    ;返回：R11=就绪线程所属任务的PCB线性地址
   164                                                                                    ;      R12=就绪线程的TCB线性地址
   165                                           ;此例程通常是在中断处理过程内调用，默认中断是关闭状态。
   166 00000D91 50                               push rax
   167 00000D92 53                               push rbx
   168 00000D93 51                               push rcx
   169                                  
   170 00000D94 B901000000                       mov rcx, 1                               ;RCX=线程的“忙”状态
   171                                  
   172 00000D99 0F01F8                           swapgs
   173 00000D9C 65488B1C2508000000               mov rbx, [gs:8]                          ;取得当前任务的PCB线性地址
   174 00000DA5 654C8B242520000000               mov r12, [gs:32]                         ;取得当前线程的TCB线性地址
   175                                           ;mov r12, [r12 + 280]                     ;得到下一个TCB
   176 00000DAE 0F01F8                           swapgs
   177 00000DB1 4989DB                           mov r11, rbx
   178 00000DB4 4983FB00                         cmp r11, 0                               ;处理器当前未在执行任务？
   179 00000DB8 7511                             jne .nextt
   180 00000DBA 488B1D(C1020000)                 mov rbx, [rel pcb_ptr]                   ;是的。从链表首节点开始搜索。
   181 00000DC1 4989DB                           mov r11, rbx
   182 00000DC4 4D8BA310010000                   mov r12, [r11 + 272]                     ;任务链表首节点的TCB首节点
   183                                    .nextt:                                         ;这一部分遍历指定任务的TCB链表
   184 00000DCB 4983FC00                         cmp r12, 0
   185 00000DCF 7416                             je .nextp
   186 00000DD1 4831C0                           xor rax, rax
   187 00000DD4 F0490FB14C2410                   lock cmpxchg [r12 + 16], rcx
   188 00000DDB 7425                             jz .retrn
   189 00000DDD 4D8BA42418010000                 mov r12, [r12 + 280]                     ;取得下一个TCB节点
   190 00000DE5 EBE4                             jmp .nextt
   191                                    .nextp:                                         ;这一部分控制任务链表的遍历
   192 00000DE7 4D8B9B18010000                   mov r11, [r11 + 280]
   193 00000DEE 4939DB                           cmp r11, rbx                             ;是否转一圈回到当前节点？
   194 00000DF1 7409                             je .fmiss                                ;是。未找到就绪任务（节点）
   195 00000DF3 4D8BA310010000                   mov r12, [r11 + 272]                     ;不是。提取下一任务的TCB首节点
   196 00000DFA EBCF                             jmp .nextt
   197                                    .fmiss:                                         ;看来系统中不存在就绪线程
   198 00000DFC 4D31DB                           xor r11, r11
   199 00000DFF 4D31E4                           xor r12, r12
   200                                    .retrn:
   201 00000E02 59                               pop rcx
   202 00000E03 5B                               pop rbx
   203 00000E04 58                               pop rax
   204 00000E05 C3                               ret
   205                                  
   206                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   207                                  resume_execute_a_thread:                          ;恢复执行一个线程
   208                                                                                    ;传入：R11=线程所属的任务的PCB线性地址
   209                                                                                    ;      R12=线程的TCB线性地址
   210                                           ;此例程在中断处理过程内调用，默认中断是关闭状态。
   211 00000E06 8B05(32010000)                   mov eax, [rel clocks_1ms]                ;以下计算新线程运行时间
   212 00000E0C 418B9C24F0000000                 mov ebx, [r12 + 240]                     ;为线程指定的时间片
   213 00000E14 F7E3                             mul ebx
   214                                  
   215 00000E16 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   215 00000E1F FF                 
   216 00000E20 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;1分频
   216 00000E29 00                 
   217 00000E2A C78620030000FD0000-              mov dword [rsi + 0x320], 0xfd            ;单次击发模式，Fixed，中断号0xfd
   217 00000E33 00                 
   218                                  
   219 00000E34 498B5B38                         mov rbx, [r11 + 56]
   220 00000E38 0F22DB                           mov cr3, rbx                             ;切换地址空间
   221                                  
   222 00000E3B 0F01F8                           swapgs
   223 00000E3E 654C891C2508000000               mov [gs:8], r11                          ;将新任务设置为当前任务
   224 00000E47 654C89242520000000               mov [gs:32], r12                         ;将新线程设置为当前线程
   225 00000E50 498B5C2420                       mov rbx, [r12 + 32]                      ;取TCB中的RSP0
   226 00000E55 6548891C2584000000               mov [gs:128 + 4], rbx                    ;置TSS的RSP0
   227 00000E5E 0F01F8                           swapgs
   228                                  
   229 00000E61 498B4C2450                       mov rcx, [r12 + 80]
   230 00000E66 498B542458                       mov rdx, [r12 + 88]
   231 00000E6B 498B7C2468                       mov rdi, [r12 + 104]
   232 00000E70 498B6C2470                       mov rbp, [r12 + 112]
   233 00000E75 498B642478                       mov rsp, [r12 + 120]
   234 00000E7A 4D8B842480000000                 mov r8, [r12 + 128]
   235 00000E82 4D8B8C2488000000                 mov r9, [r12 + 136]
   236 00000E8A 4D8B942490000000                 mov r10, [r12 + 144]
   237                                  
   238 00000E92 4D8BAC24A8000000                 mov r13, [r12 + 168]
   239 00000E9A 4D8BB424B0000000                 mov r14, [r12 + 176]
   240 00000EA2 4D8BBC24B8000000                 mov r15, [r12 + 184]
   241 00000EAA 41FFB424D0000000                 push qword [r12 + 208]                   ;SS
   242 00000EB2 41FF742478                       push qword [r12 + 120]                   ;RSP
   243 00000EB7 41FFB424E8000000                 push qword [r12 + 232]                   ;RFLAGS
   244 00000EBF 41FFB424C8000000                 push qword [r12 + 200]                   ;CS
   245 00000EC7 41FFB424C0000000                 push qword [r12 + 192]                   ;RIP
   246                                  
   247 00000ECF 898680030000                     mov dword [rsi + 0x380], eax             ;开始计时
   248                                  
   249 00000ED5 498B442440                       mov rax, [r12 + 64]
   250 00000EDA 498B5C2448                       mov rbx, [r12 + 72]
   251 00000EDF 498B742460                       mov rsi, [r12 + 96]
   252 00000EE4 4D8B9C2498000000                 mov r11, [r12 + 152]
   253 00000EEC 4D8BA424A0000000                 mov r12, [r12 + 160]
   254                                  
   255 00000EF4 48CF                             iretq                                    ;转入新线程执行
   256                                  
   257                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   258                                  time_slice_out_handler:                           ;时间片到期中断的处理过程
   259 00000EF6 50                               push rax
   260 00000EF7 53                               push rbx
   261 00000EF8 4153                             push r11
   262 00000EFA 4154                             push r12
   263 00000EFC 4155                             push r13
   264                                  
   265 00000EFE 49BB00E0FFFF7FFFFF-              mov r11, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
   265 00000F07 FF                 
   266 00000F08 41C783B00000000000-              mov dword [r11 + 0xb0], 0
   266 00000F11 0000               
   267                                  
   268 00000F13 E879FEFFFF                       call search_for_a_ready_thread
   269 00000F18 4D09DB                           or r11, r11
   270 00000F1B 0F8490000000                     jz .return                               ;未找到就绪的线程
   271                                  
   272 00000F21 0F01F8                           swapgs
   273 00000F24 65488B042508000000               mov rax, qword [gs:8]                    ;当前任务的PCB线性地址
   274 00000F2D 65488B1C2520000000               mov rbx, qword [gs:32]                   ;当前线程的TCB线性地址
   275 00000F36 0F01F8                           swapgs
   276                                  
   277                                           ;保存当前任务的状态以便将来恢复执行。
   278 00000F39 410F20DD                         mov r13, cr3                             ;保存原任务的分页系统
   279 00000F3D 4C896838                         mov qword [rax + 56], r13
   280                                           ;RAX和RBX不需要保存，将来恢复执行时从栈中弹出
   281 00000F41 48894B50                         mov [rbx + 80], rcx
   282 00000F45 48895358                         mov [rbx + 88], rdx
   283 00000F49 48897360                         mov [rbx + 96], rsi
   284 00000F4D 48897B68                         mov [rbx + 104], rdi
   285 00000F51 48896B70                         mov [rbx + 112], rbp
   286 00000F55 48896378                         mov [rbx + 120], rsp
   287 00000F59 4C898380000000                   mov [rbx + 128], r8
   288 00000F60 4C898B88000000                   mov [rbx + 136], r9
   289 00000F67 4C899390000000                   mov [rbx + 144], r10
   290                                           ;r11、R12和R13不需要设置，将来恢复执行时从栈中弹出
   291 00000F6E 4C89B3B0000000                   mov [rbx + 176], r14
   292 00000F75 4C89BBB8000000                   mov [rbx + 184], r15
   293 00000F7C 4C8B2D(08000000)                 mov r13, [rel position]
   294 00000F83 4D8DAD[B10F0000]                 lea r13, [r13 + .return]                 ;将来恢复执行时，是从中断返回也～
   295 00000F8A 4C89ABC0000000                   mov [rbx + 192], r13                     ;RIP域为中断返回点
   296 00000F91 8C8BC8000000                     mov [rbx + 200], cs
   297 00000F97 8C93D0000000                     mov [rbx + 208], ss
   298 00000F9D 9C                               pushfq
   299 00000F9E 8F83E8000000                     pop qword [rbx + 232]
   300                                  
   301 00000FA4 48C7431000000000                 mov qword [rbx + 16], 0                  ;置线程状态为就绪
   302                                  
   303 00000FAC E955FEFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   304                                  
   305                                    .return:
   306 00000FB1 415D                             pop r13
   307 00000FB3 415C                             pop r12
   308 00000FB5 415B                             pop r11
   309 00000FB7 5B                               pop rbx
   310 00000FB8 58                               pop rax
   311 00000FB9 48CF                             iretq
   312                                  
   313                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   314                                  ;新任务/线程创建后，将广播新任务/线程创建消息给所有处理器，所有处理器执行此中断服务例程。
   315                                  new_task_notify_handler:                          ;任务/线程认领中断的处理过程
   316 00000FBB 56                               push rsi
   317 00000FBC 4153                             push r11
   318 00000FBE 4154                             push r12
   319                                  
   320 00000FC0 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   320 00000FC9 FF                 
   321 00000FCA C786B0000000000000-              mov dword [rsi + 0xb0], 0                ;发送EOI
   321 00000FD3 00                 
   322                                  
   323 00000FD4 0F01F8                           swapgs
   324 00000FD7 6548833C2508000000-              cmp qword [gs:8], 0                      ;当前处理器没有任务执行吗？
   324 00000FE0 00                 
   325 00000FE1 0F01F8                           swapgs
   326 00000FE4 7522                             jne .return                              ;是的（忙）。不打扰了 :)
   327                                  
   328 00000FE6 E8A6FDFFFF                       call search_for_a_ready_thread
   329 00000FEB 4D09DB                           or r11, r11
   330 00000FEE 7418                             jz .return                               ;未找到就绪的任务
   331                                  
   332 00000FF0 0F01F8                           swapgs
   333 00000FF3 4883C418                         add rsp, 24                              ;去掉进入例程时压入的三个参数
   334 00000FF7 654889242518000000               mov qword [gs:24], rsp                   ;保存固有栈当前指针以便将来返回
   335 00001000 0F01F8                           swapgs
   336                                  
   337 00001003 E9FEFDFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   338                                  
   339                                    .return:
   340 00001008 415C                             pop r12
   341 0000100A 415B                             pop r11
   342 0000100C 5E                               pop rsi
   343                                  
   344 0000100D 48CF                             iretq
   345                                  
   346                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   347 0000100F 0000000000000000          _append_lock  dq 0
   348                                  
   349                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   350                                                                                    ;输入：R11=PCB线性基地址
   351 00001017 50                               push rax
   352 00001018 53                               push rbx
   353                                  
   354 00001019 9C                               pushfq                                   ;-->A
   355 0000101A FA                               cli
   356                                           SET_SPIN_LOCK rax, qword [rel _append_lock]
    58                              <1>  %%spin_lock:
    59 0000101B 48833DECFFFFFF00    <1>  cmp %2, 0
    60 00001023 7404                <1>  je %%get_lock
    61 00001025 F390                <1>  pause
    62 00001027 EBF2                <1>  jmp %%spin_lock
    63                              <1>  %%get_lock:
    64 00001029 B801000000          <1>  mov %1, 1
    65 0000102E 488705DAFFFFFF      <1>  xchg %1, %2
    66 00001035 4883F800            <1>  cmp %1, 0
    67 00001039 75E0                <1>  jne %%spin_lock
   357                                  
   358 0000103B 488B1D(C1020000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   359 00001042 4809DB                           or rbx, rbx
   360 00001045 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   361 00001047 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   362 0000104A 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   363 00001051 4C891D(C1020000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   364 00001058 EB17                             jmp .return
   365                                  
   366                                    .not_empty:
   367 0000105A 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   368                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   369 0000105D 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   370 00001064 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   371 0000106B 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   372 0000106E 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   373                                  
   374                                    .return:
   375 00001071 48C70593FFFFFF0000-              mov qword [rel _append_lock], 0          ;释放锁
   375 0000107A 0000               
   376 0000107C 9D                               popfq                                    ;A
   377                                  
   378 0000107D 5B                               pop rbx
   379 0000107E 58                               pop rax
   380                                  
   381 0000107F C3                               ret
   382                                  
   383                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   384                                  get_current_tid:                                  ;返回当前线程的标识
   385 00001080 9C                               pushfq
   386 00001081 FA                               cli
   387 00001082 0F01F8                           swapgs
   388 00001085 65488B042520000000               mov rax, [gs:32]
   389 0000108E 488B4008                         mov rax, [rax + 8]
   390 00001092 0F01F8                           swapgs
   391 00001095 9D                               popfq
   392                                  
   393 00001096 C3                               ret
   394                                  
   395                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   396                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   397 00001097 9C                               pushfq
   398 00001098 FA                               cli
   399 00001099 0F01F8                           swapgs
   400 0000109C 65488B042508000000               mov rax, [gs:8]
   401 000010A5 488B4008                         mov rax, [rax + 8]
   402 000010A9 0F01F8                           swapgs
   403 000010AC 9D                               popfq
   404                                  
   405 000010AD C3                               ret
   406                                  
   407                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   408                                  thread_exit:                                      ;线程终止退出
   409                                                                                    ;输入：RDX=返回码
   410 000010AE FA                               cli
   411                                  
   412 000010AF 0F01F8                           swapgs
   413 000010B2 65488B1C2520000000               mov rbx, [gs:32]
   414 000010BB 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   415 000010C4 0F01F8                           swapgs
   416                                  
   417 000010C7 48C7431002000000                 mov qword [rbx + 16], 2                  ;线程状态：终止
   418 000010CF 48895318                         mov [rbx + 24], rdx                      ;返回代码
   419                                  
   420 000010D3 E8B9FCFFFF                       call search_for_a_ready_thread
   421 000010D8 4D09DB                           or r11, r11
   422 000010DB 7405                             jz .sleep                                ;未找到就绪的线程
   423                                  
   424 000010DD E924FDFFFF                       jmp resume_execute_a_thread              ;恢复并执行新线程
   425                                  
   426                                    .sleep:
   427 000010E2 48CF                             iretq                                    ;回到不执行线程的日子:)
   428                                  
   429                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   430                                  terminate_process:                                ;终止当前任务
   431 000010E4 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   431 000010ED FF                 
   432 000010EE C78620030000000001-              mov dword [rsi + 0x320], 0x00010000      ;屏蔽定时器中断
   432 000010F7 00                 
   433                                  
   434 000010F8 FA                               cli
   435                                  
   436 000010F9 0F01F8                           swapgs
   437 000010FC 65488B042508000000               mov rax, [gs:8]                          ;定位到当前任务的PCB节点
   438 00001105 48C7401002000000                 mov qword [rax + 16], 2                  ;任务状态=终止
   439 0000110D 65488B042520000000               mov rax, [gs:32]                         ;定位到当前线程的TCB节点
   440 00001116 48C7401002000000                 mov qword [rax + 16], 2                  ;线程状态=终止
   441 0000111E 6548C7042500000000-              mov qword [gs:0], 0
   441 00001127 00000000           
   442 0000112B 65488B242518000000               mov rsp, [gs:24]                         ;切换到处理器的固有栈
   443 00001134 0F01F8                           swapgs
   444                                  
   445 00001137 E855FCFFFF                       call search_for_a_ready_thread
   446 0000113C 4D09DB                           or r11, r11
   447 0000113F 7405                             jz .sleep                                ;未找到就绪的任务
   448                                  
   449 00001141 E9C0FCFFFF                       jmp resume_execute_a_thread              ;恢复并执行新任务
   450                                  
   451                                    .sleep:
   452 00001146 48CF                             iretq                                    ;回到不执行任务的日子:)
   453                                  
   454                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   455                                  create_thread:                                    ;创建一个线程
   456                                                                                    ;输入：RSI=线程入口的线性地址
   457                                                                                    ;      RDI=传递给线程的参数
   458                                                                                    ;输出：RDX=线程标识
   459 00001148 50                               push rax
   460 00001149 53                               push rbx
   461 0000114A 51                               push rcx
   462 0000114B 4153                             push r11
   463 0000114D 4154                             push r12
   464 0000114F 4155                             push r13
   465 00001151 4156                             push r14
   466                                  
   467                                           ;先创建线程控制块TCB
   468 00001153 B900020000                       mov rcx, 512                             ;线程控制块TCB的尺寸
   469 00001158 E81EF8FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   470                                  
   471 0000115D 4C89EB                           mov rbx, r13                             ;以下，RBX专用于保存TCB线性地址
   472                                  
   473 00001160 E821FAFFFF                       call generate_thread_id
   474 00001165 48894308                         mov [rbx + 8], rax                       ;记录当前线程的标识
   475 00001169 4889C2                           mov rdx, rax                             ;用于返回线程标识
   476                                  
   477 0000116C 48C7431000000000                 mov qword [rbx + 16], 0                  ;线程状态=就绪
   478                                  
   479 00001174 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   480 00001179 E8FDF7FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   481 0000117E 4C897320                         mov [rbx + 32], r14                      ;填写TCB中的RSP0域的值
   482                                  
   483 00001182 9C                               pushfq
   484 00001183 FA                               cli
   485 00001184 0F01F8                           swapgs
   486 00001187 654C8B1C2508000000               mov r11, [gs:8]                          ;获取当前任务的PCB线性地址
   487 00001190 654C8B242520000000               mov r12, [gs:32]                         ;获取当前线程的TCB线性地址
   488 00001199 0F01F8                           swapgs
   489 0000119C 9D                               popfq
   490                                  
   491 0000119D B900000100                       mov rcx, 4096 * 16                       ;为线程开辟栈空间
   492 000011A2 E855F8FFFF                       call user_memory_allocate
   493 000011A7 4983EE20                         sub r14, 32                              ;在栈中开辟32字节的空间
   494 000011AB 4C897378                         mov [rbx + 120], r14                     ;线程执行时的RSP。
   495                                  
   496 000011AF 498D4E08                         lea rcx, [r14 + 8]                       ;得到线程返回地址
   497 000011B3 49890E                           mov [r14], rcx
   498                                           ;以下填写指令MOV RAX, 9的机器代码
   499 000011B6 C601B8                           mov byte [rcx], 0xb8
   500 000011B9 C6410109                         mov byte [rcx + 1], 0x09
   501 000011BD C6410200                         mov byte [rcx + 2], 0x00
   502 000011C1 C6410300                         mov byte [rcx + 3], 0x00
   503 000011C5 C6410400                         mov byte [rcx + 4], 0x00
   504                                           ;以下填写指令XOR RDX, RDX的机器代码
   505 000011C9 C6410548                         mov byte [rcx + 5], 0x48
   506 000011CD C6410631                         mov byte [rcx + 6], 0x31
   507 000011D1 C64107D2                         mov byte [rcx + 7], 0xd2
   508                                           ;以下填写指令SYSCALL的机器代码
   509 000011D5 C641080F                         mov byte [rcx + 8], 0x0f
   510 000011D9 C6410905                         mov byte [rcx + 9], 0x05
   511                                  
   512 000011DD 4889B3C0000000                   mov qword [rbx + 192], rsi               ;线程入口点（RIP）
   513                                  
   514 000011E4 48C783C80000003B00-              mov qword [rbx + 200], USER_CODE64_SEL   ;线程的代码段选择子
   514 000011ED 0000               
   515 000011EF 48C783D00000003300-              mov qword [rbx + 208], USER_STACK64_SEL  ;线程的栈段选择子
   515 000011F8 0000               
   516                                  
   517 000011FA 9C                               pushfq
   518 000011FB 8F83E8000000                     pop qword [rbx + 232]                    ;线程执行时的标志寄存器
   519                                  
   520 00001201 48C783F00000003700-              mov qword [rbx + 240], SUGG_PREEM_SLICE  ;推荐的线程执行时间片，来自global_defs.wid
   520 0000120A 0000               
   521                                  
   522 0000120C 48C783180100000000-              mov qword [rbx + 280], 0                 ;下一个TCB的线性地址，0=无
   522 00001215 0000               
   523                                  
   524                                    .again:
   525 00001217 4831C0                           xor rax, rax
   526 0000121A F0490FB19C24180100-              lock cmpxchg [r12 + 280], rbx
   526 00001223 00                 
   527 00001224 740A                             jz .linkd
   528 00001226 4D8BA42418010000                 mov r12, [r12 + 280]
   529 0000122E EBE7                             jmp .again
   530                                    .linkd:
   531 00001230 48B900E0FFFF7FFFFF-              mov rcx, LAPIC_START_ADDR                ;Local APIC的线性地址
   531 00001239 FF                 
   532 0000123A C78110030000000000-              mov dword [rcx + 0x310], 0
   532 00001243 00                 
   533 00001244 C78100030000FE4008-              mov dword [rcx + 0x300], 0x000840fe      ;向所有处理器发送线程认领中断
   533 0000124D 00                 
   534                                  
   535 0000124E 415E                             pop r14
   536 00001250 415D                             pop r13
   537 00001252 415C                             pop r12
   538 00001254 415B                             pop r11
   539 00001256 59                               pop rcx
   540 00001257 5B                               pop rbx
   541 00001258 58                               pop rax
   542                                  
   543 00001259 C3                               ret
   544                                  
   545                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   546                                  create_process:                                   ;创建新的任务及其主线程
   547                                                                                    ;输入：R8=程序的起始逻辑扇区号
   548 0000125A 50                               push rax
   549 0000125B 53                               push rbx
   550 0000125C 51                               push rcx
   551 0000125D 52                               push rdx
   552 0000125E 56                               push rsi
   553 0000125F 57                               push rdi
   554 00001260 55                               push rbp
   555 00001261 4150                             push r8
   556 00001263 4151                             push r9
   557 00001265 4152                             push r10
   558 00001267 4153                             push r11
   559 00001269 4154                             push r12
   560 0000126B 4155                             push r13
   561 0000126D 4156                             push r14
   562 0000126F 4157                             push r15
   563                                  
   564                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   565 00001271 B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   566 00001276 E800F7FFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   567 0000127B 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   568                                  
   569 0000127E E8F8F6FFFF                       call core_memory_allocate                ;为线程控制块TCB分配内存
   570 00001283 4D89EC                           mov r12, r13                             ;以下，R12专用于保存TCB线性地址
   571                                  
   572 00001286 4D89A310010000                   mov qword [r11 + 272], r12               ;在PCB中登记第一个TCB
   573                                  
   574 0000128D 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   575                                  
   576                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   577 00001295 E8B6F7FFFF                       call copy_current_pml4
   578 0000129A 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   579                                  
   580                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
   581                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
   582                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈是位于地址空间高端的栈。
   583                                  
   584 0000129E 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   585 000012A2 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   586                                  
   587                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   588 000012A5 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   589 000012AC B900010000                       mov rcx, 256
   590                                    .clsp:
   591 000012B1 48C70000000000                   mov qword [rax], 0
   592 000012B8 4883C008                         add rax, 8
   593 000012BC E2F3                             loop .clsp
   594                                  
   595 000012BE 0F20D8                           mov rax, cr3                             ;刷新TLB
   596 000012C1 0F22D8                           mov cr3, rax
   597                                  
   598 000012C4 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   599 000012C9 E8ADF6FFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   600 000012CE 4D89742420                       mov [r12 + 32], r14                      ;填写TCB中的RSP0域的值
   601                                  
   602 000012D3 B900000100                       mov rcx, 4096 * 16                       ;为主线程开辟栈空间
   603 000012D8 E81FF7FFFF                       call user_memory_allocate
   604 000012DD 4D89742478                       mov [r12 + 120], r14                     ;主线程执行时的RSP。
   605                                  
   606 000012E2 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=运行
   607 000012EA 49C744241000000000               mov qword [r12 + 16], 0                  ;线程状态=就绪
   608                                  
   609                                           ;以下开始加载用户程序
   610 000012F3 B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   611 000012F8 E8FFF6FFFF                       call user_memory_allocate
   612 000012FD 4C89EB                           mov rbx, r13
   613 00001300 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   614 00001303 E850EFFFFF                       call read_hard_disk_0
   615                                  
   616 00001308 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   617 0000130C 4D89EE                           mov r14, r13
   618 0000130F 4D037508                         add r14, [r13 + 8]
   619 00001313 4D89B424C0000000                 mov [r12 + 192], r14                     ;在TCB中登记程序的入口点线性地址
   620                                  
   621                                           ;以下判断整个程序有多大
   622 0000131B 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   623 0000131F 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   624 00001326 740F                             jz .y512
   625 00001328 48C1E909                         shr rcx, 9                               ;不能？凑整。
   626 0000132C 48C1E109                         shl rcx, 9
   627 00001330 4881C100020000                   add rcx, 512
   628                                    .y512:
   629 00001337 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   630 0000133E 7416                             jz .rdok
   631 00001340 E8B7F6FFFF                       call user_memory_allocate
   632                                           ;mov rbx, r13
   633 00001345 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   634 00001349 48FFC0                           inc rax                                  ;起始扇区号
   635                                    .b1:
   636 0000134C E807EFFFFF                       call read_hard_disk_0
   637 00001351 48FFC0                           inc rax
   638 00001354 E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   639                                  
   640                                    .rdok:
   641 00001356 49C78424C80000003B-              mov qword [r12 + 200], USER_CODE64_SEL   ;主线程的代码段选择子
   641 0000135F 000000             
   642 00001362 49C78424D000000033-              mov qword [r12 + 208], USER_STACK64_SEL  ;主线程的栈段选择子
   642 0000136B 000000             
   643                                  
   644 0000136E 9C                               pushfq
   645 0000136F 418F8424E8000000                 pop qword [r12 + 232]
   646                                  
   647 00001377 49C78424F000000037-              mov qword [r12 + 240], SUGG_PREEM_SLICE  ;推荐的线程执行时间片，来自global_defs.wid
   647 00001380 000000             
   648                                  
   649 00001383 E8E7F7FFFF                       call generate_process_id
   650 00001388 49894308                         mov [r11 + 8], rax                       ;记录新任务的标识
   651                                  
   652 0000138C E8F5F7FFFF                       call generate_thread_id
   653 00001391 4989442408                       mov [r12 + 8], rax                       ;记录主线程的标识
   654                                  
   655 00001396 49C784241801000000-              mov qword [r12 + 280], 0                 ;下一个TCB的线性地址（0=无）
   655 0000139F 000000             
   656                                  
   657 000013A2 E870FCFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   658                                  
   659 000013A7 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   660                                  
   661 000013AB 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   661 000013B4 FF                 
   662 000013B5 C78610030000000000-              mov dword [rsi + 0x310], 0
   662 000013BE 00                 
   663 000013BF C78600030000FE4008-              mov dword [rsi + 0x300], 0x000840fe      ;向所有处理器发送任务/线程认领中断
   663 000013C8 00                 
   664                                  
   665 000013C9 415F                             pop r15
   666 000013CB 415E                             pop r14
   667 000013CD 415D                             pop r13
   668 000013CF 415C                             pop r12
   669 000013D1 415B                             pop r11
   670 000013D3 415A                             pop r10
   671 000013D5 4159                             pop r9
   672 000013D7 4158                             pop r8
   673 000013D9 5D                               pop rbp
   674 000013DA 5F                               pop rdi
   675 000013DB 5E                               pop rsi
   676 000013DC 5A                               pop rdx
   677 000013DD 59                               pop rcx
   678 000013DE 5B                               pop rbx
   679 000013DF 58                               pop rax
   680                                  
   681 000013E0 C3                               ret
   682                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   683                                  syscall_procedure:                                ;系统调用的处理过程
   684                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；进入时中断是禁止状态
   685 000013E1 0F01F8                           swapgs                                   ;切换GS到当前处理器的数据区
   686 000013E4 654889242500000000               mov [gs:0], rsp                          ;临时保存当前的3特权级栈指针
   687 000013ED 65488B242584000000               mov rsp, [gs:128+4]                      ;使用TSS的RSP0作为安全栈指针
   688 000013F6 65FF342500000000                 push qword [gs:0]
   689 000013FE 0F01F8                           swapgs
   690 00001401 FB                               sti                                      ;准备工作全部完成，中断和任务切换无虞
   691                                  
   692 00001402 4157                             push r15
   693 00001404 4C8B3D(08000000)                 mov r15, [rel position]
   694 0000140B 4D03BCC7[69020000]               add r15, [r15 + rax * 8 + sys_entry]     ;得到指定的那个系统调用功能的线性地址
   695 00001413 41FFD7                           call r15
   696 00001416 415F                             pop r15
   697                                  
   698 00001418 FA                               cli
   699 00001419 5C                               pop rsp                                  ;恢复原先的3特权级栈指针
   700 0000141A 480F07                           o64 sysret
   701                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   702                                  init:    ;初始化内核的工作环境
   703                                  
   704                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   705                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   706 0000141D 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   706 00001426 FF                 
   707 00001427 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   708                                  
   709 0000142F 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   710                                  
   711                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   712                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   713 00001437 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   713 00001440 FF                 
   714 00001441 4801C4                           add rsp, rax                             ;栈指针必须转换为高端地址且必须是扩高地址
   715                                  
   716                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   717 00001444 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   717 0000144D FF                 
   718 0000144E 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   719                                  
   720                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   721 00001455 488B05(08000000)                 mov rax, [rel position]
   722 0000145C 4805[64140000]                   add rax, .to_upper
   723 00001462 FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   724                                  
   725                                    .to_upper:
   726                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   727                                  
   728                                           ;为32个异常创建通用处理过程的中断门
   729 00001464 4C8B0D(08000000)                 mov r9, [rel position]
   730 0000146B 498D81[5C0D0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   731 00001472 E835EDFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   732                                  
   733 00001477 4D31C0                           xor r8, r8
   734                                    .idt0:
   735 0000147A E88EEDFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   736 0000147F 49FFC0                           inc r8
   737 00001482 4983F81F                         cmp r8, 31
   738 00001486 7EF2                             jle .idt0
   739                                  
   740                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   741 00001488 498D81[5A0D0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   742 0000148F E818EDFFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
   743                                  
   744 00001494 41B820000000                     mov r8, 32
   745                                    .idt1:
   746 0000149A E86EEDFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
   747 0000149F 49FFC0                           inc r8
   748 000014A2 4981F8FF000000                   cmp r8, 255
   749 000014A9 7EEF                             jle .idt1
   750                                  
   751 000014AB 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   751 000014B4 FF                 
   752 000014B5 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   752 000014BE FF                 
   753 000014BF 4889430E                         mov qword [rbx + 0x0e], rax
   754 000014C3 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   755                                  
   756 000014C9 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   757                                  
   758 000014CD B0FF                             mov al, 0xff                             ;屏蔽所有发往8259A主芯片的中断信号
   759 000014CF E621                             out 0x21, al                             ;多处理器环境下不再使用8259芯片
   760                                  
   761                                           ;在64位模式下显示的第一条信息!
   762 000014D1 4C8B3D(08000000)                 mov r15, [rel position]
   763 000014D8 498D9F[36010000]                 lea rbx, [r15 + welcome]
   764 000014DF E824EBFFFF                       call put_string64                        ;位于core_utils64_mp.wid
   765                                  
   766                                           ;安装系统服务（SYSCALL/SYSRET）所需要的代码段和栈段描述符
   767 000014E4 49BF007E00000080FF-              mov r15, UPPER_SDA_LINEAR                ;系统数据区SDA的线性地址
   767 000014ED FF                 
   768 000014EE 4831DB                           xor rbx, rbx
   769 000014F1 66418B5F02                       mov bx, [r15 + 2]                        ;BX=GDT的界限值
   770 000014F6 66FFC3                           inc bx                                   ;BX=GDT的长度
   771 000014F9 49035F04                         add rbx, [r15 + 4]                       ;RBX=新描述符的追加位置
   772                                  
   773 000014FD C703FFFF0000                     mov dword [rbx], 0x0000ffff              ;64位模式下不支持64位立即数传送
   774 00001503 C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   775 0000150A C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   776 00001511 C7430C00000000                   mov dword [rbx + 12], 0
   777 00001518 C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   778 0000151F C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   779 00001526 C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   780 0000152D C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   781                                  
   782                                           ;我们为每个逻辑处理器都准备一个专属数据区，它是由每个处理器的GS所指向的。
   783                                           ;为当前处理器（BSP）准备专属数据区，设置GS并安装任务状态段TSS的描述符
   784 00001534 B900010000                       mov rcx, 256                             ;专属数据区的长度，含TSS。
   785 00001539 E83DF4FFFF                       call core_memory_allocate
   786 0000153E 49C7450800000000                 mov qword [r13 + 8], 0                   ;提前将“当前任务的PCB指针域”清零
   787 00001546 49C7451000000000                 mov qword [r13 + 16], 0                  ;将当前处理器的编号设置为#0
   788 0000154E 49896518                         mov [r13 + 24], rsp                      ;设置当前处理器的专属栈
   789 00001552 498D8580000000                   lea rax, [r13 + 128]                     ;TSS开始于专属数据区内偏移为128的地方
   790 00001559 E886ECFFFF                       call make_tss_descriptor
   791 0000155E 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   792 00001562 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   793                                  
   794 00001566 664183470230                     add word [r15 + 2], 48                   ;4个段描述符和1个TSS描述符的总字节数
   795 0000156C 410F015702                       lgdt [r15 + 2]
   796                                  
   797 00001571 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   798 00001575 0F00D9                           ltr cx
   799                                  
   800                                           ;将处理器专属数据区首地址保存到当前处理器的型号专属寄存器IA32_KERNEL_GS_BASE
   801 00001578 B9020100C0                       mov ecx, 0xc000_0102                     ;IA32_KERNEL_GS_BASE
   802 0000157D 4C89E8                           mov rax, r13                             ;只用EAX
   803 00001580 4C89EA                           mov rdx, r13
   804 00001583 48C1EA20                         shr rdx, 32                              ;只用EDX
   805 00001587 0F30                             wrmsr
   806                                  
   807                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   808 00001589 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   809 0000158E 0F32                             rdmsr
   810 00001590 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   811 00001594 0F30                             wrmsr
   812                                  
   813 00001596 B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   814 0000159B BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   815 000015A0 31C0                             xor eax, eax
   816 000015A2 0F30                             wrmsr
   817                                  
   818 000015A4 B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   819 000015A9 488B05(08000000)                 mov rax, [rel position]
   820 000015B0 488D80[E1130000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   821 000015B7 4889C2                           mov rdx, rax
   822 000015BA 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   823 000015BE 0F30                             wrmsr
   824                                  
   825 000015C0 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   826 000015C5 31D2                             xor edx, edx
   827 000015C7 B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   828 000015CC 0F30                             wrmsr
   829                                  
   830                                           ;以下初始化高级可编程中断控制器APIC。在计算机启动后，BIOS已经对LAPIC和IOAPIC做了
   831                                           ;初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理器和
   832                                           ;APIC信息。英特尔架构的个人计算机（IA-PC）从1MB物理内存中搜索获取；启用可扩展固件
   833                                           ;接口（EFI或者叫UEFI）的计算机需使用EFI传递的EFI系统表指针定位相关表格并从中获取
   834                                           ;多处理器和APIC信息。为简单起见，我们采用前一种传统的方式。请注意虚拟机的配置！
   835                                  
   836                                           ;ACPI申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
   837                                           ;位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
   838 000015CE 66833C25167E000000               cmp word [SDA_PHY_ADDR + 0x16], 0
   839 000015D7 7411                             jz .acpi_err                             ;不正确的ACPI数据，可能不支持ACPI
   840 000015D9 BE187E0000                       mov rsi, SDA_PHY_ADDR + 0x18             ;系统数据区：地址范围描述结构的起始地址
   841                                    .looking:
   842 000015DE 837E1003                         cmp dword [rsi + 16], 3                  ;3:ACPI申领的内存（AddressRangeACPI）
   843 000015E2 741B                             jz .looked
   844 000015E4 4883C620                         add rsi, 32                              ;32:每个地址范围描述结构的长度
   845 000015E8 E2F4                             loop .looking
   846                                  
   847                                    .acpi_err:
   848 000015EA 4C8B3D(08000000)                 mov r15, [rel position]
   849 000015F1 498D9F[00000000]                 lea rbx, [r15 + acpi_error]
   850 000015F8 E80BEAFFFF                       call put_string64                        ;位于core_utils64_mp.wid
   851 000015FD FA                               cli
   852 000015FE F4                               hlt
   853                                  
   854                                    .looked:
   855 000015FF 488B1E                           mov rbx, [rsi]                           ;ACPI申领的起始物理地址
   856 00001602 488B4E08                         mov rcx, [rsi + 8]                       ;ACPI申领的内存数量，以字节计
   857 00001606 4801D9                           add rcx, rbx                             ;ACPI申领的内存上边界
   858 00001609 48C7C200F0FFFF                   mov rdx, 0xffff_ffff_ffff_f000           ;用于生成页地址的掩码
   859                                    .maping:
   860 00001610 4989DD                           mov r13, rbx                             ;R13:本次映射的线性地址
   861 00001613 4889D8                           mov rax, rbx
   862 00001616 4821D0                           and rax, rdx
   863 00001619 4883C807                         or rax, 0x07                             ;RAX:本次映射的物理地址及属性
   864 0000161D E85EF2FFFF                       call mapping_laddr_to_page
   865 00001622 4881C300100000                   add rbx, 0x1000
   866 00001629 4839CB                           cmp rbx, rcx
   867 0000162C 7EE2                             jle .maping
   868                                  
   869                                           ;从物理地址0x60000开始，搜索根系统描述指针结构（RSDP）
   870 0000162E BB00000600                       mov rbx, 0x60000
   871 00001633 48B952534420505452-              mov rcx, 'RSD PTR '                      ;结构的起始标记（注意尾部的空格）
   871 0000163C 20                 
   872                                    .searc:
   873 0000163D 48390B                           cmp qword [rbx], rcx
   874 00001640 740F                             je .finda
   875 00001642 4883C310                         add rbx, 16                              ;结构的标记总是位于16字节边界处
   876 00001646 4881FBF0FF0F00                   cmp rbx, 0xffff0                         ;低端1MB物理内存的上边界
   877 0000164D 7CEE                             jl .searc
   878 0000164F EB99                             jmp .acpi_err                            ;未找到RSDP，报错停机处理。
   879                                  
   880                                    .finda:
   881                                           ;RSDT和XSDT都指向MADT，但RSDT给出的是32位物理地址，而XDST给出64位物理地址。
   882                                           ;只有VCPI 2.0及更高版本才有XSDT。典型地，VBox支持ACPI 2.0而Bochs仅支持1.0
   883 00001651 807B0F02                         cmp byte [rbx + 15], 2                   ;检测ACPI的版本是否为2
   884 00001655 752B                             jne .vcpi_1
   885 00001657 488B5B18                         mov rbx, [rbx + 24]                      ;得到扩展的系统描述表（XSDT）的物理地址
   886                                  
   887                                           ;以下，开始在XSDT中遍历搜索多APIC描述表（MADT）
   888 0000165B 4831FF                           xor rdi, rdi
   889 0000165E 8B7B04                           mov edi, [rbx + 4]                       ;获得XSDT的长度（以字节计）
   890 00001661 4801DF                           add rdi, rbx                             ;计算XSDT上边界的物理位置
   891 00001664 4883C324                         add rbx, 36                              ;XSDT尾部数组的物理位置
   892                                    .madt0:
   893 00001668 4C8B1B                           mov r11, [rbx]
   894 0000166B 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   895 00001672 7436                             je .findm
   896 00001674 4883C308                         add rbx, 8                               ;下一个元素
   897 00001678 4839FB                           cmp rbx, rdi
   898 0000167B 7CEB                             jl .madt0
   899 0000167D E968FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   900                                  
   901                                           ;以下按VCPI 1.0处理，开始在RSDT中遍历搜索多APIC描述表（MADT）
   902                                    .vcpi_1:
   903 00001682 8B5B10                           mov ebx, [rbx + 16]                      ;得到根系统描述表（RSDT）的物理地址
   904                                           ;以下，开始在RSDT中遍历搜索多APIC描述表（MADT）
   905 00001685 678B7B04                         mov edi, [ebx + 4]                       ;获得RSDT的长度（以字节计）
   906 00001689 01DF                             add edi, ebx                             ;计算RSDT上边界的物理位置
   907 0000168B 83C324                           add ebx, 36                              ;RSDT尾部数组的物理位置
   908 0000168E 4D31DB                           xor r11, r11
   909                                    .madt1:
   910 00001691 67448B1B                         mov r11d, [ebx]
   911 00001695 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   912 0000169C 740C                             je .findm
   913 0000169E 83C304                           add ebx, 4                               ;下一个元素
   914 000016A1 39FB                             cmp ebx, edi
   915 000016A3 7CEC                             jl .madt1
   916 000016A5 E940FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   917                                  
   918                                    .findm:
   919                                           ;此时，R11是MADT的物理地址
   920 000016AA 418B5324                         mov edx, [r11 + 36]                      ;预置的LAPIC物理地址
   921 000016AE 8915(28010000)                   mov [rel lapic_addr], edx
   922                                  
   923                                           ;以下开始遍历系统中的逻辑处理器（其LAPID ID）和I/O APIC。
   924 000016B4 4C8B3D(08000000)                 mov r15, [rel position]                  ;为访问cpu_list准备线性地址
   925 000016BB 4D8DBF[28000000]                 lea r15, [r15 + cpu_list]
   926                                  
   927 000016C2 4831FF                           xor rdi, rdi
   928 000016C5 418B7B04                         mov edi, [r11 + 4]                       ;EDI:MADT的长度，以字节计
   929 000016C9 4C01DF                           add rdi, r11                             ;RDI:MADT上部边界的物理地址
   930 000016CC 4983C32C                         add r11, 44                              ;R11:指向MADT尾部的中断控制器结构列表
   931                                    .enumd:
   932 000016D0 41803B00                         cmp byte [r11], 0                        ;列表项类型：Processor Local APIC
   933 000016D4 7408                             je .l_apic
   934 000016D6 41803B01                         cmp byte [r11], 1                        ;列表项类型：I/O APIC
   935 000016DA 741B                             je .ioapic
   936 000016DC EB2D                             jmp .m_end
   937                                    .l_apic:
   938 000016DE 41837B0400                       cmp dword [r11 + 4], 0                   ;Local APIC Flags
   939 000016E3 7426                             jz .m_end
   940 000016E5 418A4303                         mov al, [r11 + 3]                        ;local APIC ID
   941 000016E9 418807                           mov [r15], al                            ;保存local APIC ID到cpu_list
   942 000016EC 49FFC7                           inc r15
   943 000016EF FE05(27000000)                   inc byte [rel num_cpus]                  ;可用的CPU数量递增
   944 000016F5 EB14                             jmp .m_end
   945                                    .ioapic:
   946 000016F7 418A4302                         mov al, [r11 + 2]                        ;取出I/O APIC ID
   947 000016FB 8805(30010000)                   mov [rel ioapic_id], al                  ;保存I/O APIC ID
   948 00001701 418B4304                         mov eax, [r11 + 4]                       ;取出I/O APIC物理地址
   949 00001705 8905(2C010000)                   mov [rel ioapic_addr], eax               ;保存I/O APIC物理地址
   950                                     .m_end:
   951 0000170B 4831C0                           xor rax, rax
   952 0000170E 418A4301                         mov al, [r11 + 1]
   953 00001712 4901C3                           add r11, rax                             ;计算下一个中断控制器结构列表项的地址
   954 00001715 4939FB                           cmp r11, rdi
   955 00001718 7CB6                             jl .enumd
   956                                  
   957                                           ;将Local APIC的物理地址映射到预定义的线性地址LAPIC_START_ADDR
   958 0000171A 49BD00E0FFFF7FFFFF-              mov r13, LAPIC_START_ADDR                ;在global_defs.wid中定义
   958 00001723 FF                 
   959 00001724 4831C0                           xor rax, rax
   960 00001727 8B05(28010000)                   mov eax, [rel lapic_addr]                ;取出LAPIC的物理地址
   961 0000172D 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   962 00001730 E84BF1FFFF                       call mapping_laddr_to_page
   963                                  
   964                                           ;将I/O APIC的物理地址映射到预定义的线性地址IOAPIC_START_ADDR
   965 00001735 49BD00D0FFFF7FFFFF-              mov r13, IOAPIC_START_ADDR               ;在global_defs.wid中定义
   965 0000173E FF                 
   966 0000173F 4831C0                           xor rax, rax
   967 00001742 8B05(2C010000)                   mov eax, [rel ioapic_addr]               ;取出I/O APIC的物理地址
   968 00001748 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   969 0000174B E830F1FFFF                       call mapping_laddr_to_page
   970                                  
   971                                           ;以下测量当前处理器在1毫秒的时间里经历多少时钟周期，作为后续的定时基准。
   972 00001750 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   972 00001759 FF                 
   973                                  
   974 0000175A C78620030000000001-              mov dword [rsi + 0x320], 0x10000         ;定时器的本地向量表入口寄存器。单次击发（one shot）模式
   974 00001763 00                 
   975 00001764 C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;定时器的分频配置寄存器：1分频（不分频）
   975 0000176D 00                 
   976                                  
   977 0000176E B00B                             mov al, 0x0b                             ;RTC寄存器B
   978 00001770 0C80                             or al, 0x80                              ;阻断NMI
   979 00001772 E670                             out 0x70, al
   980 00001774 B052                             mov al, 0x52                             ;设置寄存器B，开放周期性中断，开放更
   981 00001776 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   982                                  
   983 00001778 B08A                             mov al, 0x8a                             ;CMOS寄存器A
   984 0000177A E670                             out 0x70, al
   985                                           ;in al, 0x71
   986 0000177C B02D                             mov al, 0x2d                             ;32kHz，125ms的周期性中断
   987 0000177E E671                             out 0x71, al                             ;写回CMOS寄存器A
   988                                  
   989 00001780 B08C                             mov al, 0x8c
   990 00001782 E670                             out 0x70, al
   991 00001784 E471                             in al, 0x71                              ;读寄存器C
   992                                    .w0:
   993 00001786 E471                             in al, 0x71                              ;读寄存器C
   994 00001788 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   995 0000178D 73F7                             jnc .w0
   996 0000178F C78680030000FFFFFF-              mov dword [rsi + 0x380], 0xffff_ffff     ;定时器初始计数寄存器：置初值并开始计数
   996 00001798 FF                 
   997                                    .w1:
   998 00001799 E471                             in al, 0x71                              ;读寄存器C
   999 0000179B 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
  1000 000017A0 73F7                             jnc .w1
  1001 000017A2 8B9690030000                     mov edx, [rsi + 0x390]                   ;定时器当前计数寄存器：读当前计数值
  1002                                  
  1003 000017A8 B8FFFFFFFF                       mov eax, 0xffff_ffff
  1004 000017AD 29D0                             sub eax, edx
  1005 000017AF 31D2                             xor edx, edx
  1006 000017B1 BB7D000000                       mov ebx, 125                             ;125毫秒
  1007 000017B6 F7F3                             div ebx                                  ;EAX=当前处理器在1ms内的时钟数
  1008                                  
  1009 000017B8 8905(32010000)                   mov [rel clocks_1ms], eax                ;登记起来用于其它定时的场合
  1010                                  
  1011 000017BE B00B                             mov al, 0x0b                             ;RTC寄存器B
  1012 000017C0 0C80                             or al, 0x80                              ;阻断NMI
  1013 000017C2 E670                             out 0x70, al
  1014 000017C4 B012                             mov al, 0x12                             ;设置寄存器B，只允许更新周期结束中断
  1015 000017C6 E671                             out 0x71, al
  1016                                  
  1017                                           ;以下安装新任务认领中断的处理过程
  1018 000017C8 4C8B0D(08000000)                 mov r9, [rel position]
  1019 000017CF 498D81[BB0F0000]                 lea rax, [r9 + new_task_notify_handler]  ;得到中断处理过程的线性地址
  1020 000017D6 E8D1E9FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1021                                  
  1022 000017DB FA                               cli
  1023 000017DC 41B8FE000000                     mov r8, 0xfe
  1024 000017E2 E826EAFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1025 000017E7 FB                               sti
  1026                                  
  1027                                           ;以下安装时间片到期中断的处理过程
  1028 000017E8 4C8B0D(08000000)                 mov r9, [rel position]
  1029 000017EF 498D81[F60E0000]                 lea rax, [r9 + time_slice_out_handler]   ;得到中断处理过程的线性地址
  1030 000017F6 E8B1E9FFFF                       call make_interrupt_gate                 ;位于core_utils64_mp.wid
  1031                                  
  1032 000017FB FA                               cli
  1033 000017FC 41B8FD000000                     mov r8, 0xfd
  1034 00001802 E806EAFFFF                       call mount_idt_entry                     ;位于core_utils64_mp.wid
  1035 00001807 FB                               sti
  1036                                  
  1037                                           ;以下开始初始化应用处理器AP。先将初始化代码复制到物理内存最低端的选定位置
  1038 00001808 488B35(08000000)                 mov rsi, [rel position]
  1039 0000180F 488DB6[00000000]                 lea rsi, [rsi + section.ap_init_block.start]
  1040 00001816 BF00F00000                       mov rdi, AP_START_UP_ADDR
  1041 0000181B B983000000                       mov rcx, ap_init_tail - ap_init
  1042 00001820 FC                               cld
  1043 00001821 F3A4                             repe movsb
  1044                                  
  1045                                           ;所有处理器都应当在初始化期间递增应答计数值
  1046 00001823 FE05(31010000)                   inc byte [rel ack_cpus]                  ;BSP自己的应答计数值
  1047                                  
  1048                                           ;给其它处理器发送INIT IPI和SIPI，命令它们初始化自己
  1049 00001829 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
  1049 00001832 FF                 
  1050 00001833 C78610030000000000-              mov dword [rsi + 0x310], 0
  1050 0000183C 00                 
  1051 0000183D C7860003000000450C-              mov dword [rsi + 0x300], 0x000c4500      ;先发送INIT IPI
  1051 00001846 00                 
  1052 00001847 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
  1052 00001850 00                 
  1053 00001851 C786000300000F460C-              mov dword [rsi + 0x300], (AP_START_UP_ADDR >> 12) | 0x000c4600;Start up IPI
  1053 0000185A 00                 
  1054                                  
  1055 0000185B 8A05(27000000)                   mov al, [rel num_cpus]
  1056                                    .wcpus:
  1057 00001861 3A05(31010000)                   cmp al, [rel ack_cpus]
  1058 00001867 75F8                             jne .wcpus                               ;等待所有应用处理器的应答
  1059                                  
  1060                                           ;显示已应答的处理器的数量信息
  1061 00001869 4C8B3D(08000000)                 mov r15, [rel position]
  1062                                  
  1063 00001870 4D31C0                           xor r8, r8
  1064 00001873 448A05(31010000)                 mov r8b, [rel ack_cpus]
  1065 0000187A 498D9F[69010000]                 lea rbx, [r15 + buffer]
  1066 00001881 E853F3FFFF                       call bin64_to_dec
  1067 00001886 E87DE7FFFF                       call put_string64
  1068                                  
  1069 0000188B 498D9F[58010000]                 lea rbx, [r15 + cpu_init_ok]
  1070 00001892 E871E7FFFF                       call put_string64                        ;位于core_utils64_mp.wid
  1071                                  
  1072                                           ;以下开始创建系统外壳任务（进程）
  1073 00001897 41B832000000                     mov r8, 50
  1074 0000189D E8B8F9FFFF                       call create_process
  1075                                  
  1076 000018A2 E9B0F4FFFF                       jmp ap_to_core_entry.do_idle             ;去处理器集结休息区 :)
  1077                                  
  1078                                  ;===============================================================================
  1079                                  section ap_init_block vstart=0
  1080                                  
  1081                                           bits 16                                  ;应用处理器AP从实模式开始执行
  1082                                  
  1083                                  ap_init:                                          ;应用处理器AP的初始化代码
  1084 00000000 B8000F                           mov ax, AP_START_UP_ADDR >> 4
  1085 00000003 8ED8                             mov ds, ax
  1086                                  
  1087                                           SET_SPIN_LOCK al, byte [lock_var]        ;自旋直至获得锁
    58                              <1>  %%spin_lock:
    59 00000005 803E[8200]00        <1>  cmp %2, 0
    60 0000000A 7404                <1>  je %%get_lock
    61 0000000C F390                <1>  pause
    62 0000000E EBF5                <1>  jmp %%spin_lock
    63                              <1>  %%get_lock:
    64 00000010 B001                <1>  mov %1, 1
    65 00000012 8606[8200]          <1>  xchg %1, %2
    66 00000016 3C00                <1>  cmp %1, 0
    67 00000018 75EB                <1>  jne %%spin_lock
  1088                                  
  1089 0000001A B8E007                           mov ax, SDA_PHY_ADDR >> 4                ;切换到系统数据区
  1090 0000001D 8ED8                             mov ds, ax
  1091                                  
  1092                                           ;加载描述符表寄存器GDTR
  1093 0000001F 0F01160200                       lgdt [2]                                 ;实模式下只加载6个字节的内容
  1094                                  
  1095 00000024 E492                             in al, 0x92                              ;南桥芯片内的端口
  1096 00000026 0C02                             or al, 0000_0010B
  1097 00000028 E692                             out 0x92, al                             ;打开A20
  1098                                  
  1099 0000002A FA                               cli                                      ;中断机制尚未工作
  1100                                  
  1101 0000002B 0F20C0                           mov eax, cr0
  1102 0000002E 6683C801                         or eax, 1
  1103 00000032 0F22C0                           mov cr0, eax                             ;设置PE位
  1104                                  
  1105                                           ;以下进入保护模式... ...
  1106 00000035 EA[3AF0]0800                     jmp 0x0008: AP_START_UP_ADDR + .flush    ;清流水线并串行化处理器
  1107                                  
  1108                                           [bits 32]
  1109                                    .flush:
  1110 0000003A B810000000                       mov eax, 0x0010                          ;加载数据段(4GB)选择子
  1111 0000003F 8ED0                             mov ss, eax                              ;加载堆栈段(4GB)选择子
  1112 00000041 BC007E0000                       mov esp, 0x7e00                          ;堆栈指针
  1113                                  
  1114                                           ;令CR3寄存器指向4级头表（保护模式下的32位CR3）
  1115 00000046 B800A00000                       mov eax, PML4_PHY_ADDR                   ;PCD=PWT=0
  1116 0000004B 0F22D8                           mov cr3, eax
  1117                                  
  1118                                           ;开启物理地址扩展PAE
  1119 0000004E 0F20E0                           mov eax, cr4
  1120 00000051 0FBAE805                         bts eax, 5
  1121 00000055 0F22E0                           mov cr4, eax
  1122                                  
  1123                                           ;设置型号专属寄存器IA32_EFER.LME，允许IA_32e模式
  1124 00000058 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
  1125 0000005D 0F32                             rdmsr
  1126 0000005F 0FBAE808                         bts eax, 8                               ;设置LME位
  1127 00000063 0F30                             wrmsr
  1128                                  
  1129                                           ;开启分页功能
  1130 00000065 0F20C0                           mov eax, cr0
  1131 00000068 0FBAE81F                         bts eax, 31                              ;置位CR0.PG
  1132 0000006C 0F22C0                           mov cr0, eax
  1133                                  
  1134                                           ;进入64位模式
  1135 0000006F EA[76F00000]1800                 jmp CORE_CODE64_SEL:AP_START_UP_ADDR + .to64
  1136                                    .to64:
  1137                                  
  1138                                           bits 64
  1139                                  
  1140                                           ;转入内核中继续初始化（使用高端线性地址）
  1141 00000076 48BB-                            mov rbx, UPPER_CORE_LINEAR + ap_to_core_entry
  1141 00000078 [340C02000080FFFF] 
  1142 00000080 FFE3                             jmp rbx
  1143                                  
  1144 00000082 00                        lock_var  db 0
  1145                                  
  1146                                  ap_init_tail:
  1147                                  
  1148                                  ;===============================================================================
  1149                                  section core_tail
  1150                                  core_end:
