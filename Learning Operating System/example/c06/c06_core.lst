     1                                  ;单处理器多任务内核，2022-01-20
     2                                  
     3                                  %include "..\common\global_defs.wid"
     4                              <1> ;系统全局使用的常量定义，2021-09-05
     5                              <1> 
     6                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     7                              <1> 
     8                              <1> %ifndef _GLOBAL_DEFS_
     9                              <1>    %define _GLOBAL_DEFS_
    10                              <1> 
    11                              <1>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    12                              <1>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    13                              <1>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    14                              <1>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    15                              <1>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    16                              <1>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    17                              <1>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    18                              <1>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    19                              <1>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    20                              <1>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    21                              <1>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    22                              <1> 
    23                              <1>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    24                              <1>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    25                              <1> 
    26                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    27                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    28                              <1> 
    29                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    30                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    31                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    32                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    33                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    34                              <1> 
    35                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    36                              <1>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    37                              <1>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    38                              <1>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    39                              <1>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    40                              <1>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    41                              <1> 
    42                              <1>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    43                              <1>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    44                              <1>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    45                              <1> 
    46                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并对这个页做初始化操作，这需要一个线性地址
    47                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    48                              <1> 
    49                              <1>    LAPIC_START_ADDR    equ     0xffffff7ffee00000      ;LOCAL APIC寄存器的起始地址
    50                              <1> 
    51                              <1> %endif
     4                                  
     5                                  ;===============================================================================
     6                                  section core_header                               ;内核程序头部
     7 00000000 [A60F0000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
     8 00000004 [700D0000]                init_entry   dd init                            ;#4：内核入口点
     9 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    10                                  
    11                                  ;===============================================================================
    12                                  section core_data                                 ;内核数据段
    13 00000000 457865637574696E67-       welcome      db "Executing in 64-bit mode.", 0x0d, 0x0a, 0
    13 00000009 20696E2036342D6269-
    13 00000012 74206D6F64652E0D0A-
    13 0000001B 00                 
    14 0000001C 0000000000000000          tss_ptr      dq 0                               ;任务状态段TSS从此处开始
    15 00000024 [110A000000000000]        sys_entry    dq get_screen_row
    16 0000002C [8E09000000000000]                     dq get_cmos_time
    17 00000034 [DD00000000000000]                     dq put_cstringxy64
    18 0000003C [1F0C000000000000]                     dq create_process
    19 00000044 [FE0B000000000000]                     dq get_current_pid
    20 0000004C [0A0C000000000000]                     dq terminate_process
    21 00000054 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    22 0000005C 0000000000000000          cur_pcb      dq 0                               ;当前任务的PCB线性地址
    23                                  
    24                                  ;===============================================================================
    25                                  section core_code                                 ;内核代码段
    26                                  
    27                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    28                              <1> ;文件core_utils64.wid是供64位内核使用的函数集。
    29                              <1> ;创建时间：2021-11-07 10:15，李忠
    30                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，
    31                              <1> ;方便内核代码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    32                              <1> 
    33                              <1> %include "..\common\global_defs.wid"
    34                              <2> ;系统全局使用的常量定义，2021-09-05
    35                              <2> 
    36                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    37                              <2> 
    38                              <2> %ifndef _GLOBAL_DEFS_
    39                              <2>    %define _GLOBAL_DEFS_
    40                              <2> 
    41                              <2>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    42                              <2>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    43                              <2>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    44                              <2>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    45                              <2>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    46                              <2>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    47                              <2>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    48                              <2>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    49                              <2>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    50                              <2>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    51                              <2>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    52                              <2> 
    53                              <2>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    54                              <2>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    55                              <2> 
    56                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    57                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    58                              <2> 
    59                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    60                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    61                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    62                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    63                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    64                              <2> 
    65                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    66                              <2>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    67                              <2>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    68                              <2>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    69                              <2>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    70                              <2>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    71                              <2> 
    72                              <2>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    73                              <2>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    74                              <2>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    75                              <2> 
    76                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并对这个页做初始化操作，这需要一个线性地址
    77                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    78                              <2> 
    79                              <2>    LAPIC_START_ADDR    equ     0xffffff7ffee00000      ;LOCAL APIC寄存器的起始地址
    80                              <2> 
    81                              <2> %endif
    34                              <1> 
    35                              <1>          bits 64
    36                              <1> 
    37                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    38                              <1> put_string64:                                     ;显示0终止的字符串并移动光标
    39                              <1>                                                   ;输入：RBX=字符串的线性地址
    40 00000000 FA                  <1>          cli
    41                              <1> 
    42 00000001 53                  <1>          push rbx
    43 00000002 51                  <1>          push rcx
    44                              <1> 
    45                              <1>   .getc:
    46 00000003 8A0B                <1>          mov cl, [rbx]
    47 00000005 08C9                <1>          or cl, cl                                ;检测串结束标志（0）
    48 00000007 740A                <1>          jz .exit                                 ;显示完毕，返回
    49 00000009 E809000000          <1>          call put_char
    50 0000000E 48FFC3              <1>          inc rbx
    51 00000011 EBF0                <1>          jmp .getc
    52                              <1> 
    53                              <1>   .exit:
    54 00000013 59                  <1>          pop rcx
    55 00000014 5B                  <1>          pop rbx
    56                              <1> 
    57 00000015 FB                  <1>          sti
    58                              <1> 
    59 00000016 C3                  <1>          ret                                      ;段内返回
    60                              <1> 
    61                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    62                              <1> put_char:                                         ;在当前光标处显示一个字符,并推进
    63                              <1>                                                   ;光标。
    64                              <1>                                                   ;输入：CL=字符ASCII码
    65 00000017 50                  <1>          push rax
    66 00000018 53                  <1>          push rbx
    67 00000019 51                  <1>          push rcx
    68 0000001A 52                  <1>          push rdx
    69 0000001B 56                  <1>          push rsi
    70 0000001C 57                  <1>          push rdi
    71                              <1> 
    72                              <1>          ;以下取当前光标位置
    73 0000001D 66BAD403            <1>          mov dx, 0x3d4
    74 00000021 B00E                <1>          mov al, 0x0e
    75 00000023 EE                  <1>          out dx, al
    76 00000024 66FFC2              <1>          inc dx                                   ;0x3d5
    77 00000027 EC                  <1>          in al, dx                                ;高字
    78 00000028 88C4                <1>          mov ah, al
    79                              <1> 
    80 0000002A 66FFCA              <1>          dec dx                                   ;0x3d4
    81 0000002D B00F                <1>          mov al, 0x0f
    82 0000002F EE                  <1>          out dx, al
    83 00000030 66FFC2              <1>          inc dx                                   ;0x3d5
    84 00000033 EC                  <1>          in al, dx                                ;低字
    85 00000034 6689C3              <1>          mov bx, ax                               ;BX=代表光标位置的16位数
    86 00000037 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff              ;准备使用64位寻址方式访问显存
    87                              <1> 
    88 0000003E 80F90D              <1>          cmp cl, 0x0d                             ;回车符？
    89 00000041 750E                <1>          jnz .put_0a
    90 00000043 6689D8              <1>          mov ax, bx
    91 00000046 B350                <1>          mov bl, 80
    92 00000048 F6F3                <1>          div bl
    93 0000004A F6E3                <1>          mul bl
    94 0000004C 6689C3              <1>          mov bx, ax
    95 0000004F EB6C                <1>          jmp .set_cursor
    96                              <1> 
    97                              <1>   .put_0a:
    98 00000051 80F90A              <1>          cmp cl, 0x0a                             ;换行符？
    99 00000054 7506                <1>          jnz .put_other
   100 00000056 6683C350            <1>          add bx, 80
   101 0000005A EB16                <1>          jmp .roll_screen
   102                              <1> 
   103                              <1>   .put_other:                                     ;正常显示字符
   104 0000005C 66D1E3              <1>          shl bx, 1
   105 0000005F 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO                ;在global_defs.wid中定义
   105 00000068 FF                  <1>
   106 00000069 880C18              <1>          mov [rax + rbx], cl
   107                              <1> 
   108                              <1>          ;以下将光标位置推进一个字符
   109 0000006C 66D1EB              <1>          shr bx, 1
   110 0000006F 66FFC3              <1>          inc bx
   111                              <1> 
   112                              <1>   .roll_screen:
   113 00000072 6681FBD007          <1>          cmp bx, 2000                             ;光标超出屏幕？滚屏
   114 00000077 7C44                <1>          jl .set_cursor
   115                              <1> 
   116 00000079 6653                <1>          push bx
   117                              <1> 
   118 0000007B FC                  <1>          cld
   119 0000007C 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0         ;小心！64位模式下movsq
   119 00000085 FF                  <1>
   120 00000086 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO                ;使用的是rsi/rdi/rcx
   120 0000008F FF                  <1>
   121 00000090 B9E0010000          <1>          mov rcx, 480
   122 00000095 F348A5              <1>          rep movsq
   123 00000098 66BB000F            <1>          mov bx, 3840                             ;清除屏幕最底一行
   124 0000009C B950000000          <1>          mov rcx, 80                              ;64位程序应该使用RCX
   125                              <1>   .cls:
   126 000000A1 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   126 000000AA FF                  <1>
   127 000000AB 66C704182007        <1>          mov word[rax + rbx], 0x0720
   128 000000B1 6683C302            <1>          add bx, 2
   129 000000B5 E2EA                <1>          loop .cls
   130                              <1> 
   131 000000B7 665B                <1>          pop bx
   132 000000B9 6683EB50            <1>          sub bx, 80
   133                              <1> 
   134                              <1>   .set_cursor:
   135 000000BD 66BAD403            <1>          mov dx, 0x3d4
   136 000000C1 B00E                <1>          mov al, 0x0e
   137 000000C3 EE                  <1>          out dx, al
   138 000000C4 66FFC2              <1>          inc dx                                   ;0x3d5
   139 000000C7 88F8                <1>          mov al, bh
   140 000000C9 EE                  <1>          out dx, al
   141 000000CA 66FFCA              <1>          dec dx                                   ;0x3d4
   142 000000CD B00F                <1>          mov al, 0x0f
   143 000000CF EE                  <1>          out dx, al
   144 000000D0 66FFC2              <1>          inc dx                                   ;0x3d5
   145 000000D3 88D8                <1>          mov al, bl
   146 000000D5 EE                  <1>          out dx, al
   147                              <1> 
   148 000000D6 5F                  <1>          pop rdi
   149 000000D7 5E                  <1>          pop rsi
   150 000000D8 5A                  <1>          pop rdx
   151 000000D9 59                  <1>          pop rcx
   152 000000DA 5B                  <1>          pop rbx
   153 000000DB 58                  <1>          pop rax
   154                              <1> 
   155 000000DC C3                  <1>          ret
   156                              <1> 
   157                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   158                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符
   159                              <1> put_cstringxy64:                                  ;输入：RBX=字符串首地址
   160                              <1>                                                   ;DH=行，DL=列
   161                              <1>                                                   ;R9B=颜色属性
   162 000000DD FA                  <1>          cli
   163                              <1> 
   164 000000DE 50                  <1>          push rax
   165 000000DF 53                  <1>          push rbx
   166 000000E0 51                  <1>          push rcx
   167 000000E1 52                  <1>          push rdx
   168 000000E2 4150                <1>          push r8
   169                              <1> 
   170                              <1>          ;指定坐标位置在显存内的偏移量
   171 000000E4 88F0                <1>          mov al, dh
   172 000000E6 B5A0                <1>          mov ch, 160                              ;每一行80个字符，占用160个字节
   173 000000E8 F6E5                <1>          mul ch
   174 000000EA D0E2                <1>          shl dl, 1                                ;每个字符（列）占用2个字节，要乘以2
   175 000000EC 6681E2FF00          <1>          and dx, 0x00ff
   176 000000F1 6601D0              <1>          add ax, dx                               ;得到指定坐标位置在显存内的偏移量
   177 000000F4 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   178                              <1> 
   179 000000FA 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO                 ;显存的起始线性地址
   179 00000103 FF                  <1>
   180                              <1>   .nextc:
   181 00000104 8A13                <1>          mov dl, [rbx]                            ;取得将要显示的字符
   182 00000106 08D2                <1>          or dl, dl
   183 00000108 7412                <1>          jz .exit
   184 0000010A 41881400            <1>          mov byte [r8 + rax], dl
   185 0000010E 45884C0001          <1>          mov byte [r8 + rax + 1], r9b             ;字符颜色
   186 00000113 48FFC3              <1>          inc rbx
   187 00000116 4883C002            <1>          add rax, 2                               ;增加一个字符的位置（2个字节）
   188 0000011A EBE8                <1>          jmp .nextc
   189                              <1>   .exit:
   190 0000011C 4158                <1>          pop r8
   191 0000011E 5A                  <1>          pop rdx
   192 0000011F 59                  <1>          pop rcx
   193 00000120 5B                  <1>          pop rbx
   194 00000121 58                  <1>          pop rax
   195                              <1> 
   196 00000122 FB                  <1>          sti
   197                              <1> 
   198 00000123 C3                  <1>          ret
   199                              <1> 
   200                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   201                              <1> make_call_gate:                                   ;创建64位的调用门
   202                              <1>                                                   ;输入：RAX=例程的线性地址
   203                              <1>                                                   ;输出：RDI:RSI=调用门
   204 00000124 4889C7              <1>          mov rdi, rax
   205 00000127 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   206                              <1> 
   207 0000012B 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   208 0000012C 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   209 00000133 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   210 00000137 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00               ;添加P=1，TYPE=64位调用门
   211 0000013E 5E                  <1>          pop rsi
   212                              <1> 
   213 0000013F C3                  <1>          ret
   214                              <1> 
   215                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   216                              <1> make_interrupt_gate:                              ;创建64位的中断门
   217                              <1>                                                   ;输入：RAX=例程的线性地址
   218                              <1>                                                   ;输出：RDI:RSI=中断门
   219 00000140 4889C7              <1>          mov rdi, rax
   220 00000143 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   221                              <1> 
   222 00000147 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   223 00000148 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   224 0000014F 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   225 00000153 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00               ;添加P=1，TYPE=64位中断门
   226 0000015A 5E                  <1>          pop rsi
   227                              <1> 
   228 0000015B C3                  <1>          ret
   229                              <1> 
   230                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   231                              <1> make_trap_gate:                                   ;创建64位的陷阱门
   232                              <1>                                                   ;输入：RAX=例程的线性地址
   233                              <1>                                                   ;输出：RDI:RSI=陷阱门
   234 0000015C 4889C7              <1>          mov rdi, rax
   235 0000015F 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   236                              <1> 
   237 00000163 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   238 00000164 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   239 0000016B 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   240 0000016F 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00               ;添加P=1，TYPE=64位陷阱门
   241 00000176 5E                  <1>          pop rsi
   242                              <1> 
   243 00000177 C3                  <1>          ret
   244                              <1> 
   245                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   246                              <1> make_tss_descriptor:                              ;创建64位的TSS描述符
   247                              <1>                                                   ;输入：RAX=TSS的线性地址
   248                              <1>                                                   ;输出：RDI:RSI=TSS描述符
   249 00000178 50                  <1>          push rax
   250                              <1> 
   251 00000179 4889C7              <1>          mov rdi, rax
   252 0000017C 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   253                              <1> 
   254 00000180 50                  <1>          push rax                                 ;先将部分线性地址移到适当位置
   255 00000181 48C1242410          <1>          shl qword [rsp], 16                      ;将线性地址的位23~00移到正确位置
   256 00000186 66C704246800        <1>          mov word [rsp], 104                      ;段界限的标准长度
   257 0000018C 8A442405            <1>          mov al, [rsp + 5]
   258 00000190 88442407            <1>          mov [rsp + 7], al                        ;将线性地址的位31~24移到正确位置
   259 00000194 C644240589          <1>          mov byte [rsp + 5], 0x89                 ;P=1，DPL=00，TYPE=1001（64位TSS）
   260 00000199 C644240600          <1>          mov byte [rsp + 6], 0                    ;G、0、0、AVL和limit
   261 0000019E 5E                  <1>          pop rsi                                  ;门的低64位
   262                              <1> 
   263 0000019F 58                  <1>          pop rax
   264                              <1> 
   265 000001A0 C3                  <1>          ret
   266                              <1> 
   267                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   268                              <1> mount_idt_entry:                                  ;在中断描述符表IDT中安装门描述符
   269                              <1>                                                   ;R8=中断向量
   270                              <1>                                                   ;RDI:RSI=门描述符
   271 000001A1 4150                <1>          push r8
   272 000001A3 4151                <1>          push r9
   273                              <1> 
   274 000001A5 49C1E004            <1>          shl r8, 4                                ;中断号乘以16，得到表内偏移
   275 000001A9 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR                 ;中断描述符表的高端线性地址
   275 000001B2 FF                  <1>
   276 000001B3 4B893401            <1>          mov [r9 + r8], rsi
   277 000001B7 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   278                              <1> 
   279 000001BC 4159                <1>          pop r9
   280 000001BE 4158                <1>          pop r8
   281                              <1> 
   282 000001C0 C3                  <1>          ret
   283                              <1> 
   284                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   285                              <1> init_8259:                                        ;初始化8259中断控制器，包括重新设置向量号
   286 000001C1 50                  <1>          push rax
   287                              <1> 
   288 000001C2 B011                <1>          mov al, 0x11
   289 000001C4 E620                <1>          out 0x20, al                             ;ICW1：边沿触发/级联方式
   290 000001C6 B020                <1>          mov al, 0x20
   291 000001C8 E621                <1>          out 0x21, al                             ;ICW2:起始中断向量（避开前31个异常的向量）
   292 000001CA B004                <1>          mov al, 0x04
   293 000001CC E621                <1>          out 0x21, al                             ;ICW3:从片级联到IR2
   294 000001CE B001                <1>          mov al, 0x01
   295 000001D0 E621                <1>          out 0x21, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   296                              <1> 
   297 000001D2 B011                <1>          mov al, 0x11
   298 000001D4 E6A0                <1>          out 0xa0, al                             ;ICW1：边沿触发/级联方式
   299 000001D6 B028                <1>          mov al, 0x28
   300 000001D8 E6A1                <1>          out 0xa1, al                             ;ICW2:起始中断向量-->0x28
   301 000001DA B002                <1>          mov al, 0x02
   302 000001DC E6A1                <1>          out 0xa1, al                             ;ICW3:从片识别标志，级联到主片IR2
   303 000001DE B001                <1>          mov al, 0x01
   304 000001E0 E6A1                <1>          out 0xa1, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   305                              <1> 
   306 000001E2 58                  <1>          pop rax
   307 000001E3 C3                  <1>          ret
   308                              <1> 
   309                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   310                              <1> read_hard_disk_0:                                 ;从硬盘读取一个逻辑扇区
   311                              <1>                                                   ;RAX=逻辑扇区号
   312                              <1>                                                   ;RBX=目标缓冲区线性地址
   313                              <1>                                                   ;返回：RBX=RBX+512
   314 000001E4 FA                  <1>          cli
   315                              <1> 
   316 000001E5 50                  <1>          push rax
   317 000001E6 51                  <1>          push rcx
   318 000001E7 52                  <1>          push rdx
   319                              <1> 
   320 000001E8 50                  <1>          push rax
   321                              <1> 
   322 000001E9 66BAF201            <1>          mov dx, 0x1f2
   323 000001ED B001                <1>          mov al, 1
   324 000001EF EE                  <1>          out dx, al                               ;读取的扇区数
   325                              <1> 
   326 000001F0 66FFC2              <1>          inc dx                                   ;0x1f3
   327 000001F3 58                  <1>          pop rax
   328 000001F4 EE                  <1>          out dx, al                               ;LBA地址7~0
   329                              <1> 
   330 000001F5 66FFC2              <1>          inc dx                                   ;0x1f4
   331 000001F8 B108                <1>          mov cl, 8
   332 000001FA 48D3E8              <1>          shr rax, cl
   333 000001FD EE                  <1>          out dx, al                               ;LBA地址15~8
   334                              <1> 
   335 000001FE 66FFC2              <1>          inc dx                                   ;0x1f5
   336 00000201 48D3E8              <1>          shr rax, cl
   337 00000204 EE                  <1>          out dx, al                               ;LBA地址23~16
   338                              <1> 
   339 00000205 66FFC2              <1>          inc dx                                   ;0x1f6
   340 00000208 48D3E8              <1>          shr rax, cl
   341 0000020B 0CE0                <1>          or al, 0xe0                              ;第一硬盘  LBA地址27~24
   342 0000020D EE                  <1>          out dx, al
   343                              <1> 
   344 0000020E 66FFC2              <1>          inc dx                                   ;0x1f7
   345 00000211 B020                <1>          mov al, 0x20                             ;读命令
   346 00000213 EE                  <1>          out dx, al
   347                              <1> 
   348                              <1>   .waits:
   349 00000214 EC                  <1>          in al, dx
   350 00000215 2488                <1>          and al, 0x88
   351 00000217 3C08                <1>          cmp al, 0x08
   352 00000219 75F9                <1>          jnz .waits                               ;不忙，且硬盘已准备好数据传输
   353                              <1> 
   354 0000021B B900010000          <1>          mov rcx, 256                             ;总共要读取的字数
   355 00000220 66BAF001            <1>          mov dx, 0x1f0
   356                              <1>   .readw:
   357 00000224 66ED                <1>          in ax, dx
   358 00000226 668903              <1>          mov [rbx], ax
   359 00000229 4883C302            <1>          add rbx, 2
   360 0000022D E2F5                <1>          loop .readw
   361                              <1> 
   362 0000022F 5A                  <1>          pop rdx
   363 00000230 59                  <1>          pop rcx
   364 00000231 58                  <1>          pop rax
   365                              <1> 
   366 00000232 FB                  <1>          sti
   367 00000233 C3                  <1>          ret
   368                              <1> 
   369                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   370 00000234 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          ;对应物理内存的前512个页面（2MB）
   371 00000274 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 ;对应后续的页面
   372                              <1>   _page_map_len  equ $ - _page_bit_map
   373                              <1> 
   374                              <1> allocate_a_4k_page:                               ;分配一个4KB的页
   375                              <1>                                                   ;输入：无
   376                              <1>                                                   ;输出：RAX=页的物理地址
   377 00000634 4831C0              <1>          xor rax, rax
   378                              <1>   .b1:
   379 00000637 480FAB05F5FBFFFF    <1>          bts [rel _page_bit_map], rax
   380 0000063F 730B                <1>          jnc .b2
   381 00000641 48FFC0              <1>          inc rax
   382 00000644 483D00200000        <1>          cmp rax, _page_map_len * 8               ;立即数符号扩展到64位进行比较
   383 0000064A 7CEB                <1>          jl .b1
   384                              <1> 
   385                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的
   386                              <1>          ;系统来说，如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注
   387                              <1>          ;销的页面，或者执行页面的换入和换出。
   388                              <1> 
   389                              <1>   .b2:
   390 0000064C 48C1E00C            <1>          shl rax, 12                              ;乘以4096（0x1000）
   391                              <1> 
   392 00000650 C3                  <1>          ret
   393                              <1> 
   394                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   395                              <1> lin_to_lin_of_pml4e:                              ;返回指定的线性地址所对应的4级头表项的线性地址
   396                              <1>                                                   ;输入：R13=线性地址
   397                              <1>                                                   ;输出：R14=对应的4级头表项的线性地址
   398 00000651 4155                <1>          push r13
   399                              <1> 
   400 00000653 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000           ;保留4级头表索引部分
   400 0000065C 00                  <1>
   401 0000065D 4D21F5              <1>          and r13, r14
   402 00000660 49C1ED24            <1>          shr r13, 36                              ;原4级头表索引变成页内偏移
   403                              <1> 
   404 00000664 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000           ;访问4级头表所用的地址前缀
   405 0000066B 4D01EE              <1>          add r14, r13
   406                              <1> 
   407 0000066E 415D                <1>          pop r13
   408                              <1> 
   409 00000670 C3                  <1>          ret
   410                              <1> 
   411                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   412                              <1> lin_to_lin_of_pdpte:                              ;返回指定的线性地址所对应的页目录指针项的线性地址
   413                              <1>                                                   ;输入：R13=线性地址
   414                              <1>                                                   ;输出：R14=对应的页目录指针项的线性地址
   415 00000671 4155                <1>          push r13
   416                              <1> 
   417 00000673 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000           ;保留4级头表索引和页目录指针表索引部分
   417 0000067C 00                  <1>
   418 0000067D 4D21F5              <1>          and r13, r14
   419 00000680 49C1ED1B            <1>          shr r13, 27                              ;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   420                              <1> 
   421 00000684 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000           ;访问页目录指针表所用的地址前缀
   422 0000068B 4D01EE              <1>          add r14, r13
   423                              <1> 
   424 0000068E 415D                <1>          pop r13
   425                              <1> 
   426 00000690 C3                  <1>          ret
   427                              <1> 
   428                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   429                              <1> lin_to_lin_of_pdte:                               ;返回指定的线性地址所对应的页目录项的线性地址
   430                              <1>                                                   ;输入：R13=线性地址
   431                              <1>                                                   ;输出：R14=对应的页目录项的线性地址
   432 00000691 4155                <1>          push r13
   433                              <1> 
   434 00000693 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000           ;保留4级头表索引、页目录指针表索引和页目录表索引部分
   434 0000069C 00                  <1>
   435 0000069D 4D21F5              <1>          and r13, r14
   436 000006A0 49C1ED12            <1>          shr r13, 18                              ;原4级头表索引变成页目录表索引，原页目录指针表索引变
   437                              <1>                                                   ;页表索引，原页目录表索引变页内偏移
   438 000006A4 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000           ;访问页目录表所用的地址前缀
   439 000006AB 4D01EE              <1>          add r14, r13
   440                              <1> 
   441 000006AE 415D                <1>          pop r13
   442                              <1> 
   443 000006B0 C3                  <1>          ret
   444                              <1> 
   445                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   446                              <1> lin_to_lin_of_pte:                                ;返回指定的线性地址所对应的页表项的线性地址
   447                              <1>                                                   ;输入：R13=线性地址
   448                              <1>                                                   ;输出：R14=对应的页表项的线性地址
   449 000006B1 4155                <1>          push r13
   450                              <1> 
   451 000006B3 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000           ;保留4级头表、页目录指针表、页目录表和页表的索引部分
   451 000006BC 00                  <1>
   452 000006BD 4D21F5              <1>          and r13, r14
   453 000006C0 49C1ED09            <1>          shr r13, 9                               ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   454                              <1>                                                   ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   455 000006C4 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000           ;访问页表所用的地址前缀
   455 000006CD FF                  <1>
   456 000006CE 4D01EE              <1>          add r14, r13
   457                              <1> 
   458 000006D1 415D                <1>          pop r13
   459                              <1> 
   460 000006D3 C3                  <1>          ret
   461                              <1> 
   462                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   463                              <1> setup_paging_for_laddr:                           ;为指定的线性地址安装分页系统（表项）
   464                              <1>                                                   ;输入：R13=线性地址
   465 000006D4 50                  <1>          push rax
   466 000006D5 4156                <1>          push r14
   467                              <1> 
   468                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   469                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   470 000006D7 E875FFFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   471 000006DC 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   472 000006E3 752B                <1>          jnz .b0
   473                              <1> 
   474                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   475 000006E5 E84AFFFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   476 000006EA 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   477 000006EE 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   478                              <1> 
   479                              <1>          ;清空刚分配的页目录指针表
   480 000006F1 E87BFFFFFF          <1>          call lin_to_lin_of_pdpte
   481 000006F6 49C1EE0C            <1>          shr r14, 12
   482 000006FA 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   483 000006FE B900020000          <1>          mov rcx, 512
   484                              <1>   .cls0:
   485 00000703 49C70600000000      <1>          mov qword [r14], 0
   486 0000070A 4983C608            <1>          add r14, 8
   487 0000070E E2F3                <1>          loop .cls0
   488                              <1> ;-------------------------------------------------
   489                              <1>   .b0:
   490                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   491 00000710 E85CFFFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   492 00000715 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   493 0000071C 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   494                              <1> 
   495                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   496 0000071E E811FFFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   497 00000723 4883C807            <1>          or rax, 0x07                             ;添加属性位
   498 00000727 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   499                              <1> 
   500                              <1>          ;清空刚分配的页目录表
   501 0000072A E862FFFFFF          <1>          call lin_to_lin_of_pdte
   502 0000072F 49C1EE0C            <1>          shr r14, 12
   503 00000733 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   504 00000737 B900020000          <1>          mov rcx, 512
   505                              <1>   .cls1:
   506 0000073C 49C70600000000      <1>          mov qword [r14], 0
   507 00000743 4983C608            <1>          add r14, 8
   508 00000747 E2F3                <1>          loop .cls1
   509                              <1> ;-------------------------------------------------
   510                              <1>   .b1:
   511                              <1>          ;检查该线性地址所对应的页目录项是否存在
   512 00000749 E843FFFFFF          <1>          call lin_to_lin_of_pdte
   513 0000074E 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   514 00000755 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   515                              <1> 
   516                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   517 00000757 E8D8FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   518 0000075C 4883C807            <1>          or rax, 0x07                             ;添加属性位
   519 00000760 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   520                              <1> 
   521                              <1>          ;清空刚分配的页表
   522 00000763 E849FFFFFF          <1>          call lin_to_lin_of_pte
   523 00000768 49C1EE0C            <1>          shr r14, 12
   524 0000076C 49C1E60C            <1>          shl r14, 12                             ;得到页表的线性地址
   525 00000770 B900020000          <1>          mov rcx, 512
   526                              <1>   .cls2:
   527 00000775 49C70600000000      <1>          mov qword [r14], 0
   528 0000077C 4983C608            <1>          add r14, 8
   529 00000780 E2F3                <1>          loop .cls2
   530                              <1> ;-------------------------------------------------
   531                              <1>   .b2:
   532                              <1>          ;检查该线性地址所对应的页表项是否存在
   533 00000782 E82AFFFFFF          <1>          call lin_to_lin_of_pte
   534 00000787 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   535 0000078E 750C                <1>          jnz .b3                                  ;页表项已经存在，转.b3
   536                              <1> 
   537                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   538 00000790 E89FFEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页
   539 00000795 4883C807            <1>          or rax, 0x07                             ;添加属性位
   540 00000799 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   541                              <1> 
   542                              <1>   .b3:
   543 0000079C 415E                <1>          pop r14
   544 0000079E 58                  <1>          pop rax
   545                              <1> 
   546 0000079F C3                  <1>          ret
   547                              <1> 
   548                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   549                              <1> mapping_laddr_to_page:                            ;建立线性地址到物理页的映射
   550                              <1>                                                   ;即，为指定的线性地址安装指定的物理页
   551                              <1>                                                   ;输入：R13=线性地址
   552                              <1>                                                   ;      RAX=页的物理地址（含属性）
   553 000007A0 4156                <1>          push r14
   554 000007A2 50                  <1>          push rax
   555                              <1> 
   556                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   557                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   558 000007A3 E8A9FEFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   559 000007A8 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   560 000007AF 752B                <1>          jnz .b0
   561                              <1> 
   562                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   563 000007B1 E87EFEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   564 000007B6 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   565 000007BA 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   566                              <1> 
   567                              <1>          ;清空刚分配的页目录指针表
   568 000007BD E8AFFEFFFF          <1>          call lin_to_lin_of_pdpte
   569 000007C2 49C1EE0C            <1>          shr r14, 12
   570 000007C6 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   571 000007CA B900020000          <1>          mov rcx, 512
   572                              <1>   .cls0:
   573 000007CF 49C70600000000      <1>          mov qword [r14], 0
   574 000007D6 4983C608            <1>          add r14, 8
   575 000007DA E2F3                <1>          loop .cls0
   576                              <1> ;-------------------------------------------------
   577                              <1>   .b0:
   578                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   579 000007DC E890FEFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   580 000007E1 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   581 000007E8 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   582                              <1> 
   583                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   584 000007EA E845FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   585 000007EF 4883C807            <1>          or rax, 0x07                             ;添加属性位
   586 000007F3 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   587                              <1> 
   588                              <1>          ;清空刚分配的页目录表
   589 000007F6 E896FEFFFF          <1>          call lin_to_lin_of_pdte
   590 000007FB 49C1EE0C            <1>          shr r14, 12
   591 000007FF 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   592 00000803 B900020000          <1>          mov rcx, 512
   593                              <1>   .cls1:
   594 00000808 49C70600000000      <1>          mov qword [r14], 0
   595 0000080F 4983C608            <1>          add r14, 8
   596 00000813 E2F3                <1>          loop .cls1
   597                              <1> ;-------------------------------------------------
   598                              <1>   .b1:
   599                              <1>          ;检查该线性地址所对应的页目录项是否存在
   600 00000815 E877FEFFFF          <1>          call lin_to_lin_of_pdte
   601 0000081A 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   602 00000821 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   603                              <1> 
   604                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   605 00000823 E80CFEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   606 00000828 4883C807            <1>          or rax, 0x07                             ;添加属性位
   607 0000082C 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   608                              <1> 
   609                              <1>          ;清空刚分配的页表
   610 0000082F E87DFEFFFF          <1>          call lin_to_lin_of_pte
   611 00000834 49C1EE0C            <1>          shr r14, 12
   612 00000838 49C1E60C            <1>          shl r14, 12                              ;得到页表的线性地址
   613 0000083C B900020000          <1>          mov rcx, 512
   614                              <1>   .cls2:
   615 00000841 49C70600000000      <1>          mov qword [r14], 0
   616 00000848 4983C608            <1>          add r14, 8
   617 0000084C E2F3                <1>          loop .cls2
   618                              <1> ;-------------------------------------------------
   619                              <1>   .b2:
   620 0000084E E85EFEFFFF          <1>          call lin_to_lin_of_pte                   ;得到页表项的线性地址
   621 00000853 58                  <1>          pop rax
   622 00000854 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   623                              <1> 
   624 00000857 415E                <1>          pop r14
   625                              <1> 
   626 00000859 C3                  <1>          ret
   627                              <1> 
   628                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   629 0000085A 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START          ;下一次分配时可用的起始线性地址
   630                              <1> 
   631                              <1> core_memory_allocate:                             ;在虚拟地址空间的高端（内核）分配内存
   632                              <1>                                                   ;输入：RCX=请求分配的字节数
   633                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   634                              <1>                                                   ;      R14=下次分配的起始线性地址
   635 00000862 4C8B2DF1FFFFFF      <1>          mov r13, [rel _core_next_linear]         ;获得本次分配的起始线性地址
   636 00000869 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   637                              <1> 
   638 0000086E 49F7C607000000      <1>          test r14, 0x07                           ;最低3位是000吗（是否按8字节对齐）？
   639 00000875 740C                <1>          jz .algn
   640 00000877 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   641 0000087B 49C1EE03            <1>          shr r14, 3
   642 0000087F 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   643                              <1> 
   644                              <1>   .algn:
   645 00000883 4C8935D0FFFFFF      <1>          mov [rel _core_next_linear], r14         ;写回。
   646                              <1> 
   647 0000088A 4155                <1>          push r13
   648 0000088C 4156                <1>          push r14
   649                              <1> 
   650                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   651 0000088E 49C1ED0C            <1>          shr r13, 12
   652 00000892 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   653 00000896 49C1EE0C            <1>          shr r14, 12
   654 0000089A 49C1E60C            <1>          shl r14, 12                              ;too
   655                              <1>   .next:
   656 0000089E E831FEFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   657 000008A3 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   658 000008AA 4D39F5              <1>          cmp r13, r14
   659 000008AD 7EEF                <1>          jle .next
   660                              <1> 
   661 000008AF 415E                <1>          pop r14
   662 000008B1 415D                <1>          pop r13
   663                              <1> 
   664 000008B3 C3                  <1>          ret
   665                              <1> 
   666                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   667                              <1> user_memory_allocate:                             ;在用户任务的私有空间（低端）分配内存
   668                              <1>                                                   ;输入：R11=任务控制块PCB的线性地址
   669                              <1>                                                   ;      RCX=希望分配的字节数
   670                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   671                              <1>                                                   ;      R14=下次分配的起始线性地址
   672                              <1>          ;获得本次内存分配的起始线性地址
   673 000008B4 4D8B6B18            <1>          mov r13, [r11 + 24]                      ;获得本次分配的起始线性地址
   674 000008B8 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   675                              <1> 
   676 000008BD 49F7C607000000      <1>          test r14, 0x07                           ;能够被8整除吗（是否按8字节对齐）？
   677 000008C4 740C                <1>          jz .algn
   678 000008C6 49C1EE03            <1>          shr r14, 3
   679 000008CA 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   680 000008CE 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   681                              <1> 
   682                              <1>   .algn:
   683 000008D2 4D897318            <1>          mov [r11 + 24], r14                      ;写回PCB中。
   684                              <1> 
   685 000008D6 4155                <1>          push r13
   686 000008D8 4156                <1>          push r14
   687                              <1> 
   688                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   689 000008DA 49C1ED0C            <1>          shr r13, 12
   690 000008DE 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   691 000008E2 49C1EE0C            <1>          shr r14, 12
   692 000008E6 49C1E60C            <1>          shl r14, 12                              ;too
   693                              <1>   .next:
   694 000008EA E8E5FDFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   695 000008EF 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   696 000008F6 4D39F5              <1>          cmp r13, r14
   697 000008F9 7EEF                <1>          jle .next
   698                              <1> 
   699 000008FB 415E                <1>          pop r14
   700 000008FD 415D                <1>          pop r13
   701                              <1> 
   702 000008FF C3                  <1>          ret
   703                              <1> 
   704                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   705                              <1> copy_current_pml4:                                ;创建新的4级头表，并复制当前4级头表的内容
   706                              <1>                                                   ;输入：无
   707                              <1>                                                   ;输出：RAX=新4级头表的物理地址及属性
   708 00000900 56                  <1>          push rsi
   709 00000901 57                  <1>          push rdi
   710 00000902 4155                <1>          push r13
   711 00000904 51                  <1>          push rcx
   712                              <1> 
   713 00000905 E82AFDFFFF          <1>          call allocate_a_4k_page                  ;分配一个物理页
   714 0000090A 4883C807            <1>          or rax, 0x07                             ;立即数符号扩展到64位参与操作
   715 0000090E 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR                 ;用指定的线性地址映射和访问这个页
   715 00000917 FF                  <1>
   716 00000918 E883FEFFFF          <1>          call mapping_laddr_to_page
   717                              <1> 
   718                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   719 0000091D 410F017D00          <1>          invlpg [r13]
   720                              <1> 
   721 00000922 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000           ;RSI->当前活动4级头表的线性地址
   722 00000929 4C89EF              <1>          mov rdi, r13                             ;RDI->新4级头表的线性地址
   723 0000092C B900020000          <1>          mov rcx, 512                             ;RCX=要复制的目录项数
   724 00000931 FC                  <1>          cld
   725 00000932 F348A5              <1>          repe movsq
   726                              <1> 
   727 00000935 498985F80F0000      <1>          mov [r13 + 0xff8], rax                   ;新4级头表的511号表项指向它自己
   728 0000093C 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   729                              <1> 
   730 00000944 59                  <1>          pop rcx
   731 00000945 415D                <1>          pop r13
   732 00000947 5F                  <1>          pop rdi
   733 00000948 5E                  <1>          pop rsi
   734                              <1> 
   735 00000949 C3                  <1>          ret
   736                              <1> 
   737                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   738 0000094A 0000                <1> _gdt_info dw 0
   739 0000094C 0000000000000000    <1>           dq 0
   740                              <1> 
   741                              <1> append_segd_to_gdt:                               ;在GDT中添加段描述符
   742                              <1>                                                   ;输入：RSI=段描述符
   743                              <1>                                                   ;输出：CX=段描述符选择子
   744 00000954 4150                <1>          push r8
   745                              <1> 
   746 00000956 0F0105EDFFFFFF      <1>          sgdt [rel _gdt_info]
   747                              <1> 
   748 0000095D 4C8B05E8FFFFFF      <1>          mov r8, [rel _gdt_info + 2]
   749 00000964 480FB70DDEFFFFFF    <1>          movzx rcx, word [rel _gdt_info]
   750 0000096C 4989740801          <1>          mov [r8 + rcx + 1], rsi
   751                              <1> 
   752 00000971 4883C108            <1>          add rcx, 8
   753 00000975 66890DCEFFFFFF      <1>          mov [rel _gdt_info], cx
   754                              <1> 
   755 0000097C 0F0115C7FFFFFF      <1>          lgdt [rel _gdt_info]
   756                              <1> 
   757 00000983 66C1E903            <1>          shr cx, 3                                ;除以8（消除余数）
   758 00000987 66C1E103            <1>          shl cx, 3                                ;将索引号移到正确位置
   759                              <1>          ;and cx, 0xfff8
   760 0000098B 4158                <1>          pop r8
   761                              <1> 
   762 0000098D C3                  <1>          ret
   763                              <1> 
   764                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   765                              <1> get_cmos_time:                                    ;从CMOS中获取当前时间
   766                              <1>                                                   ;输入：RBX=缓冲区线性地址
   767 0000098E 50                  <1>          push rax
   768                              <1> 
   769                              <1>   .w0:
   770 0000098F B08A                <1>          mov al, 0x8a
   771 00000991 E670                <1>          out 0x70, al
   772 00000993 E471                <1>          in al, 0x71                              ;读寄存器A
   773 00000995 A880                <1>          test al, 0x80                            ;测试第7位UIP，等待更新周期结束。
   774 00000997 75F6                <1>          jnz .w0
   775                              <1> 
   776 00000999 B084                <1>          mov al, 0x84
   777 0000099B E670                <1>          out 0x70, al
   778 0000099D E471                <1>          in al, 0x71                              ;读RTC当前时间(时)
   779 0000099F 88C4                <1>          mov ah, al
   780                              <1> 
   781 000009A1 C0EC04              <1>          shr ah, 4
   782 000009A4 80E40F              <1>          and ah, 0x0f
   783 000009A7 80C430              <1>          add ah, 0x30
   784 000009AA 8823                <1>          mov [rbx], ah
   785                              <1> 
   786 000009AC 240F                <1>          and al, 0x0f
   787 000009AE 0430                <1>          add al, 0x30
   788 000009B0 884301              <1>          mov [rbx + 1], al
   789                              <1> 
   790 000009B3 C643023A            <1>          mov byte [rbx + 2], ':'
   791                              <1> 
   792 000009B7 B082                <1>          mov al, 0x82
   793 000009B9 E670                <1>          out 0x70, al
   794 000009BB E471                <1>          in al, 0x71                              ;读RTC当前时间(分)
   795 000009BD 88C4                <1>          mov ah, al
   796                              <1> 
   797 000009BF C0EC04              <1>          shr ah, 4
   798 000009C2 80E40F              <1>          and ah, 0x0f
   799 000009C5 80C430              <1>          add ah, 0x30
   800 000009C8 886303              <1>          mov [rbx + 3], ah
   801                              <1> 
   802 000009CB 240F                <1>          and al, 0x0f
   803 000009CD 0430                <1>          add al, 0x30
   804 000009CF 884304              <1>          mov [rbx + 4], al
   805                              <1> 
   806 000009D2 C643053A            <1>          mov byte [rbx + 5], ':'
   807                              <1> 
   808 000009D6 B080                <1>          mov al, 0x80
   809 000009D8 E670                <1>          out 0x70, al
   810 000009DA E471                <1>          in al, 0x71                              ;读RTC当前时间(秒)
   811 000009DC 88C4                <1>          mov ah, al                               ;分拆成两个数字
   812                              <1> 
   813 000009DE C0EC04              <1>          shr ah, 4                                ;逻辑右移4位
   814 000009E1 80E40F              <1>          and ah, 0x0f
   815 000009E4 80C430              <1>          add ah, 0x30
   816 000009E7 886306              <1>          mov [rbx + 6], ah
   817                              <1> 
   818 000009EA 240F                <1>          and al, 0x0f                             ;仅保留低4位
   819 000009EC 0430                <1>          add al, 0x30                             ;转换成ASCII
   820 000009EE 884307              <1>          mov [rbx + 7], al
   821                              <1> 
   822 000009F1 C6430800            <1>          mov byte [rbx + 8], 0                    ;空字符终止
   823                              <1> 
   824 000009F5 58                  <1>          pop rax
   825                              <1> 
   826 000009F6 C3                  <1>          ret
   827                              <1> 
   828                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   829 000009F7 0000000000000000    <1>   _process_id dq 0
   830                              <1> 
   831                              <1> generate_process_id:                              ;生成唯一的进程标识
   832                              <1>                                                   ;返回：RAX=进程标识
   833 000009FF FA                  <1>          cli
   834 00000A00 488B05F0FFFFFF      <1>          mov rax, [rel _process_id]
   835 00000A07 48FF05E9FFFFFF      <1>          inc qword [rel _process_id]
   836 00000A0E FB                  <1>          sti
   837 00000A0F C3                  <1>          ret
   838                              <1> 
   839                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   840                              <1> ;  _thread_id dq 0
   841                              <1> 
   842                              <1> ;generate_thread_id:                               ;生成唯一的线程标识
   843                              <1>                                                   ;返回：RAX=线程标识
   844                              <1> ;         mov rax, [rel _thread_id]
   845                              <1> ;         inc qword [rel _thread_id]
   846                              <1> ;         ret
   847                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   848 00000A10 08                  <1>   _screen_row db 8
   849                              <1> 
   850                              <1> get_screen_row:                                   ;返回下一个屏幕坐标行的行号
   851                              <1>                                                   ;返回：DH=行号
   852 00000A11 FA                  <1>          cli
   853 00000A12 8A35F8FFFFFF        <1>          mov dh, [rel _screen_row]
   854 00000A18 FE05F2FFFFFF        <1>          inc byte [rel _screen_row]
   855 00000A1E FB                  <1>          sti
   856 00000A1F C3                  <1>          ret
   857                              <1> 
   858                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   859                              <1> 
    28                                  
    29                                           bits 64
    30                                  
    31                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    32                                  general_interrupt_handler:                        ;通用中断处理过程
    33 00000A20 48CF                             iretq
    34                                  
    35                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    36                                  general_exception_handler:                        ;通用异常处理过程
    37                                                                                    ;在24行0列显示红底白字的错误信息
    38 00000A22 4C8B3D(08000000)                 mov r15, [rel position]
    39 00000A29 498D9F[3E0A0000]                 lea rbx, [r15 + exceptm]
    40 00000A30 B618                             mov dh, 24
    41 00000A32 B200                             mov dl, 0
    42 00000A34 41B14F                           mov r9b, 0x4f
    43 00000A37 E8A1F6FFFF                       call put_cstringxy64                     ;位于core_utils64.wid
    44                                  
    45 00000A3C FA                               cli
    46 00000A3D F4                               hlt                                      ;停机且不接受外部硬件中断
    47                                  
    48 00000A3E 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
    48 00000A47 6F6E20726169736564-
    48 00000A50 2C68616C742E00     
    49                                  
    50                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    51                                  general_8259ints_handler:                         ;通用的8259中断处理过程
    52 00000A57 50                               push rax
    53                                  
    54 00000A58 B020                             mov al, 0x20                             ;中断结束命令EOI
    55 00000A5A E6A0                             out 0xa0, al                             ;向从片发送
    56 00000A5C E620                             out 0x20, al                             ;向主片发送
    57                                  
    58 00000A5E 58                               pop rax
    59                                  
    60 00000A5F 48CF                             iretq
    61                                  
    62                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    63                                  rtm_interrupt_handle:                             ;实时时钟中断处理过程（任务切换）
    64 00000A61 4150                             push r8
    65 00000A63 50                               push rax
    66 00000A64 53                               push rbx
    67                                  
    68 00000A65 B020                             mov al, 0x20                             ;中断结束命令EOI
    69 00000A67 E6A0                             out 0xa0, al                             ;向8259A从片发送
    70 00000A69 E620                             out 0x20, al                             ;向8259A主片发送
    71                                  
    72 00000A6B B00C                             mov al, 0x0c                             ;寄存器C的索引。且开放NMI
    73 00000A6D E670                             out 0x70, al
    74 00000A6F E471                             in al, 0x71                              ;读一下RTC的寄存器C，否则只发生一次中断
    75                                                                                    ;此处不考虑闹钟和周期性中断的情况
    76                                           ;以下开始执行任务切换
    77                                           ;任务切换的原理是，它发生在所有任务的全局空间。在任务A的全局空间执行任务
    78                                           ;切换，切换到任务B，实际上也是从任务B的全局空间返回任务B的私有空间。
    79                                  
    80                                           ;从PCB链表中寻找就绪的任务。
    81 00000A71 4C8B05(5C000000)                 mov r8, [rel cur_pcb]                    ;定位到当前任务的PCB节点
    82                                    .again:
    83 00000A78 4D8B8018010000                   mov r8, [r8 + 280]                       ;取得下一个节点
    84 00000A7F 4C3B05(5C000000)                 cmp r8, [rel cur_pcb]                    ;是否转一圈回到当前节点？
    85 00000A86 0F842F010000                     jz .return                               ;是。未找到就绪任务（节点），返回
    86 00000A8C 4983781000                       cmp qword [r8 + 16], 0                   ;是就绪任务（节点）？
    87 00000A91 7402                             jz .found                                ;是。转任务切换
    88 00000A93 EBE3                             jmp .again
    89                                  
    90                                    .found:
    91 00000A95 488B05(5C000000)                 mov rax, [rel cur_pcb]                   ;取得当前任务的PCB（线性地址）
    92 00000A9C 4883781002                       cmp qword [rax + 16], 2                  ;当前任务有可能已经被标记为终止。
    93 00000AA1 7479                             jz .restore
    94                                  
    95                                           ;保存当前任务的状态以便将来恢复执行
    96 00000AA3 48C7401000000000                 mov qword [rax + 16], 0                  ;置任务状态为就绪
    97                                           ;mov [rax + 64], rax                     ;不需设置，将来恢复执行时从栈中弹出
    98                                           ;mov [rax + 72], rbx                     ;不需设置，将来恢复执行时从栈中弹出
    99 00000AAB 48894850                         mov [rax + 80], rcx
   100 00000AAF 48895058                         mov [rax + 88], rdx
   101 00000AB3 48897060                         mov [rax + 96], rsi
   102 00000AB7 48897868                         mov [rax + 104], rdi
   103 00000ABB 48896870                         mov [rax + 112], rbp
   104 00000ABF 48896078                         mov [rax + 120], rsp
   105                                           ;mov [rax + 128], r8                     ;不需设置，将来恢复执行时从栈中弹出
   106 00000AC3 4C898888000000                   mov [rax + 136], r9
   107 00000ACA 4C899090000000                   mov [rax + 144], r10
   108 00000AD1 4C899898000000                   mov [rax + 152], r11
   109 00000AD8 4C89A0A0000000                   mov [rax + 160], r12
   110 00000ADF 4C89A8A8000000                   mov [rax + 168], r13
   111 00000AE6 4C89B0B0000000                   mov [rax + 176], r14
   112 00000AED 4C89B8B8000000                   mov [rax + 184], r15
   113 00000AF4 488B1D(08000000)                 mov rbx, [rel position]
   114 00000AFB 488D9B[BB0B0000]                 lea rbx, [rbx + .return]
   115 00000B02 488998C0000000                   mov [rax + 192], rbx                     ;RIP为中断返回点
   116 00000B09 8C88C8000000                     mov [rax + 200], cs
   117 00000B0F 8C90D0000000                     mov [rax + 208], ss
   118 00000B15 9C                               pushfq
   119 00000B16 8F80E8000000                     pop qword [rax + 232]
   120                                  
   121                                    .restore:
   122                                           ;恢复新任务的状态
   123 00000B1C 4C8905(5C000000)                 mov [rel cur_pcb], r8                    ;将新任务设置为当前任务
   124 00000B23 49C7401001000000                 mov qword [r8 + 16], 1                   ;置任务状态为忙
   125                                  
   126 00000B2B 498B4020                         mov rax, [r8 + 32]                       ;取PCB中的RSP0
   127 00000B2F 488B1D(1C000000)                 mov rbx, [rel tss_ptr]
   128 00000B36 48894304                         mov [rbx + 4], rax                       ;置TSS的RSP0
   129                                  
   130 00000B3A 498B4038                         mov rax, [r8 + 56]
   131 00000B3E 0F22D8                           mov cr3, rax                             ;切换地址空间
   132                                  
   133 00000B41 498B4040                         mov rax, [r8 + 64]
   134 00000B45 498B5848                         mov rbx, [r8 + 72]
   135 00000B49 498B4850                         mov rcx, [r8 + 80]
   136 00000B4D 498B5058                         mov rdx, [r8 + 88]
   137 00000B51 498B7060                         mov rsi, [r8 + 96]
   138 00000B55 498B7868                         mov rdi, [r8 + 104]
   139 00000B59 498B6870                         mov rbp, [r8 + 112]
   140 00000B5D 498B6078                         mov rsp, [r8 + 120]
   141 00000B61 4D8B8888000000                   mov r9, [r8 + 136]
   142 00000B68 4D8B9090000000                   mov r10, [r8 + 144]
   143 00000B6F 4D8B9898000000                   mov r11, [r8 + 152]
   144 00000B76 4D8BA0A0000000                   mov r12, [r8 + 160]
   145 00000B7D 4D8BA8A8000000                   mov r13, [r8 + 168]
   146 00000B84 4D8BB0B0000000                   mov r14, [r8 + 176]
   147 00000B8B 4D8BB8B8000000                   mov r15, [r8 + 184]
   148 00000B92 41FFB0D0000000                   push qword [r8 + 208]                    ;SS
   149 00000B99 41FF7078                         push qword [r8 + 120]                    ;RSP
   150 00000B9D 41FFB0E8000000                   push qword [r8 + 232]                    ;RFLAGS
   151 00000BA4 41FFB0C8000000                   push qword [r8 + 200]                    ;CS
   152 00000BAB 41FFB0C0000000                   push qword [r8 + 192]                    ;RIP
   153                                  
   154 00000BB2 4D8B8080000000                   mov r8, [r8 + 128]                       ;恢复R8的值
   155                                  
   156 00000BB9 48CF                             iretq                                    ;转入新任务局部空间执行
   157                                  
   158                                    .return:
   159 00000BBB 5B                               pop rbx
   160 00000BBC 58                               pop rax
   161 00000BBD 4158                             pop r8
   162                                  
   163 00000BBF 48CF                             iretq
   164                                  
   165                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   166                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   167                                                                                    ;输入：R11=PCB线性基地址
   168 00000BC1 50                               push rax
   169 00000BC2 53                               push rbx
   170                                  
   171 00000BC3 FA                               cli
   172                                  
   173 00000BC4 488B1D(54000000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   174 00000BCB 4809DB                           or rbx, rbx
   175 00000BCE 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   176 00000BD0 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   177 00000BD3 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   178 00000BDA 4C891D(54000000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   179 00000BE1 EB17                             jmp .return
   180                                  
   181                                    .not_empty:
   182 00000BE3 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   183                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   184 00000BE6 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   185 00000BED 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   186 00000BF4 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   187 00000BF7 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   188                                  
   189                                    .return:
   190 00000BFA FB                               sti
   191                                  
   192 00000BFB 5B                               pop rbx
   193 00000BFC 58                               pop rax
   194                                  
   195 00000BFD C3                               ret
   196                                  
   197                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   198                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   199 00000BFE 488B05(5C000000)                 mov rax, [rel cur_pcb]
   200 00000C05 488B4008                         mov rax, [rax + 8]
   201                                  
   202 00000C09 C3                               ret
   203                                  
   204                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   205                                  terminate_process:                                ;终止当前任务
   206 00000C0A FA                               cli                                      ;执行流改变期间禁止时钟中断引发的任务切换
   207                                  
   208 00000C0B 488B05(5C000000)                 mov rax, [rel cur_pcb]                   ;定位到当前任务的PCB节点
   209 00000C12 48C7401002000000                 mov qword [rax + 16], 2                  ;状态=终止
   210                                  
   211 00000C1A E942FEFFFF                       jmp rtm_interrupt_handle                 ;强制任务调度，交还处理器控制权
   212                                  
   213                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   214                                  create_process:                                   ;创建新的任务
   215                                                                                    ;输入：R8=程序的起始逻辑扇区号
   216 00000C1F 50                               push rax
   217 00000C20 53                               push rbx
   218 00000C21 51                               push rcx
   219 00000C22 52                               push rdx
   220 00000C23 56                               push rsi
   221 00000C24 57                               push rdi
   222 00000C25 55                               push rbp
   223 00000C26 4150                             push r8
   224 00000C28 4151                             push r9
   225 00000C2A 4152                             push r10
   226 00000C2C 4153                             push r11
   227 00000C2E 4154                             push r12
   228 00000C30 4155                             push r13
   229 00000C32 4156                             push r14
   230 00000C34 4157                             push r15
   231                                  
   232                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   233 00000C36 B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   234 00000C3B E822FCFFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   235                                  
   236 00000C40 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   237                                  
   238 00000C43 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   239                                  
   240                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   241 00000C4B E8B0FCFFFF                       call copy_current_pml4
   242 00000C50 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   243                                  
   244                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
   245                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
   246                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈位于地址空间高端的栈。
   247 00000C54 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   248 00000C58 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   249                                  
   250                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   251 00000C5B 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   252 00000C62 B900010000                       mov rcx, 256
   253                                    .clsp:
   254 00000C67 48C70000000000                   mov qword [rax], 0
   255 00000C6E 4883C008                         add rax, 8
   256 00000C72 E2F3                             loop .clsp
   257                                  
   258 00000C74 0F20D8                           mov rax, cr3                             ;刷新TLB
   259 00000C77 0F22D8                           mov cr3, rax
   260                                  
   261 00000C7A B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   262 00000C7F E8DEFBFFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   263 00000C84 4D897320                         mov [r11 + 32], r14                      ;填写PCB中的RSP0域的值
   264                                  
   265 00000C88 B900000100                       mov rcx, 4096 * 16                       ;为用户程序开辟栈空间
   266 00000C8D E822FCFFFF                       call user_memory_allocate
   267 00000C92 4D897378                         mov [r11 + 120], r14                     ;用户程序执行时的RSP。
   268                                  
   269 00000C96 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=就绪
   270                                  
   271                                           ;以下开始加载用户程序
   272 00000C9E B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   273 00000CA3 E80CFCFFFF                       call user_memory_allocate
   274 00000CA8 4C89EB                           mov rbx, r13
   275 00000CAB 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   276 00000CAE E831F5FFFF                       call read_hard_disk_0
   277                                  
   278 00000CB3 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   279 00000CB7 4D89EE                           mov r14, r13
   280 00000CBA 4D037508                         add r14, [r13 + 8]
   281 00000CBE 4D89B3C0000000                   mov [r11 + 192], r14                     ;在PCB中登记程序的入口点线性地址
   282                                  
   283                                           ;以下判断整个程序有多大
   284 00000CC5 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   285 00000CC9 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   286 00000CD0 740F                             jz .y512
   287 00000CD2 48C1E909                         shr rcx, 9                               ;不能？凑整。
   288 00000CD6 48C1E109                         shl rcx, 9
   289 00000CDA 4881C100020000                   add rcx, 512
   290                                    .y512:
   291 00000CE1 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   292 00000CE8 7416                             jz .rdok
   293 00000CEA E8C5FBFFFF                       call user_memory_allocate
   294                                           ;mov rbx, r13
   295 00000CEF 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   296 00000CF3 48FFC0                           inc rax                                  ;起始扇区号
   297                                    .b1:
   298 00000CF6 E8E9F4FFFF                       call read_hard_disk_0
   299 00000CFB 48FFC0                           inc rax
   300 00000CFE E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   301                                  
   302                                    .rdok:
   303 00000D00 49C783C80000003B00-              mov qword [r11 + 200], USER_CODE64_SEL   ;新任务的代码段选择子
   303 00000D09 0000               
   304 00000D0B 49C783D00000003300-              mov qword [r11 + 208], USER_STACK64_SEL  ;新任务的栈段选择子
   304 00000D14 0000               
   305                                  
   306 00000D16 9C                               pushfq
   307 00000D17 418F83E8000000                   pop qword [r11 + 232]
   308                                  
   309 00000D1E E8DCFCFFFF                       call generate_process_id
   310 00000D23 49894308                         mov [r11 + 8], rax                       ;记录当前任务的标识
   311                                  
   312 00000D27 E895FEFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   313                                  
   314 00000D2C 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   315                                  
   316 00000D30 415F                             pop r15
   317 00000D32 415E                             pop r14
   318 00000D34 415D                             pop r13
   319 00000D36 415C                             pop r12
   320 00000D38 415B                             pop r11
   321 00000D3A 415A                             pop r10
   322 00000D3C 4159                             pop r9
   323 00000D3E 4158                             pop r8
   324 00000D40 5F                               pop rdi
   325 00000D41 5E                               pop rsi
   326 00000D42 5D                               pop rbp
   327 00000D43 5A                               pop rdx
   328 00000D44 59                               pop rcx
   329 00000D45 5B                               pop rbx
   330 00000D46 58                               pop rax
   331                                  
   332 00000D47 C3                               ret
   333                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   334                                  syscall_procedure:                                ;系统调用的处理过程
   335                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；RBP和R15由此例程占用。如
   336                                           ;有必要，请用户程序在调用syscall前保存它们，在系统调用返回后自行恢复。
   337 00000D48 4889E5                           mov rbp, rsp
   338 00000D4B 4C8B3D(1C000000)                 mov r15, [rel tss_ptr]
   339 00000D52 498B6704                         mov rsp, [r15 + 4]                       ;使用TSS的RSP0作为安全栈
   340                                  
   341 00000D56 FB                               sti
   342                                  
   343 00000D57 4C8B3D(08000000)                 mov r15, [rel position]
   344 00000D5E 4D03BCC7[24000000]               add r15, [r15 + rax * 8 + sys_entry]
   345 00000D66 41FFD7                           call r15
   346                                  
   347 00000D69 FA                               cli
   348 00000D6A 4889EC                           mov rsp, rbp                             ;还原到用户程序的栈
   349 00000D6D 480F07                           o64 sysret
   350                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   351                                  init:    ;初始化内核的工作环境
   352                                  
   353                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   354                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   355 00000D70 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   355 00000D79 FF                 
   356 00000D7A 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   357                                  
   358 00000D82 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   359                                  
   360                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   361                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   362 00000D8A 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   362 00000D93 FF                 
   363 00000D94 4801C4                           add rsp,rax                              ;栈指针必须转换为高端地址且必须是扩高地址
   364                                  
   365                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   366 00000D97 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   366 00000DA0 FF                 
   367 00000DA1 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   368                                  
   369                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   370 00000DA8 488B05(08000000)                 mov rax, [rel position]
   371 00000DAF 4805[B70D0000]                   add rax, .to_upper
   372 00000DB5 FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   373                                  
   374                                    .to_upper:
   375                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   376                                  
   377                                           ;为32个异常创建通用处理过程的中断门
   378 00000DB7 4C8B0D(08000000)                 mov r9, [rel position]
   379 00000DBE 498D81[220A0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   380 00000DC5 E876F3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   381                                  
   382 00000DCA 4D31C0                           xor r8, r8
   383                                    .idt0:
   384 00000DCD E8CFF3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   385 00000DD2 49FFC0                           inc r8
   386 00000DD5 4983F81F                         cmp r8, 31
   387 00000DD9 7EF2                             jle .idt0
   388                                  
   389                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   390 00000DDB 498D81[200A0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   391 00000DE2 E859F3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   392                                  
   393 00000DE7 41B820000000                     mov r8, 32
   394                                    .idt1:
   395 00000DED E8AFF3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   396 00000DF2 49FFC0                           inc r8
   397 00000DF5 4981F8FF000000                   cmp r8, 255
   398 00000DFC 7EEF                             jle .idt1
   399                                  
   400 00000DFE 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   400 00000E07 FF                 
   401 00000E08 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   401 00000E11 FF                 
   402 00000E12 4889430E                         mov qword [rbx + 0x0e], rax
   403 00000E16 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   404                                  
   405 00000E1C 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   406                                  
   407                                           ;初始化8259中断控制器，包括重新设置中断向量号
   408 00000E20 E89CF3FFFF                       call init_8259
   409                                  
   410                                           ;创建并安装16个8259中断处理过程的中断门，向量0x20--0x2f
   411 00000E25 498D81[570A0000]                 lea rax, [r9 + general_8259ints_handler] ;得到通用8259中断处理过程的线性地址
   412 00000E2C E80FF3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   413                                  
   414 00000E31 41B820000000                     mov r8, 0x20
   415                                    .8259:
   416 00000E37 E865F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   417 00000E3C 49FFC0                           inc r8
   418 00000E3F 4983F82F                         cmp r8, 0x2f
   419 00000E43 7EF2                             jle .8259
   420                                  
   421 00000E45 FB                               sti                                      ;开放硬件中断
   422                                  
   423                                           ;在64位模式下显示的第一条信息!
   424 00000E46 4C8B3D(08000000)                 mov r15, [rel position]
   425 00000E4D 498D9F[00000000]                 lea rbx, [r15 + welcome]
   426 00000E54 E8A7F1FFFF                       call put_string64                        ;位于core_utils64.wid
   427                                           ;----------------------------------------------------------------------
   428                                           ;安装系统服务所需要的代码段和栈段描述符
   429 00000E59 4883EC10                         sub rsp, 16                              ;开辟16字节的空间操作GDT和GDTR
   430 00000E5D 0F010424                         sgdt [rsp]
   431 00000E61 4831DB                           xor rbx, rbx
   432 00000E64 668B1C24                         mov bx, [rsp]                            ;得到GDT的界限值
   433 00000E68 66FFC3                           inc bx                                   ;得到GDT的长度（字节数）
   434 00000E6B 48035C2402                       add rbx, [rsp + 2]
   435                                           ;以下，处理器不支持从64位立即数到内存之间的传送!!!
   436 00000E70 C703FFFF0000                     mov dword [rbx], 0x0000ffff
   437 00000E76 C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   438 00000E7D C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   439 00000E84 C7430C00000000                   mov dword [rbx + 12], 0
   440 00000E8B C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   441 00000E92 C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   442 00000E99 C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   443 00000EA0 C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   444                                  
   445                                           ;安装任务状态段TSS的描述符
   446 00000EA7 B968000000                       mov rcx, 104                             ;TSS的标准长度
   447 00000EAC E8B1F9FFFF                       call core_memory_allocate
   448 00000EB1 4C892D(1C000000)                 mov [rel tss_ptr], r13
   449 00000EB8 4C89E8                           mov rax, r13
   450 00000EBB E8B8F2FFFF                       call make_tss_descriptor
   451 00000EC0 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   452 00000EC4 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   453                                  
   454 00000EC8 6683042430                       add word [rsp], 48                       ;4个段描述符和1个TSS描述符的总字节数
   455 00000ECD 0F011424                         lgdt [rsp]
   456 00000ED1 4883C410                         add rsp, 16                              ;恢复栈平衡
   457                                  
   458 00000ED5 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   459 00000ED9 0F00D9                           ltr cx
   460                                  
   461                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   462 00000EDC B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   463 00000EE1 0F32                             rdmsr
   464 00000EE3 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   465 00000EE7 0F30                             wrmsr
   466                                  
   467 00000EE9 B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   468 00000EEE BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   469 00000EF3 31C0                             xor eax, eax
   470 00000EF5 0F30                             wrmsr
   471                                  
   472 00000EF7 B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   473 00000EFC 488B05(08000000)                 mov rax, [rel position]
   474 00000F03 488D80[480D0000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   475 00000F0A 4889C2                           mov rdx, rax
   476 00000F0D 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   477 00000F11 0F30                             wrmsr
   478                                  
   479 00000F13 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   480 00000F18 31D2                             xor edx, edx
   481 00000F1A B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   482 00000F1F 0F30                             wrmsr
   483                                  
   484                                           ;以下安装用于任务切换的实时时钟中断处理过程
   485 00000F21 4C8B0D(08000000)                 mov r9, [rel position]
   486 00000F28 498D81[610A0000]                 lea rax, [r9 + rtm_interrupt_handle]     ;得到中断处理过程的线性地址
   487 00000F2F E80CF2FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   488                                  
   489 00000F34 FA                               cli
   490                                  
   491 00000F35 41B828000000                     mov r8, 0x28
   492 00000F3B E861F2FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   493                                  
   494                                           ;设置和时钟中断相关的硬件
   495 00000F40 B00B                             mov al, 0x0b                             ;RTC寄存器B
   496 00000F42 0C80                             or al, 0x80                              ;阻断NMI
   497 00000F44 E670                             out 0x70, al
   498 00000F46 B012                             mov al, 0x12                             ;设置寄存器B，禁止周期性中断，开放更
   499 00000F48 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   500                                  
   501 00000F4A E4A1                             in al, 0xa1                              ;读8259从片的IMR寄存器
   502 00000F4C 24FE                             and al, 0xfe                             ;清除bit 0(此位连接RTC)
   503 00000F4E E6A1                             out 0xa1, al                             ;写回此寄存器
   504                                  
   505 00000F50 FB                               sti
   506                                  
   507 00000F51 B00C                             mov al, 0x0c
   508 00000F53 E670                             out 0x70, al
   509 00000F55 E471                             in al, 0x71                              ;读RTC寄存器C，复位未决的中断状态
   510                                  
   511                                           ;以下开始创建系统外壳任务（进程）
   512 00000F57 41B832000000                     mov r8, 50
   513 00000F5D E8BDFCFFFF                       call create_process
   514                                  
   515 00000F62 488B1D(54000000)                 mov rbx, [rel pcb_ptr]                   ;得到外壳任务PCB的线性地址
   516 00000F69 488B4338                         mov rax, [rbx + 56]                      ;从PCB中取出CR3
   517 00000F6D 0F22D8                           mov cr3, rax                             ;切换到新进程的地址空间
   518                                  
   519 00000F70 48891D(5C000000)                 mov [rel cur_pcb], rbx                   ;设置当前任务的PCB。
   520 00000F77 48C7431001000000                 mov qword [rbx + 16], 1                  ;设置任务状态为“忙”。
   521                                  
   522 00000F7F 488B4320                         mov rax, [rbx + 32]                      ;从PCB中取出RSP0
   523 00000F83 488B15(1C000000)                 mov rdx, [rel tss_ptr]                   ;得到TSS的线性地址
   524 00000F8A 48894204                         mov [rdx + 4], rax                       ;在TSS中填写RSP0
   525                                  
   526 00000F8E FFB3D0000000                     push qword [rbx + 208]                   ;用户程序的SS
   527 00000F94 FF7378                           push qword [rbx + 120]                   ;用户程序的RSP
   528 00000F97 9C                               pushfq
   529 00000F98 FFB3C8000000                     push qword [rbx + 200]                   ;用户程序的CS
   530 00000F9E FFB3C0000000                     push qword [rbx + 192]                   ;用户程序的RIP
   531                                  
   532 00000FA4 48CF                             iretq                                    ;返回当前任务的私有空间执行
   533                                  
   534                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   535                                  core_end:
