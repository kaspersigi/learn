     1                                  ;多处理器和高级可编程中断控制器
     2                                  ;李忠，2020-7-6
     3                                  
     4                                  %include "..\common\global_defs.wid"
     5                              <1> ;系统全局使用的常量定义，2021-09-05
     6                              <1> 
     7                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
     8                              <1> 
     9                              <1> %ifndef _GLOBAL_DEFS_
    10                              <1>    %define _GLOBAL_DEFS_
    11                              <1> 
    12                              <1>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    13                              <1>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    14                              <1>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    15                              <1>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    16                              <1>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    17                              <1>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    18                              <1>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    19                              <1>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    20                              <1>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    21                              <1>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    22                              <1>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    23                              <1> 
    24                              <1>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    25                              <1>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    26                              <1> 
    27                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    28                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    29                              <1> 
    30                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    31                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    32                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    33                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    34                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    35                              <1> 
    36                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    37                              <1>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    38                              <1>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    39                              <1>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    40                              <1>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    41                              <1>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    42                              <1> 
    43                              <1>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    44                              <1>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    45                              <1>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    46                              <1> 
    47                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    48                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    49                              <1> 
    50                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    51                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    52                              <1> 
    53                              <1>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    54                              <1> 
    55                              <1>    SUGG_PREEM_SLICE    equ     50                      ;推荐的任务/线程抢占时间片长度（毫秒）
    56                              <1> 
    57                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    58                              <1>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
    59                              <1>             %%spin_lock:
    60                              <1>                        cmp %2, 0                       ;锁是释放状态吗？
    61                              <1>                        je %%get_lock                   ;获取锁
    62                              <1>                        pause
    63                              <1>                        jmp %%spin_lock                 ;继续尝试获取锁
    64                              <1>             %%get_lock:
    65                              <1>                        mov %1, 1
    66                              <1>                        xchg %1, %2
    67                              <1>                        cmp %1, 0                       ;交换前为零？
    68                              <1>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
    69                              <1>    %endmacro
    70                              <1> 
    71                              <1> %endif
     5                                  
     6                                  ;===============================================================================
     7                                  section core_header                               ;内核程序头部
     8 00000000 [05120000]                length       dd core_end                        ;#0：内核程序的总长度（字节数）
     9 00000004 [960D0000]                init_entry   dd init                            ;#4：内核入口点
    10 00000008 0000000000000000          position     dq 0                               ;#8：内核加载的虚拟（线性）地址
    11                                  
    12                                  ;===============================================================================
    13                                  section core_data                                 ;内核数据段
    14 00000000 41435049206973206E-       acpi_error    db "ACPI is not supported or data error.", 0x0d, 0x0a, 0
    14 00000009 6F7420737570706F72-
    14 00000012 746564206F72206461-
    14 0000001B 7461206572726F722E-
    14 00000024 0D0A00             
    15                                  
    16 00000027 00                        num_cpus     db 0                               ;逻辑处理器数量
    17 00000028 00<rep 100h>              cpu_list     times 256 db 0                     ;Local APIC ID的列表
    18 00000128 00000000                  lapic_addr   dd 0                               ;Local APIC的物理地址
    19                                  
    20 0000012C 00000000                  ioapic_addr  dd 0                               ;I/O APIC的物理地址
    21 00000130 00                        ioapic_id    db 0                               ;I/O APIC ID
    22                                  
    23 00000131 00000000                  clocks_1ms   dd 0                               ;处理器在1ms内经历的时钟数
    24                                  
    25 00000135 457865637574696E67-       welcome      db "Executing in 64-bit mode.", 0x0d, 0x0a, 0
    25 0000013E 20696E2036342D6269-
    25 00000147 74206D6F64652E0D0A-
    25 00000150 00                 
    26 00000151 0000000000000000          tss_ptr      dq 0                               ;任务状态段TSS从此处开始
    27                                  
    28 00000159 [130A000000000000]        sys_entry    dq get_screen_row
    29 00000161 [9009000000000000]                     dq get_cmos_time
    30 00000169 [DD00000000000000]                     dq put_cstringxy64
    31 00000171 [450C000000000000]                     dq create_process
    32 00000179 [240C000000000000]                     dq get_current_pid
    33 00000181 [300C000000000000]                     dq terminate_process
    34                                  
    35 00000189 0000000000000000          pcb_ptr      dq 0                               ;进程控制块PCB首节点的线性地址
    36 00000191 0000000000000000          cur_pcb      dq 0                               ;当前任务的PCB线性地址
    37                                  
    38                                  ;===============================================================================
    39                                  section core_code                                 ;内核代码段
    40                                  
    41                                  %include "..\common\core_utils64.wid"             ;引入内核用到的例程
    42                              <1> ;文件core_utils64.wid是供64位内核使用的函数集。
    43                              <1> ;创建时间：2021-11-07 10:15，李忠
    44                              <1> ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，
    45                              <1> ;方便内核代码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
    46                              <1> ;2022-5-5：在例程mapping_laddr_to_page和setup_paging_for_laddr中用到了RCX，但未
    47                              <1> ;予以保存和恢复，已经修正。
    48                              <1> 
    49                              <1> %include "..\common\global_defs.wid"
    50                              <2> ;系统全局使用的常量定义，2021-09-05
    51                              <2> 
    52                              <2> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    53                              <2> 
    54                              <2> %ifndef _GLOBAL_DEFS_
    55                              <2>    %define _GLOBAL_DEFS_
    56                              <2> 
    57                              <2>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    58                              <2>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    59                              <2>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    60                              <2>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    61                              <2>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    62                              <2>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    63                              <2>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    64                              <2>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    65                              <2>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    66                              <2>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    67                              <2>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    68                              <2> 
    69                              <2>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    70                              <2>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    71                              <2> 
    72                              <2>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    73                              <2>    UPPER_LINEAR_START  equ     0xffff800000000000
    74                              <2> 
    75                              <2>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    76                              <2>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    77                              <2>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    78                              <2>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    79                              <2>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    80                              <2> 
    81                              <2>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    82                              <2>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    83                              <2>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    84                              <2>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    85                              <2>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    86                              <2>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    87                              <2> 
    88                              <2>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    89                              <2>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    90                              <2>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    91                              <2> 
    92                              <2>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    93                              <2>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    94                              <2> 
    95                              <2>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    96                              <2>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    97                              <2> 
    98                              <2>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    99                              <2> 
   100                              <2>    SUGG_PREEM_SLICE    equ     50                      ;推荐的任务/线程抢占时间片长度（毫秒）
   101                              <2> 
   102                              <2>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
   103                              <2>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
   104                              <2>             %%spin_lock:
   105                              <2>                        cmp %2, 0                       ;锁是释放状态吗？
   106                              <2>                        je %%get_lock                   ;获取锁
   107                              <2>                        pause
   108                              <2>                        jmp %%spin_lock                 ;继续尝试获取锁
   109                              <2>             %%get_lock:
   110                              <2>                        mov %1, 1
   111                              <2>                        xchg %1, %2
   112                              <2>                        cmp %1, 0                       ;交换前为零？
   113                              <2>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
   114                              <2>    %endmacro
   115                              <2> 
   116                              <2> %endif
    50                              <1> 
    51                              <1>          bits 64
    52                              <1> 
    53                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    54                              <1> put_string64:                                     ;显示0终止的字符串并移动光标
    55                              <1>                                                   ;输入：RBX=字符串的线性地址
    56 00000000 FA                  <1>          cli
    57                              <1> 
    58 00000001 53                  <1>          push rbx
    59 00000002 51                  <1>          push rcx
    60                              <1> 
    61                              <1>   .getc:
    62 00000003 8A0B                <1>          mov cl, [rbx]
    63 00000005 08C9                <1>          or cl, cl                                ;检测串结束标志（0）
    64 00000007 740A                <1>          jz .exit                                 ;显示完毕，返回
    65 00000009 E809000000          <1>          call put_char
    66 0000000E 48FFC3              <1>          inc rbx
    67 00000011 EBF0                <1>          jmp .getc
    68                              <1> 
    69                              <1>   .exit:
    70 00000013 59                  <1>          pop rcx
    71 00000014 5B                  <1>          pop rbx
    72                              <1> 
    73 00000015 FB                  <1>          sti
    74                              <1> 
    75 00000016 C3                  <1>          ret                                      ;段内返回
    76                              <1> 
    77                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    78                              <1> put_char:                                         ;在当前光标处显示一个字符,并推进
    79                              <1>                                                   ;光标。
    80                              <1>                                                   ;输入：CL=字符ASCII码
    81 00000017 50                  <1>          push rax
    82 00000018 53                  <1>          push rbx
    83 00000019 51                  <1>          push rcx
    84 0000001A 52                  <1>          push rdx
    85 0000001B 56                  <1>          push rsi
    86 0000001C 57                  <1>          push rdi
    87                              <1> 
    88                              <1>          ;以下取当前光标位置
    89 0000001D 66BAD403            <1>          mov dx, 0x3d4
    90 00000021 B00E                <1>          mov al, 0x0e
    91 00000023 EE                  <1>          out dx, al
    92 00000024 66FFC2              <1>          inc dx                                   ;0x3d5
    93 00000027 EC                  <1>          in al, dx                                ;高字
    94 00000028 88C4                <1>          mov ah, al
    95                              <1> 
    96 0000002A 66FFCA              <1>          dec dx                                   ;0x3d4
    97 0000002D B00F                <1>          mov al, 0x0f
    98 0000002F EE                  <1>          out dx, al
    99 00000030 66FFC2              <1>          inc dx                                   ;0x3d5
   100 00000033 EC                  <1>          in al, dx                                ;低字
   101 00000034 6689C3              <1>          mov bx, ax                               ;BX=代表光标位置的16位数
   102 00000037 4881E3FFFF0000      <1>          and rbx, 0x000000000000ffff              ;准备使用64位寻址方式访问显存
   103                              <1> 
   104 0000003E 80F90D              <1>          cmp cl, 0x0d                             ;回车符？
   105 00000041 750E                <1>          jnz .put_0a
   106 00000043 6689D8              <1>          mov ax, bx
   107 00000046 B350                <1>          mov bl, 80
   108 00000048 F6F3                <1>          div bl
   109 0000004A F6E3                <1>          mul bl
   110 0000004C 6689C3              <1>          mov bx, ax
   111 0000004F EB6C                <1>          jmp .set_cursor
   112                              <1> 
   113                              <1>   .put_0a:
   114 00000051 80F90A              <1>          cmp cl, 0x0a                             ;换行符？
   115 00000054 7506                <1>          jnz .put_other
   116 00000056 6683C350            <1>          add bx, 80
   117 0000005A EB16                <1>          jmp .roll_screen
   118                              <1> 
   119                              <1>   .put_other:                                     ;正常显示字符
   120 0000005C 66D1E3              <1>          shl bx, 1
   121 0000005F 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO                ;在global_defs.wid中定义
   121 00000068 FF                  <1>
   122 00000069 880C18              <1>          mov [rax + rbx], cl
   123                              <1> 
   124                              <1>          ;以下将光标位置推进一个字符
   125 0000006C 66D1EB              <1>          shr bx, 1
   126 0000006F 66FFC3              <1>          inc bx
   127                              <1> 
   128                              <1>   .roll_screen:
   129 00000072 6681FBD007          <1>          cmp bx, 2000                             ;光标超出屏幕？滚屏
   130 00000077 7C44                <1>          jl .set_cursor
   131                              <1> 
   132 00000079 6653                <1>          push bx
   133                              <1> 
   134 0000007B FC                  <1>          cld
   135 0000007C 48BEA0800B000080FF- <1>          mov rsi, UPPER_TEXT_VIDEO + 0xa0         ;小心！64位模式下movsq
   135 00000085 FF                  <1>
   136 00000086 48BF00800B000080FF- <1>          mov rdi, UPPER_TEXT_VIDEO                ;使用的是rsi/rdi/rcx
   136 0000008F FF                  <1>
   137 00000090 B9E0010000          <1>          mov rcx, 480
   138 00000095 F348A5              <1>          rep movsq
   139 00000098 66BB000F            <1>          mov bx, 3840                             ;清除屏幕最底一行
   140 0000009C B950000000          <1>          mov rcx, 80                              ;64位程序应该使用RCX
   141                              <1>   .cls:
   142 000000A1 48B800800B000080FF- <1>          mov rax, UPPER_TEXT_VIDEO
   142 000000AA FF                  <1>
   143 000000AB 66C704182007        <1>          mov word[rax + rbx], 0x0720
   144 000000B1 6683C302            <1>          add bx, 2
   145 000000B5 E2EA                <1>          loop .cls
   146                              <1> 
   147 000000B7 665B                <1>          pop bx
   148 000000B9 6683EB50            <1>          sub bx, 80
   149                              <1> 
   150                              <1>   .set_cursor:
   151 000000BD 66BAD403            <1>          mov dx, 0x3d4
   152 000000C1 B00E                <1>          mov al, 0x0e
   153 000000C3 EE                  <1>          out dx, al
   154 000000C4 66FFC2              <1>          inc dx                                   ;0x3d5
   155 000000C7 88F8                <1>          mov al, bh
   156 000000C9 EE                  <1>          out dx, al
   157 000000CA 66FFCA              <1>          dec dx                                   ;0x3d4
   158 000000CD B00F                <1>          mov al, 0x0f
   159 000000CF EE                  <1>          out dx, al
   160 000000D0 66FFC2              <1>          inc dx                                   ;0x3d5
   161 000000D3 88D8                <1>          mov al, bl
   162 000000D5 EE                  <1>          out dx, al
   163                              <1> 
   164 000000D6 5F                  <1>          pop rdi
   165 000000D7 5E                  <1>          pop rsi
   166 000000D8 5A                  <1>          pop rdx
   167 000000D9 59                  <1>          pop rcx
   168 000000DA 5B                  <1>          pop rbx
   169 000000DB 58                  <1>          pop rax
   170                              <1> 
   171 000000DC C3                  <1>          ret
   172                              <1> 
   173                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   174                              <1> ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符
   175                              <1> put_cstringxy64:                                  ;输入：RBX=字符串首地址
   176                              <1>                                                   ;DH=行，DL=列
   177                              <1>                                                   ;R9B=颜色属性
   178                              <1>          ;cli
   179                              <1> 
   180 000000DD 50                  <1>          push rax
   181 000000DE 53                  <1>          push rbx
   182 000000DF 51                  <1>          push rcx
   183 000000E0 52                  <1>          push rdx
   184 000000E1 4150                <1>          push r8
   185                              <1> 
   186                              <1>          ;指定坐标位置在显存内的偏移量
   187 000000E3 88F0                <1>          mov al, dh
   188 000000E5 B5A0                <1>          mov ch, 160                              ;每一行80个字符，占用160个字节
   189 000000E7 F6E5                <1>          mul ch
   190 000000E9 D0E2                <1>          shl dl, 1                                ;每个字符（列）占用2个字节，要乘以2
   191 000000EB 6681E2FF00          <1>          and dx, 0x00ff
   192 000000F0 6601D0              <1>          add ax, dx                               ;得到指定坐标位置在显存内的偏移量
   193 000000F3 4825FFFF0000        <1>          and rax, 0x000000000000ffff
   194                              <1> 
   195 000000F9 49B800800B000080FF- <1>          mov r8, UPPER_TEXT_VIDEO                 ;显存的起始线性地址
   195 00000102 FF                  <1>
   196                              <1>   .nextc:
   197 00000103 8A13                <1>          mov dl, [rbx]                            ;取得将要显示的字符
   198 00000105 08D2                <1>          or dl, dl
   199 00000107 7412                <1>          jz .exit
   200 00000109 41881400            <1>          mov byte [r8 + rax], dl
   201 0000010D 45884C0001          <1>          mov byte [r8 + rax + 1], r9b             ;字符颜色
   202 00000112 48FFC3              <1>          inc rbx
   203 00000115 4883C002            <1>          add rax, 2                               ;增加一个字符的位置（2个字节）
   204 00000119 EBE8                <1>          jmp .nextc
   205                              <1>   .exit:
   206 0000011B 4158                <1>          pop r8
   207 0000011D 5A                  <1>          pop rdx
   208 0000011E 59                  <1>          pop rcx
   209 0000011F 5B                  <1>          pop rbx
   210 00000120 58                  <1>          pop rax
   211                              <1> 
   212                              <1>          ;sti
   213                              <1> 
   214 00000121 C3                  <1>          ret
   215                              <1> 
   216                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   217                              <1> make_call_gate:                                   ;创建64位的调用门
   218                              <1>                                                   ;输入：RAX=例程的线性地址
   219                              <1>                                                   ;输出：RDI:RSI=调用门
   220 00000122 4889C7              <1>          mov rdi, rax
   221 00000125 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   222                              <1> 
   223 00000129 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   224 0000012A 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   225 00000131 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   226 00000135 66C7442404008C      <1>          mov word [rsp + 4], 0x8c00               ;添加P=1，TYPE=64位调用门
   227 0000013C 5E                  <1>          pop rsi
   228                              <1> 
   229 0000013D C3                  <1>          ret
   230                              <1> 
   231                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   232                              <1> make_interrupt_gate:                              ;创建64位的中断门
   233                              <1>                                                   ;输入：RAX=例程的线性地址
   234                              <1>                                                   ;输出：RDI:RSI=中断门
   235 0000013E 4889C7              <1>          mov rdi, rax
   236 00000141 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   237                              <1> 
   238 00000145 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   239 00000146 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   240 0000014D 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   241 00000151 66C7442404008E      <1>          mov word [rsp + 4], 0x8e00               ;添加P=1，TYPE=64位中断门
   242 00000158 5E                  <1>          pop rsi
   243                              <1> 
   244 00000159 C3                  <1>          ret
   245                              <1> 
   246                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   247                              <1> make_trap_gate:                                   ;创建64位的陷阱门
   248                              <1>                                                   ;输入：RAX=例程的线性地址
   249                              <1>                                                   ;输出：RDI:RSI=陷阱门
   250 0000015A 4889C7              <1>          mov rdi, rax
   251 0000015D 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   252                              <1> 
   253 00000161 50                  <1>          push rax                                 ;构造数据结构，并预置线性地址的位15~0
   254 00000162 66C74424021800      <1>          mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   255 00000169 89442404            <1>          mov [rsp + 4], eax                       ;预置线性地址的位31~16
   256 0000016D 66C7442404008F      <1>          mov word [rsp + 4], 0x8f00               ;添加P=1，TYPE=64位陷阱门
   257 00000174 5E                  <1>          pop rsi
   258                              <1> 
   259 00000175 C3                  <1>          ret
   260                              <1> 
   261                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   262                              <1> make_tss_descriptor:                              ;创建64位的TSS描述符
   263                              <1>                                                   ;输入：RAX=TSS的线性地址
   264                              <1>                                                   ;输出：RDI:RSI=TSS描述符
   265 00000176 50                  <1>          push rax
   266                              <1> 
   267 00000177 4889C7              <1>          mov rdi, rax
   268 0000017A 48C1EF20            <1>          shr rdi, 32                              ;得到门的高64位，在RDI中
   269                              <1> 
   270 0000017E 50                  <1>          push rax                                 ;先将部分线性地址移到适当位置
   271 0000017F 48C1242410          <1>          shl qword [rsp], 16                      ;将线性地址的位23~00移到正确位置
   272 00000184 66C704246800        <1>          mov word [rsp], 104                      ;段界限的标准长度
   273 0000018A 8A442405            <1>          mov al, [rsp + 5]
   274 0000018E 88442407            <1>          mov [rsp + 7], al                        ;将线性地址的位31~24移到正确位置
   275 00000192 C644240589          <1>          mov byte [rsp + 5], 0x89                 ;P=1，DPL=00，TYPE=1001（64位TSS）
   276 00000197 C644240600          <1>          mov byte [rsp + 6], 0                    ;G、0、0、AVL和limit
   277 0000019C 5E                  <1>          pop rsi                                  ;门的低64位
   278                              <1> 
   279 0000019D 58                  <1>          pop rax
   280                              <1> 
   281 0000019E C3                  <1>          ret
   282                              <1> 
   283                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   284                              <1> mount_idt_entry:                                  ;在中断描述符表IDT中安装门描述符
   285                              <1>                                                   ;R8=中断向量
   286                              <1>                                                   ;RDI:RSI=门描述符
   287 0000019F 4150                <1>          push r8
   288 000001A1 4151                <1>          push r9
   289                              <1> 
   290 000001A3 49C1E004            <1>          shl r8, 4                                ;中断号乘以16，得到表内偏移
   291 000001A7 49B900E000000080FF- <1>          mov r9, UPPER_IDT_LINEAR                 ;中断描述符表的高端线性地址
   291 000001B0 FF                  <1>
   292 000001B1 4B893401            <1>          mov [r9 + r8], rsi
   293 000001B5 4B897C0108          <1>          mov [r9 + r8 + 8], rdi
   294                              <1> 
   295 000001BA 4159                <1>          pop r9
   296 000001BC 4158                <1>          pop r8
   297                              <1> 
   298 000001BE C3                  <1>          ret
   299                              <1> 
   300                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   301                              <1> init_8259:                                        ;初始化8259中断控制器，包括重新设置向量号
   302 000001BF 50                  <1>          push rax
   303                              <1> 
   304 000001C0 B011                <1>          mov al, 0x11
   305 000001C2 E620                <1>          out 0x20, al                             ;ICW1：边沿触发/级联方式
   306 000001C4 B020                <1>          mov al, 0x20
   307 000001C6 E621                <1>          out 0x21, al                             ;ICW2:起始中断向量（避开前31个异常的向量）
   308 000001C8 B004                <1>          mov al, 0x04
   309 000001CA E621                <1>          out 0x21, al                             ;ICW3:从片级联到IR2
   310 000001CC B001                <1>          mov al, 0x01
   311 000001CE E621                <1>          out 0x21, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   312                              <1> 
   313 000001D0 B011                <1>          mov al, 0x11
   314 000001D2 E6A0                <1>          out 0xa0, al                             ;ICW1：边沿触发/级联方式
   315 000001D4 B028                <1>          mov al, 0x28
   316 000001D6 E6A1                <1>          out 0xa1, al                             ;ICW2:起始中断向量-->0x28
   317 000001D8 B002                <1>          mov al, 0x02
   318 000001DA E6A1                <1>          out 0xa1, al                             ;ICW3:从片识别标志，级联到主片IR2
   319 000001DC B001                <1>          mov al, 0x01
   320 000001DE E6A1                <1>          out 0xa1, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   321                              <1> 
   322 000001E0 58                  <1>          pop rax
   323 000001E1 C3                  <1>          ret
   324                              <1> 
   325                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   326                              <1> read_hard_disk_0:                                 ;从硬盘读取一个逻辑扇区
   327                              <1>                                                   ;RAX=逻辑扇区号
   328                              <1>                                                   ;RBX=目标缓冲区线性地址
   329                              <1>                                                   ;返回：RBX=RBX+512
   330 000001E2 FA                  <1>          cli
   331                              <1> 
   332 000001E3 50                  <1>          push rax
   333 000001E4 51                  <1>          push rcx
   334 000001E5 52                  <1>          push rdx
   335                              <1> 
   336 000001E6 50                  <1>          push rax
   337                              <1> 
   338 000001E7 66BAF201            <1>          mov dx, 0x1f2
   339 000001EB B001                <1>          mov al, 1
   340 000001ED EE                  <1>          out dx, al                               ;读取的扇区数
   341                              <1> 
   342 000001EE 66FFC2              <1>          inc dx                                   ;0x1f3
   343 000001F1 58                  <1>          pop rax
   344 000001F2 EE                  <1>          out dx, al                               ;LBA地址7~0
   345                              <1> 
   346 000001F3 66FFC2              <1>          inc dx                                   ;0x1f4
   347 000001F6 B108                <1>          mov cl, 8
   348 000001F8 48D3E8              <1>          shr rax, cl
   349 000001FB EE                  <1>          out dx, al                               ;LBA地址15~8
   350                              <1> 
   351 000001FC 66FFC2              <1>          inc dx                                   ;0x1f5
   352 000001FF 48D3E8              <1>          shr rax, cl
   353 00000202 EE                  <1>          out dx, al                               ;LBA地址23~16
   354                              <1> 
   355 00000203 66FFC2              <1>          inc dx                                   ;0x1f6
   356 00000206 48D3E8              <1>          shr rax, cl
   357 00000209 0CE0                <1>          or al, 0xe0                              ;第一硬盘  LBA地址27~24
   358 0000020B EE                  <1>          out dx, al
   359                              <1> 
   360 0000020C 66FFC2              <1>          inc dx                                   ;0x1f7
   361 0000020F B020                <1>          mov al, 0x20                             ;读命令
   362 00000211 EE                  <1>          out dx, al
   363                              <1> 
   364                              <1>   .waits:
   365 00000212 EC                  <1>          in al, dx
   366 00000213 2488                <1>          and al, 0x88
   367 00000215 3C08                <1>          cmp al, 0x08
   368 00000217 75F9                <1>          jnz .waits                               ;不忙，且硬盘已准备好数据传输
   369                              <1> 
   370 00000219 B900010000          <1>          mov rcx, 256                             ;总共要读取的字数
   371 0000021E 66BAF001            <1>          mov dx, 0x1f0
   372                              <1>   .readw:
   373 00000222 66ED                <1>          in ax, dx
   374 00000224 668903              <1>          mov [rbx], ax
   375 00000227 4883C302            <1>          add rbx, 2
   376 0000022B E2F5                <1>          loop .readw
   377                              <1> 
   378 0000022D 5A                  <1>          pop rdx
   379 0000022E 59                  <1>          pop rcx
   380 0000022F 58                  <1>          pop rax
   381                              <1> 
   382 00000230 FB                  <1>          sti
   383 00000231 C3                  <1>          ret
   384                              <1> 
   385                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   386 00000232 FF<rep 40h>         <1>   _page_bit_map times 2*1024/4/8 db 0xff          ;对应物理内存的前512个页面（2MB）
   387 00000272 00<rep 3C0h>        <1>           times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 ;对应后续的页面
   388                              <1>   _page_map_len  equ $ - _page_bit_map
   389                              <1> 
   390                              <1> allocate_a_4k_page:                               ;分配一个4KB的页
   391                              <1>                                                   ;输入：无
   392                              <1>                                                   ;输出：RAX=页的物理地址
   393 00000632 4831C0              <1>          xor rax, rax
   394                              <1>   .b1:
   395 00000635 480FAB05F5FBFFFF    <1>          bts [rel _page_bit_map], rax
   396 0000063D 730B                <1>          jnc .b2
   397 0000063F 48FFC0              <1>          inc rax
   398 00000642 483D00200000        <1>          cmp rax, _page_map_len * 8               ;立即数符号扩展到64位进行比较
   399 00000648 7CEB                <1>          jl .b1
   400                              <1> 
   401                              <1>          ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的
   402                              <1>          ;系统来说，如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注
   403                              <1>          ;销的页面，或者执行页面的换入和换出。
   404                              <1> 
   405                              <1>   .b2:
   406 0000064A 48C1E00C            <1>          shl rax, 12                              ;乘以4096（0x1000）
   407                              <1> 
   408 0000064E C3                  <1>          ret
   409                              <1> 
   410                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   411                              <1> lin_to_lin_of_pml4e:                              ;返回指定的线性地址所对应的4级头表项的线性地址
   412                              <1>                                                   ;输入：R13=线性地址
   413                              <1>                                                   ;输出：R14=对应的4级头表项的线性地址
   414 0000064F 4155                <1>          push r13
   415                              <1> 
   416 00000651 49BE0000000080FF00- <1>          mov r14, 0x0000_ff80_0000_0000           ;保留4级头表索引部分
   416 0000065A 00                  <1>
   417 0000065B 4D21F5              <1>          and r13, r14
   418 0000065E 49C1ED24            <1>          shr r13, 36                              ;原4级头表索引变成页内偏移
   419                              <1> 
   420 00000662 49C7C600F0FFFF      <1>          mov r14, 0xffff_ffff_ffff_f000           ;访问4级头表所用的地址前缀
   421 00000669 4D01EE              <1>          add r14, r13
   422                              <1> 
   423 0000066C 415D                <1>          pop r13
   424                              <1> 
   425 0000066E C3                  <1>          ret
   426                              <1> 
   427                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   428                              <1> lin_to_lin_of_pdpte:                              ;返回指定的线性地址所对应的页目录指针项的线性地址
   429                              <1>                                                   ;输入：R13=线性地址
   430                              <1>                                                   ;输出：R14=对应的页目录指针项的线性地址
   431 0000066F 4155                <1>          push r13
   432                              <1> 
   433 00000671 49BE000000C0FFFF00- <1>          mov r14, 0x0000_ffff_c000_0000           ;保留4级头表索引和页目录指针表索引部分
   433 0000067A 00                  <1>
   434 0000067B 4D21F5              <1>          and r13, r14
   435 0000067E 49C1ED1B            <1>          shr r13, 27                              ;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   436                              <1> 
   437 00000682 49C7C60000E0FF      <1>          mov r14, 0xffff_ffff_ffe0_0000           ;访问页目录指针表所用的地址前缀
   438 00000689 4D01EE              <1>          add r14, r13
   439                              <1> 
   440 0000068C 415D                <1>          pop r13
   441                              <1> 
   442 0000068E C3                  <1>          ret
   443                              <1> 
   444                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   445                              <1> lin_to_lin_of_pdte:                               ;返回指定的线性地址所对应的页目录项的线性地址
   446                              <1>                                                   ;输入：R13=线性地址
   447                              <1>                                                   ;输出：R14=对应的页目录项的线性地址
   448 0000068F 4155                <1>          push r13
   449                              <1> 
   450 00000691 49BE0000E0FFFFFF00- <1>          mov r14, 0x0000_ffff_ffe0_0000           ;保留4级头表索引、页目录指针表索引和页目录表索引部分
   450 0000069A 00                  <1>
   451 0000069B 4D21F5              <1>          and r13, r14
   452 0000069E 49C1ED12            <1>          shr r13, 18                              ;原4级头表索引变成页目录表索引，原页目录指针表索引变
   453                              <1>                                                   ;页表索引，原页目录表索引变页内偏移
   454 000006A2 49C7C6000000C0      <1>          mov r14, 0xffff_ffff_c000_0000           ;访问页目录表所用的地址前缀
   455 000006A9 4D01EE              <1>          add r14, r13
   456                              <1> 
   457 000006AC 415D                <1>          pop r13
   458                              <1> 
   459 000006AE C3                  <1>          ret
   460                              <1> 
   461                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   462                              <1> lin_to_lin_of_pte:                                ;返回指定的线性地址所对应的页表项的线性地址
   463                              <1>                                                   ;输入：R13=线性地址
   464                              <1>                                                   ;输出：R14=对应的页表项的线性地址
   465 000006AF 4155                <1>          push r13
   466                              <1> 
   467 000006B1 49BE00F0FFFFFFFF00- <1>          mov r14, 0x0000_ffff_ffff_f000           ;保留4级头表、页目录指针表、页目录表和页表的索引部分
   467 000006BA 00                  <1>
   468 000006BB 4D21F5              <1>          and r13, r14
   469 000006BE 49C1ED09            <1>          shr r13, 9                               ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   470                              <1>                                                   ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   471 000006C2 49BE0000000080FFFF- <1>          mov r14, 0xffff_ff80_0000_0000           ;访问页表所用的地址前缀
   471 000006CB FF                  <1>
   472 000006CC 4D01EE              <1>          add r14, r13
   473                              <1> 
   474 000006CF 415D                <1>          pop r13
   475                              <1> 
   476 000006D1 C3                  <1>          ret
   477                              <1> 
   478                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   479                              <1> setup_paging_for_laddr:                           ;为指定的线性地址安装分页系统（表项）
   480                              <1>                                                   ;输入：R13=线性地址
   481 000006D2 51                  <1>          push rcx
   482 000006D3 50                  <1>          push rax
   483 000006D4 4156                <1>          push r14
   484                              <1> 
   485                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   486                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   487 000006D6 E874FFFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   488 000006DB 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   489 000006E2 752B                <1>          jnz .b0
   490                              <1> 
   491                              <1>          ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   492 000006E4 E849FFFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   493 000006E9 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   494 000006ED 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   495                              <1> 
   496                              <1>          ;清空刚分配的页目录指针表
   497 000006F0 E87AFFFFFF          <1>          call lin_to_lin_of_pdpte
   498 000006F5 49C1EE0C            <1>          shr r14, 12
   499 000006F9 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   500 000006FD B900020000          <1>          mov rcx, 512
   501                              <1>   .cls0:
   502 00000702 49C70600000000      <1>          mov qword [r14], 0
   503 00000709 4983C608            <1>          add r14, 8
   504 0000070D E2F3                <1>          loop .cls0
   505                              <1> ;-------------------------------------------------
   506                              <1>   .b0:
   507                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   508 0000070F E85BFFFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   509 00000714 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   510 0000071B 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   511                              <1> 
   512                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   513 0000071D E810FFFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   514 00000722 4883C807            <1>          or rax, 0x07                             ;添加属性位
   515 00000726 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   516                              <1> 
   517                              <1>          ;清空刚分配的页目录表
   518 00000729 E861FFFFFF          <1>          call lin_to_lin_of_pdte
   519 0000072E 49C1EE0C            <1>          shr r14, 12
   520 00000732 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   521 00000736 B900020000          <1>          mov rcx, 512
   522                              <1>   .cls1:
   523 0000073B 49C70600000000      <1>          mov qword [r14], 0
   524 00000742 4983C608            <1>          add r14, 8
   525 00000746 E2F3                <1>          loop .cls1
   526                              <1> ;-------------------------------------------------
   527                              <1>   .b1:
   528                              <1>          ;检查该线性地址所对应的页目录项是否存在
   529 00000748 E842FFFFFF          <1>          call lin_to_lin_of_pdte
   530 0000074D 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   531 00000754 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   532                              <1> 
   533                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   534 00000756 E8D7FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   535 0000075B 4883C807            <1>          or rax, 0x07                             ;添加属性位
   536 0000075F 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   537                              <1> 
   538                              <1>          ;清空刚分配的页表
   539 00000762 E848FFFFFF          <1>          call lin_to_lin_of_pte
   540 00000767 49C1EE0C            <1>          shr r14, 12
   541 0000076B 49C1E60C            <1>          shl r14, 12                             ;得到页表的线性地址
   542 0000076F B900020000          <1>          mov rcx, 512
   543                              <1>   .cls2:
   544 00000774 49C70600000000      <1>          mov qword [r14], 0
   545 0000077B 4983C608            <1>          add r14, 8
   546 0000077F E2F3                <1>          loop .cls2
   547                              <1> ;-------------------------------------------------
   548                              <1>   .b2:
   549                              <1>          ;检查该线性地址所对应的页表项是否存在
   550 00000781 E829FFFFFF          <1>          call lin_to_lin_of_pte
   551 00000786 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   552 0000078D 750C                <1>          jnz .b3                                  ;页表项已经存在，转.b3
   553                              <1> 
   554                              <1>          ;创建并安装该线性地址所对应的页表项（分配最终的页）
   555 0000078F E89EFEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页
   556 00000794 4883C807            <1>          or rax, 0x07                             ;添加属性位
   557 00000798 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   558                              <1> 
   559                              <1>   .b3:
   560 0000079B 415E                <1>          pop r14
   561 0000079D 58                  <1>          pop rax
   562 0000079E 59                  <1>          pop rcx
   563                              <1> 
   564 0000079F C3                  <1>          ret
   565                              <1> 
   566                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   567                              <1> mapping_laddr_to_page:                            ;建立线性地址到物理页的映射
   568                              <1>                                                   ;即，为指定的线性地址安装指定的物理页
   569                              <1>                                                   ;输入：R13=线性地址
   570                              <1>                                                   ;      RAX=页的物理地址（含属性）
   571 000007A0 51                  <1>          push rcx
   572 000007A1 4156                <1>          push r14
   573 000007A3 50                  <1>          push rax
   574                              <1> 
   575                              <1>          ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   576                              <1>          ;检查该线性地址所对应的4级头表项是否存在
   577 000007A4 E8A6FEFFFF          <1>          call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   578 000007A9 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   579 000007B0 752B                <1>          jnz .b0
   580                              <1> 
   581                              <1>          ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   582 000007B2 E87BFEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   583 000007B7 4883C807            <1>          or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   584 000007BB 498906              <1>          mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   585                              <1> 
   586                              <1>          ;清空刚分配的页目录指针表
   587 000007BE E8ACFEFFFF          <1>          call lin_to_lin_of_pdpte
   588 000007C3 49C1EE0C            <1>          shr r14, 12
   589 000007C7 49C1E60C            <1>          shl r14, 12                              ;得到页目录指针表的线性地址
   590 000007CB B900020000          <1>          mov rcx, 512
   591                              <1>   .cls0:
   592 000007D0 49C70600000000      <1>          mov qword [r14], 0
   593 000007D7 4983C608            <1>          add r14, 8
   594 000007DB E2F3                <1>          loop .cls0
   595                              <1> ;-------------------------------------------------
   596                              <1>   .b0:
   597                              <1>          ;检查该线性地址所对应的页目录指针项是否存在
   598 000007DD E88DFEFFFF          <1>          call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   599 000007E2 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   600 000007E9 752B                <1>          jnz .b1                                  ;页目录指针项是存在的，转.b1
   601                              <1> 
   602                              <1>          ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   603 000007EB E842FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页目录表
   604 000007F0 4883C807            <1>          or rax, 0x07                             ;添加属性位
   605 000007F4 498906              <1>          mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   606                              <1> 
   607                              <1>          ;清空刚分配的页目录表
   608 000007F7 E893FEFFFF          <1>          call lin_to_lin_of_pdte
   609 000007FC 49C1EE0C            <1>          shr r14, 12
   610 00000800 49C1E60C            <1>          shl r14, 12                             ;得到页目录表的线性地址
   611 00000804 B900020000          <1>          mov rcx, 512
   612                              <1>   .cls1:
   613 00000809 49C70600000000      <1>          mov qword [r14], 0
   614 00000810 4983C608            <1>          add r14, 8
   615 00000814 E2F3                <1>          loop .cls1
   616                              <1> ;-------------------------------------------------
   617                              <1>   .b1:
   618                              <1>          ;检查该线性地址所对应的页目录项是否存在
   619 00000816 E874FEFFFF          <1>          call lin_to_lin_of_pdte
   620 0000081B 49F70601000000      <1>          test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   621 00000822 752B                <1>          jnz .b2                                  ;页目录项已存在，转.b2
   622                              <1> 
   623                              <1>          ;创建并安装该线性地址所对应的页目录项（分配页表）
   624 00000824 E809FEFFFF          <1>          call allocate_a_4k_page                  ;分配一个页做为页表
   625 00000829 4883C807            <1>          or rax, 0x07                             ;添加属性位
   626 0000082D 498906              <1>          mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   627                              <1> 
   628                              <1>          ;清空刚分配的页表
   629 00000830 E87AFEFFFF          <1>          call lin_to_lin_of_pte
   630 00000835 49C1EE0C            <1>          shr r14, 12
   631 00000839 49C1E60C            <1>          shl r14, 12                              ;得到页表的线性地址
   632 0000083D B900020000          <1>          mov rcx, 512
   633                              <1>   .cls2:
   634 00000842 49C70600000000      <1>          mov qword [r14], 0
   635 00000849 4983C608            <1>          add r14, 8
   636 0000084D E2F3                <1>          loop .cls2
   637                              <1> ;-------------------------------------------------
   638                              <1>   .b2:
   639 0000084F E85BFEFFFF          <1>          call lin_to_lin_of_pte                   ;得到页表项的线性地址
   640 00000854 58                  <1>          pop rax
   641 00000855 498906              <1>          mov [r14], rax                           ;在页表中登记页表项（页的地址）
   642                              <1> 
   643 00000858 415E                <1>          pop r14
   644 0000085A 59                  <1>          pop rcx
   645                              <1> 
   646 0000085B C3                  <1>          ret
   647                              <1> 
   648                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   649 0000085C 000020000080FFFF    <1>   _core_next_linear  dq CORE_ALLOC_START          ;下一次分配时可用的起始线性地址
   650                              <1> 
   651                              <1> core_memory_allocate:                             ;在虚拟地址空间的高端（内核）分配内存
   652                              <1>                                                   ;输入：RCX=请求分配的字节数
   653                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   654                              <1>                                                   ;      R14=下次分配的起始线性地址
   655 00000864 4C8B2DF1FFFFFF      <1>          mov r13, [rel _core_next_linear]         ;获得本次分配的起始线性地址
   656 0000086B 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   657                              <1> 
   658 00000870 49F7C607000000      <1>          test r14, 0x07                           ;最低3位是000吗（是否按8字节对齐）？
   659 00000877 740C                <1>          jz .algn
   660 00000879 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   661 0000087D 49C1EE03            <1>          shr r14, 3
   662 00000881 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   663                              <1> 
   664                              <1>   .algn:
   665 00000885 4C8935D0FFFFFF      <1>          mov [rel _core_next_linear], r14         ;写回。
   666                              <1> 
   667 0000088C 4155                <1>          push r13
   668 0000088E 4156                <1>          push r14
   669                              <1> 
   670                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   671 00000890 49C1ED0C            <1>          shr r13, 12
   672 00000894 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   673 00000898 49C1EE0C            <1>          shr r14, 12
   674 0000089C 49C1E60C            <1>          shl r14, 12                              ;too
   675                              <1>   .next:
   676 000008A0 E82DFEFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   677 000008A5 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   678 000008AC 4D39F5              <1>          cmp r13, r14
   679 000008AF 7EEF                <1>          jle .next
   680                              <1> 
   681 000008B1 415E                <1>          pop r14
   682 000008B3 415D                <1>          pop r13
   683                              <1> 
   684 000008B5 C3                  <1>          ret
   685                              <1> 
   686                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   687                              <1> user_memory_allocate:                             ;在用户任务的私有空间（低端）分配内存
   688                              <1>                                                   ;输入：R11=任务控制块PCB的线性地址
   689                              <1>                                                   ;      RCX=希望分配的字节数
   690                              <1>                                                   ;输出：R13=本次分配的起始线性地址
   691                              <1>                                                   ;      R14=下次分配的起始线性地址
   692                              <1>          ;获得本次内存分配的起始线性地址
   693 000008B6 4D8B6B18            <1>          mov r13, [r11 + 24]                      ;获得本次分配的起始线性地址
   694 000008BA 4D8D740D00          <1>          lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   695                              <1> 
   696 000008BF 49F7C607000000      <1>          test r14, 0x07                           ;能够被8整除吗（是否按8字节对齐）？
   697 000008C6 740C                <1>          jz .algn
   698 000008C8 49C1EE03            <1>          shr r14, 3
   699 000008CC 49C1E603            <1>          shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   700 000008D0 4983C608            <1>          add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   701                              <1> 
   702                              <1>   .algn:
   703 000008D4 4D897318            <1>          mov [r11 + 24], r14                      ;写回PCB中。
   704                              <1> 
   705 000008D8 4155                <1>          push r13
   706 000008DA 4156                <1>          push r14
   707                              <1> 
   708                              <1>          ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   709 000008DC 49C1ED0C            <1>          shr r13, 12
   710 000008E0 49C1E50C            <1>          shl r13, 12                              ;清除掉页内偏移部分
   711 000008E4 49C1EE0C            <1>          shr r14, 12
   712 000008E8 49C1E60C            <1>          shl r14, 12                              ;too
   713                              <1>   .next:
   714 000008EC E8E1FDFFFF          <1>          call setup_paging_for_laddr              ;安装当前线性地址所在的页
   715 000008F1 4981C500100000      <1>          add r13, 0x1000                          ;+4096
   716 000008F8 4D39F5              <1>          cmp r13, r14
   717 000008FB 7EEF                <1>          jle .next
   718                              <1> 
   719 000008FD 415E                <1>          pop r14
   720 000008FF 415D                <1>          pop r13
   721                              <1> 
   722 00000901 C3                  <1>          ret
   723                              <1> 
   724                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   725                              <1> copy_current_pml4:                                ;创建新的4级头表，并复制当前4级头表的内容
   726                              <1>                                                   ;输入：无
   727                              <1>                                                   ;输出：RAX=新4级头表的物理地址及属性
   728 00000902 56                  <1>          push rsi
   729 00000903 57                  <1>          push rdi
   730 00000904 4155                <1>          push r13
   731 00000906 51                  <1>          push rcx
   732                              <1> 
   733 00000907 E826FDFFFF          <1>          call allocate_a_4k_page                  ;分配一个物理页
   734 0000090C 4883C807            <1>          or rax, 0x07                             ;立即数符号扩展到64位参与操作
   735 00000910 49BD00F0FFFF7FFFFF- <1>          mov r13, NEW_PML4_LINEAR                 ;用指定的线性地址映射和访问这个页
   735 00000919 FF                  <1>
   736 0000091A E881FEFFFF          <1>          call mapping_laddr_to_page
   737                              <1> 
   738                              <1>          ;相关表项在修改前存在遗留，本次修改必须刷新。
   739 0000091F 410F017D00          <1>          invlpg [r13]
   740                              <1> 
   741 00000924 48C7C600F0FFFF      <1>          mov rsi, 0xffff_ffff_ffff_f000           ;RSI->当前活动4级头表的线性地址
   742 0000092B 4C89EF              <1>          mov rdi, r13                             ;RDI->新4级头表的线性地址
   743 0000092E B900020000          <1>          mov rcx, 512                             ;RCX=要复制的目录项数
   744 00000933 FC                  <1>          cld
   745 00000934 F348A5              <1>          repe movsq
   746                              <1> 
   747 00000937 498985F80F0000      <1>          mov [r13 + 0xff8], rax                   ;新4级头表的511号表项指向它自己
   748 0000093E 410F01BDF80F0000    <1>          invlpg [r13 + 0xff8]
   749                              <1> 
   750 00000946 59                  <1>          pop rcx
   751 00000947 415D                <1>          pop r13
   752 00000949 5F                  <1>          pop rdi
   753 0000094A 5E                  <1>          pop rsi
   754                              <1> 
   755 0000094B C3                  <1>          ret
   756                              <1> 
   757                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   758 0000094C 0000                <1> _gdt_info dw 0
   759 0000094E 0000000000000000    <1>           dq 0
   760                              <1> 
   761                              <1> append_segd_to_gdt:                               ;在GDT中添加段描述符
   762                              <1>                                                   ;输入：RSI=段描述符
   763                              <1>                                                   ;输出：CX=段描述符选择子
   764 00000956 4150                <1>          push r8
   765                              <1> 
   766 00000958 0F0105EDFFFFFF      <1>          sgdt [rel _gdt_info]
   767                              <1> 
   768 0000095F 4C8B05E8FFFFFF      <1>          mov r8, [rel _gdt_info + 2]
   769 00000966 480FB70DDEFFFFFF    <1>          movzx rcx, word [rel _gdt_info]
   770 0000096E 4989740801          <1>          mov [r8 + rcx + 1], rsi
   771                              <1> 
   772 00000973 4883C108            <1>          add rcx, 8
   773 00000977 66890DCEFFFFFF      <1>          mov [rel _gdt_info], cx
   774                              <1> 
   775 0000097E 0F0115C7FFFFFF      <1>          lgdt [rel _gdt_info]
   776                              <1> 
   777 00000985 66C1E903            <1>          shr cx, 3                                ;除以8（消除余数）
   778 00000989 66C1E103            <1>          shl cx, 3                                ;将索引号移到正确位置
   779                              <1>          ;and cx, 0xfff8
   780 0000098D 4158                <1>          pop r8
   781                              <1> 
   782 0000098F C3                  <1>          ret
   783                              <1> 
   784                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   785                              <1> get_cmos_time:                                    ;从CMOS中获取当前时间
   786                              <1>                                                   ;输入：RBX=缓冲区线性地址
   787 00000990 50                  <1>          push rax
   788                              <1> 
   789                              <1>   .w0:
   790 00000991 B08A                <1>          mov al, 0x8a
   791 00000993 E670                <1>          out 0x70, al
   792 00000995 E471                <1>          in al, 0x71                              ;读寄存器A
   793 00000997 A880                <1>          test al, 0x80                            ;测试第7位UIP，等待更新周期结束。
   794 00000999 75F6                <1>          jnz .w0
   795                              <1> 
   796 0000099B B084                <1>          mov al, 0x84
   797 0000099D E670                <1>          out 0x70, al
   798 0000099F E471                <1>          in al, 0x71                              ;读RTC当前时间(时)
   799 000009A1 88C4                <1>          mov ah, al
   800                              <1> 
   801 000009A3 C0EC04              <1>          shr ah, 4
   802 000009A6 80E40F              <1>          and ah, 0x0f
   803 000009A9 80C430              <1>          add ah, 0x30
   804 000009AC 8823                <1>          mov [rbx], ah
   805                              <1> 
   806 000009AE 240F                <1>          and al, 0x0f
   807 000009B0 0430                <1>          add al, 0x30
   808 000009B2 884301              <1>          mov [rbx + 1], al
   809                              <1> 
   810 000009B5 C643023A            <1>          mov byte [rbx + 2], ':'
   811                              <1> 
   812 000009B9 B082                <1>          mov al, 0x82
   813 000009BB E670                <1>          out 0x70, al
   814 000009BD E471                <1>          in al, 0x71                              ;读RTC当前时间(分)
   815 000009BF 88C4                <1>          mov ah, al
   816                              <1> 
   817 000009C1 C0EC04              <1>          shr ah, 4
   818 000009C4 80E40F              <1>          and ah, 0x0f
   819 000009C7 80C430              <1>          add ah, 0x30
   820 000009CA 886303              <1>          mov [rbx + 3], ah
   821                              <1> 
   822 000009CD 240F                <1>          and al, 0x0f
   823 000009CF 0430                <1>          add al, 0x30
   824 000009D1 884304              <1>          mov [rbx + 4], al
   825                              <1> 
   826 000009D4 C643053A            <1>          mov byte [rbx + 5], ':'
   827                              <1> 
   828 000009D8 B080                <1>          mov al, 0x80
   829 000009DA E670                <1>          out 0x70, al
   830 000009DC E471                <1>          in al, 0x71                              ;读RTC当前时间(秒)
   831 000009DE 88C4                <1>          mov ah, al                               ;分拆成两个数字
   832                              <1> 
   833 000009E0 C0EC04              <1>          shr ah, 4                                ;逻辑右移4位
   834 000009E3 80E40F              <1>          and ah, 0x0f
   835 000009E6 80C430              <1>          add ah, 0x30
   836 000009E9 886306              <1>          mov [rbx + 6], ah
   837                              <1> 
   838 000009EC 240F                <1>          and al, 0x0f                             ;仅保留低4位
   839 000009EE 0430                <1>          add al, 0x30                             ;转换成ASCII
   840 000009F0 884307              <1>          mov [rbx + 7], al
   841                              <1> 
   842 000009F3 C6430800            <1>          mov byte [rbx + 8], 0                    ;空字符终止
   843                              <1> 
   844 000009F7 58                  <1>          pop rax
   845                              <1> 
   846 000009F8 C3                  <1>          ret
   847                              <1> 
   848                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   849 000009F9 0000000000000000    <1>   _process_id dq 0
   850                              <1> 
   851                              <1> generate_process_id:                              ;生成唯一的进程标识
   852                              <1>                                                   ;返回：RAX=进程标识
   853 00000A01 FA                  <1>          cli
   854 00000A02 488B05F0FFFFFF      <1>          mov rax, [rel _process_id]
   855 00000A09 48FF05E9FFFFFF      <1>          inc qword [rel _process_id]
   856 00000A10 FB                  <1>          sti
   857 00000A11 C3                  <1>          ret
   858                              <1> 
   859                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   860                              <1> ;  _thread_id dq 0
   861                              <1> 
   862                              <1> ;generate_thread_id:                               ;生成唯一的线程标识
   863                              <1>                                                   ;返回：RAX=线程标识
   864                              <1> ;         mov rax, [rel _thread_id]
   865                              <1> ;         inc qword [rel _thread_id]
   866                              <1> ;         ret
   867                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   868 00000A12 08                  <1>   _screen_row db 8
   869                              <1> 
   870                              <1> get_screen_row:                                   ;返回下一个屏幕坐标行的行号
   871                              <1>                                                   ;返回：DH=行号
   872 00000A13 FA                  <1>          cli
   873 00000A14 8A35F8FFFFFF        <1>          mov dh, [rel _screen_row]
   874 00000A1A FE05F2FFFFFF        <1>          inc byte [rel _screen_row]
   875 00000A20 FB                  <1>          sti
   876 00000A21 C3                  <1>          ret
   877                              <1> 
   878                              <1> ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   879                              <1> 
    42                                  
    43                                           bits 64
    44                                  
    45                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    46                                  general_interrupt_handler:                        ;通用中断处理过程
    47 00000A22 48CF                             iretq
    48                                  
    49                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    50                                  general_exception_handler:                        ;通用异常处理过程
    51                                                                                    ;在24行0列显示红底白字的错误信息
    52 00000A24 4C8B3D(08000000)                 mov r15, [rel position]
    53 00000A2B 498D9F[400A0000]                 lea rbx, [r15 + exceptm]
    54 00000A32 B618                             mov dh, 24
    55 00000A34 B200                             mov dl, 0
    56 00000A36 41B14F                           mov r9b, 0x4f
    57 00000A39 E89FF6FFFF                       call put_cstringxy64                     ;位于core_utils64.wid
    58                                  
    59 00000A3E FA                               cli
    60 00000A3F F4                               hlt                                      ;停机且不接受外部硬件中断
    61                                  
    62 00000A40 412065786365707469-       exceptm      db "A exception raised,halt.", 0   ;发生异常时的错误信息
    62 00000A49 6F6E20726169736564-
    62 00000A52 2C68616C742E00     
    63                                  
    64                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    65                                  general_8259ints_handler:                         ;通用的8259中断处理过程
    66 00000A59 50                               push rax
    67                                  
    68 00000A5A B020                             mov al, 0x20                             ;中断结束命令EOI
    69 00000A5C E6A0                             out 0xa0, al                             ;向从片发送
    70 00000A5E E620                             out 0x20, al                             ;向主片发送
    71                                  
    72 00000A60 58                               pop rax
    73                                  
    74 00000A61 48CF                             iretq
    75                                  
    76                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    77                                  rtm_interrupt_handle:                             ;实时时钟中断处理过程（任务切换）
    78 00000A63 4150                             push r8
    79 00000A65 50                               push rax
    80 00000A66 53                               push rbx
    81                                  
    82                                           ;mov al, 0x20                             ;中断结束命令EOI
    83                                           ;out 0xa0, al                             ;向8259A从片发送
    84                                           ;out 0x20, al                             ;向8259A主片发送
    85                                  
    86 00000A67 B00C                             mov al, 0x0c                             ;寄存器C的索引。且开放NMI
    87 00000A69 E670                             out 0x70, al
    88 00000A6B E471                             in al, 0x71                              ;读一下RTC的寄存器C，否则只发生一次中断
    89                                                                                    ;此处不考虑闹钟和周期性中断的情况
    90                                  
    91                                           ;除非是NMI、SMI、INIT、ExtINT、SIPI或者INIT-Deassert引发的中断，中断处理过程必须
    92                                           ;包含一条写EOI寄存器的指令
    93 00000A6D 49B800E0FFFF7FFFFF-              mov r8, LAPIC_START_ADDR                ;给Local APIC发送中断结束命令EOI
    93 00000A76 FF                 
    94 00000A77 41C780B00000000000-              mov dword [r8 + 0xb0], 0
    94 00000A80 0000               
    95                                  
    96                                           ;以下开始执行任务切换
    97                                           ;任务切换的原理是，它发生在所有任务的全局空间。在任务A的全局空间执行任务
    98                                           ;切换，切换到任务B，实际上也是从任务B的全局空间返回任务B的私有空间。
    99                                  
   100                                           ;从PCB链表中寻找就绪的任务。
   101 00000A82 4C8B05(91010000)                 mov r8, [rel cur_pcb]                    ;定位到当前任务的PCB节点
   102 00000A89 4983F800                         cmp r8, 0                                ;系统中尚未确立当前任务？
   103 00000A8D 0F844E010000                     jz .return                               ;是。未找到就绪任务（节点），返回
   104                                    .again:
   105 00000A93 4D8B8018010000                   mov r8, [r8 + 280]                       ;取得下一个节点
   106 00000A9A 4C3B05(91010000)                 cmp r8, [rel cur_pcb]                    ;是否转一圈回到当前节点？
   107 00000AA1 0F843A010000                     jz .return                               ;是。未找到就绪任务（节点），返回
   108 00000AA7 4983781000                       cmp qword [r8 + 16], 0                   ;是就绪任务（节点）？
   109 00000AAC 7402                             jz .found                                ;是。转任务切换
   110 00000AAE EBE3                             jmp .again
   111                                  
   112                                    .found:
   113 00000AB0 488B05(91010000)                 mov rax, [rel cur_pcb]                   ;取得当前任务的PCB（线性地址）
   114 00000AB7 4883781002                       cmp qword [rax + 16], 2                  ;当前任务有可能已经被标记为终止。
   115 00000ABC 0F8480000000                     jz .restore
   116                                  
   117                                           ;保存当前任务的状态以便将来恢复执行
   118 00000AC2 0F20DB                           mov rbx, cr3
   119 00000AC5 48895838                         mov [rax + 56], rbx
   120                                  
   121 00000AC9 48C7401000000000                 mov qword [rax + 16], 0                  ;置任务状态为就绪
   122                                           ;mov [rax + 64], rax                     ;不需设置，将来恢复执行时从栈中弹出
   123                                           ;mov [rax + 72], rbx                     ;不需设置，将来恢复执行时从栈中弹出
   124 00000AD1 48894850                         mov [rax + 80], rcx
   125 00000AD5 48895058                         mov [rax + 88], rdx
   126 00000AD9 48897060                         mov [rax + 96], rsi
   127 00000ADD 48897868                         mov [rax + 104], rdi
   128 00000AE1 48896870                         mov [rax + 112], rbp
   129 00000AE5 48896078                         mov [rax + 120], rsp
   130                                           ;mov [rax + 128], r8                     ;不需设置，将来恢复执行时从栈中弹出
   131 00000AE9 4C898888000000                   mov [rax + 136], r9
   132 00000AF0 4C899090000000                   mov [rax + 144], r10
   133 00000AF7 4C899898000000                   mov [rax + 152], r11
   134 00000AFE 4C89A0A0000000                   mov [rax + 160], r12
   135 00000B05 4C89A8A8000000                   mov [rax + 168], r13
   136 00000B0C 4C89B0B0000000                   mov [rax + 176], r14
   137 00000B13 4C89B8B8000000                   mov [rax + 184], r15
   138 00000B1A 488B1D(08000000)                 mov rbx, [rel position]
   139 00000B21 488D9B[E10B0000]                 lea rbx, [rbx + .return]
   140 00000B28 488998C0000000                   mov [rax + 192], rbx                     ;RIP为中断返回点
   141 00000B2F 8C88C8000000                     mov [rax + 200], cs
   142 00000B35 8C90D0000000                     mov [rax + 208], ss
   143 00000B3B 9C                               pushfq
   144 00000B3C 8F80E8000000                     pop qword [rax + 232]
   145                                  
   146                                    .restore:
   147                                           ;恢复新任务的状态
   148 00000B42 4C8905(91010000)                 mov [rel cur_pcb], r8                    ;将新任务设置为当前任务
   149 00000B49 49C7401001000000                 mov qword [r8 + 16], 1                   ;置任务状态为忙
   150                                  
   151 00000B51 498B4020                         mov rax, [r8 + 32]                       ;取PCB中的RSP0
   152 00000B55 488B1D(51010000)                 mov rbx, [rel tss_ptr]
   153 00000B5C 48894304                         mov [rbx + 4], rax                       ;置TSS的RSP0
   154                                  
   155 00000B60 498B4038                         mov rax, [r8 + 56]
   156 00000B64 0F22D8                           mov cr3, rax                             ;切换地址空间
   157                                  
   158 00000B67 498B4040                         mov rax, [r8 + 64]
   159 00000B6B 498B5848                         mov rbx, [r8 + 72]
   160 00000B6F 498B4850                         mov rcx, [r8 + 80]
   161 00000B73 498B5058                         mov rdx, [r8 + 88]
   162 00000B77 498B7060                         mov rsi, [r8 + 96]
   163 00000B7B 498B7868                         mov rdi, [r8 + 104]
   164 00000B7F 498B6870                         mov rbp, [r8 + 112]
   165 00000B83 498B6078                         mov rsp, [r8 + 120]
   166 00000B87 4D8B8888000000                   mov r9, [r8 + 136]
   167 00000B8E 4D8B9090000000                   mov r10, [r8 + 144]
   168 00000B95 4D8B9898000000                   mov r11, [r8 + 152]
   169 00000B9C 4D8BA0A0000000                   mov r12, [r8 + 160]
   170 00000BA3 4D8BA8A8000000                   mov r13, [r8 + 168]
   171 00000BAA 4D8BB0B0000000                   mov r14, [r8 + 176]
   172 00000BB1 4D8BB8B8000000                   mov r15, [r8 + 184]
   173 00000BB8 41FFB0D0000000                   push qword [r8 + 208]                    ;SS
   174 00000BBF 41FF7078                         push qword [r8 + 120]                    ;RSP
   175 00000BC3 41FFB0E8000000                   push qword [r8 + 232]                    ;RFLAGS
   176 00000BCA 41FFB0C8000000                   push qword [r8 + 200]                    ;CS
   177 00000BD1 41FFB0C0000000                   push qword [r8 + 192]                    ;RIP
   178                                  
   179 00000BD8 4D8B8080000000                   mov r8, [r8 + 128]                       ;恢复R8的值
   180                                  
   181 00000BDF 48CF                             iretq                                    ;转入新任务局部空间执行
   182                                  
   183                                    .return:
   184 00000BE1 5B                               pop rbx
   185 00000BE2 58                               pop rax
   186 00000BE3 4158                             pop r8
   187                                  
   188 00000BE5 48CF                             iretq
   189                                  
   190                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   191                                  append_to_pcb_link:                               ;在PCB链上追加任务控制块
   192                                                                                    ;输入：R11=PCB线性基地址
   193 00000BE7 50                               push rax
   194 00000BE8 53                               push rbx
   195                                  
   196 00000BE9 FA                               cli
   197                                  
   198 00000BEA 488B1D(89010000)                 mov rbx, [rel pcb_ptr]                   ;取得链表首节点的线性地址
   199 00000BF1 4809DB                           or rbx, rbx
   200 00000BF4 7513                             jnz .not_empty                           ;链表非空，转.not_empty
   201 00000BF6 4D891B                           mov [r11], r11                           ;唯一的节点：前驱是自己
   202 00000BF9 4D899B18010000                   mov [r11 + 280], r11                     ;后继也是自己
   203 00000C00 4C891D(89010000)                 mov [rel pcb_ptr], r11                   ;这是头节点
   204 00000C07 EB17                             jmp .return
   205                                  
   206                                    .not_empty:
   207 00000C09 488B03                           mov rax, [rbx]                           ;取得头节点的前驱节点的线性地址
   208                                           ;此处，RBX=头节点；RAX=头节点的前驱节点；R11=追加的节点
   209 00000C0C 4C899818010000                   mov [rax + 280], r11                     ;前驱节点的后继是追加的节点
   210 00000C13 49899B18010000                   mov [r11 + 280], rbx                     ;追加的节点的后继是头节点
   211 00000C1A 498903                           mov [r11], rax                           ;追加的节点的前驱是头节点的前驱
   212 00000C1D 4C891B                           mov [rbx], r11                           ;头节点的前驱是追加的节点
   213                                  
   214                                    .return:
   215 00000C20 FB                               sti
   216                                  
   217 00000C21 5B                               pop rbx
   218 00000C22 58                               pop rax
   219                                  
   220 00000C23 C3                               ret
   221                                  
   222                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   223                                  get_current_pid:                                  ;返回当前任务（进程）的标识
   224 00000C24 488B05(91010000)                 mov rax, [rel cur_pcb]
   225 00000C2B 488B4008                         mov rax, [rax + 8]
   226                                  
   227 00000C2F C3                               ret
   228                                  
   229                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   230                                  terminate_process:                                ;终止当前任务
   231 00000C30 FA                               cli                                      ;执行流改变期间禁止时钟中断引发的任务切换
   232                                  
   233 00000C31 488B05(91010000)                 mov rax, [rel cur_pcb]                   ;定位到当前任务的PCB节点
   234 00000C38 48C7401002000000                 mov qword [rax + 16], 2                  ;状态=终止
   235                                  
   236 00000C40 E91EFEFFFF                       jmp rtm_interrupt_handle                 ;强制任务调度，交还处理器控制权
   237                                  
   238                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   239                                  create_process:                                   ;创建新的任务
   240                                                                                    ;输入：R8=程序的起始逻辑扇区号
   241 00000C45 50                               push rax
   242 00000C46 53                               push rbx
   243 00000C47 51                               push rcx
   244 00000C48 52                               push rdx
   245 00000C49 56                               push rsi
   246 00000C4A 57                               push rdi
   247 00000C4B 55                               push rbp
   248 00000C4C 4150                             push r8
   249 00000C4E 4151                             push r9
   250 00000C50 4152                             push r10
   251 00000C52 4153                             push r11
   252 00000C54 4154                             push r12
   253 00000C56 4155                             push r13
   254 00000C58 4156                             push r14
   255 00000C5A 4157                             push r15
   256                                  
   257                                           ;首先在地址空间的高端（内核）创建任务控制块PCB
   258 00000C5C B900020000                       mov rcx, 512                             ;任务控制块PCB的尺寸
   259 00000C61 E8FEFBFFFF                       call core_memory_allocate                ;在虚拟地址空间的高端（内核）分配内存
   260                                  
   261 00000C66 4D89EB                           mov r11, r13                             ;以下，R11专用于保存PCB线性地址
   262                                  
   263 00000C69 49C7431800000000                 mov qword [r11 + 24], USER_ALLOC_START   ;填写PCB的下一次可分配线性地址域
   264                                  
   265                                           ;从当前活动的4级头表复制并创建新任务的4级头表。
   266 00000C71 E88CFCFFFF                       call copy_current_pml4
   267 00000C76 49894338                         mov [r11 + 56], rax                      ;填写PCB的CR3域，默认PCD=PWT=0
   268                                  
   269                                           ;以下，切换到新任务的地址空间，并清空其4级头表的前半部分。不过没有关系，
   270                                           ;我们正在地址空间的高端执行，可正常执行内核代码并访问内核数据，毕竟所有
   271                                           ;任务的高端（全局）部分都相同。同时，当前使用的栈位于地址空间高端的栈。
   272 00000C7A 410F20DF                         mov r15, cr3                             ;保存控制寄存器CR3的值
   273 00000C7E 0F22D8                           mov cr3, rax                             ;切换到新4级头表映射的新地址空间
   274                                  
   275                                           ;清空当前4级头表的前半部分（对应于任务的局部地址空间）
   276 00000C81 48C7C000F0FFFF                   mov rax, 0xffff_ffff_ffff_f000           ;当前活动4级头表自身的线性地址
   277 00000C88 B900010000                       mov rcx, 256
   278                                    .clsp:
   279 00000C8D 48C70000000000                   mov qword [rax], 0
   280 00000C94 4883C008                         add rax, 8
   281 00000C98 E2F3                             loop .clsp
   282                                  
   283 00000C9A 0F20D8                           mov rax, cr3                             ;刷新TLB
   284 00000C9D 0F22D8                           mov cr3, rax
   285                                  
   286 00000CA0 B900000100                       mov rcx, 4096 * 16                       ;为TSS的RSP0开辟栈空间
   287 00000CA5 E8BAFBFFFF                       call core_memory_allocate                ;必须是在内核的空间中开辟
   288 00000CAA 4D897320                         mov [r11 + 32], r14                      ;填写PCB中的RSP0域的值
   289                                  
   290 00000CAE B900000100                       mov rcx, 4096 * 16                       ;为用户程序开辟栈空间
   291 00000CB3 E8FEFBFFFF                       call user_memory_allocate
   292 00000CB8 4D897378                         mov [r11 + 120], r14                     ;用户程序执行时的RSP。
   293                                  
   294 00000CBC 49C7431000000000                 mov qword [r11 + 16], 0                  ;任务状态=就绪
   295                                  
   296                                           ;以下开始加载用户程序
   297 00000CC4 B900020000                       mov rcx, 512                             ;在私有空间开辟一个缓冲区
   298 00000CC9 E8E8FBFFFF                       call user_memory_allocate
   299 00000CCE 4C89EB                           mov rbx, r13
   300 00000CD1 4C89C0                           mov rax, r8                              ;用户程序起始扇区号
   301 00000CD4 E809F5FFFF                       call read_hard_disk_0
   302                                  
   303 00000CD9 4D896D10                         mov [r13 + 16], r13                      ;在程序中填写它自己的起始线性地址
   304 00000CDD 4D89EE                           mov r14, r13
   305 00000CE0 4D037508                         add r14, [r13 + 8]
   306 00000CE4 4D89B3C0000000                   mov [r11 + 192], r14                     ;在PCB中登记程序的入口点线性地址
   307                                  
   308                                           ;以下判断整个程序有多大
   309 00000CEB 498B4D00                         mov rcx, [r13]                           ;程序尺寸
   310 00000CEF 48F7C1FF010000                   test rcx, 0x1ff                          ;能够被512整除吗？
   311 00000CF6 740F                             jz .y512
   312 00000CF8 48C1E909                         shr rcx, 9                               ;不能？凑整。
   313 00000CFC 48C1E109                         shl rcx, 9
   314 00000D00 4881C100020000                   add rcx, 512
   315                                    .y512:
   316 00000D07 4881E900020000                   sub rcx, 512                             ;减去已经读的一个扇区长度
   317 00000D0E 7416                             jz .rdok
   318 00000D10 E8A1FBFFFF                       call user_memory_allocate
   319                                           ;mov rbx, r13
   320 00000D15 48C1E909                         shr rcx, 9                               ;除以512，还需要读的扇区数
   321 00000D19 48FFC0                           inc rax                                  ;起始扇区号
   322                                    .b1:
   323 00000D1C E8C1F4FFFF                       call read_hard_disk_0
   324 00000D21 48FFC0                           inc rax
   325 00000D24 E2F6                             loop .b1                                 ;循环读，直到读完整个用户程序
   326                                  
   327                                    .rdok:
   328 00000D26 49C783C80000003B00-              mov qword [r11 + 200], USER_CODE64_SEL   ;新任务的代码段选择子
   328 00000D2F 0000               
   329 00000D31 49C783D00000003300-              mov qword [r11 + 208], USER_STACK64_SEL  ;新任务的栈段选择子
   329 00000D3A 0000               
   330                                  
   331 00000D3C 9C                               pushfq
   332 00000D3D 418F83E8000000                   pop qword [r11 + 232]
   333                                  
   334 00000D44 E8B8FCFFFF                       call generate_process_id
   335 00000D49 49894308                         mov [r11 + 8], rax                       ;记录当前任务的标识
   336                                  
   337 00000D4D E895FEFFFF                       call append_to_pcb_link                  ;将PCB添加到进程控制块链表尾部
   338                                  
   339 00000D52 410F22DF                         mov cr3, r15                             ;切换到原任务的地址空间
   340                                  
   341 00000D56 415F                             pop r15
   342 00000D58 415E                             pop r14
   343 00000D5A 415D                             pop r13
   344 00000D5C 415C                             pop r12
   345 00000D5E 415B                             pop r11
   346 00000D60 415A                             pop r10
   347 00000D62 4159                             pop r9
   348 00000D64 4158                             pop r8
   349 00000D66 5D                               pop rbp
   350 00000D67 5F                               pop rdi
   351 00000D68 5E                               pop rsi
   352 00000D69 5A                               pop rdx
   353 00000D6A 59                               pop rcx
   354 00000D6B 5B                               pop rbx
   355 00000D6C 58                               pop rax
   356                                  
   357 00000D6D C3                               ret
   358                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   359                                  syscall_procedure:                                ;系统调用的处理过程
   360                                           ;RCX和R11由处理器使用，保存RIP和RFLAGS的内容；RBP和R15由此例程占用。如
   361                                           ;有必要，请用户程序在调用syscall前保存它们，在系统调用返回后自行恢复。
   362 00000D6E 4889E5                           mov rbp, rsp
   363 00000D71 4C8B3D(51010000)                 mov r15, [rel tss_ptr]
   364 00000D78 498B6704                         mov rsp, [r15 + 4]                       ;使用TSS的RSP0作为安全栈
   365                                  
   366 00000D7C FB                               sti
   367                                  
   368 00000D7D 4C8B3D(08000000)                 mov r15, [rel position]
   369 00000D84 4D03BCC7[59010000]               add r15, [r15 + rax * 8 + sys_entry]
   370 00000D8C 41FFD7                           call r15
   371                                  
   372 00000D8F FA                               cli
   373 00000D90 4889EC                           mov rsp, rbp                             ;还原到用户程序的栈
   374 00000D93 480F07                           o64 sysret
   375                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   376                                  init:    ;初始化内核的工作环境
   377                                  
   378                                           ;将GDT的线性地址映射到虚拟内存高端的相同位置。
   379                                           ;处理器不支持64位立即数到内存地址的操作，所以用两条指令完成。
   380 00000D96 48B8000001000080FF-              mov rax, UPPER_GDT_LINEAR                ;GDT的高端线性地址
   380 00000D9F FF                 
   381 00000DA0 48890425047E0000                 mov qword [SDA_PHY_ADDR + 4], rax        ;注意：必须是扩高地址
   382                                  
   383 00000DA8 0F011425027E0000                 lgdt [SDA_PHY_ADDR + 2]                  ;只有在64位模式下才能加载64位线性地址部分
   384                                  
   385                                           ;将栈映射到高端，否则，压栈时依然压在低端，并和低端的内容冲突。
   386                                           ;64位模式下不支持源操作数为64位立即数的加法操作。
   387 00000DB0 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者加上UPPER_LINEAR_START
   387 00000DB9 FF                 
   388 00000DBA 4801C4                           add rsp,rax                              ;栈指针必须转换为高端地址且必须是扩高地址
   389                                  
   390                                           ;准备让处理器从虚拟地址空间的高端开始执行（现在依然在低端执行）
   391 00000DBD 48B8000000000080FF-              mov rax, 0xffff800000000000              ;或者使用常量UPPER_LINEAR_START
   391 00000DC6 FF                 
   392 00000DC7 480105(08000000)                 add [rel position], rax                  ;内核程序的起始位置数据也必须转换成扩高地址
   393                                  
   394                                           ;内核的起始地址 + 标号.to_upper的汇编地址 = 标号.to_upper所在位置的运行时扩高地址
   395 00000DCE 488B05(08000000)                 mov rax, [rel position]
   396 00000DD5 4805[DD0D0000]                   add rax, .to_upper
   397 00000DDB FFE0                             jmp rax                                  ;绝对间接近转移，从此在高端执行后面的指令
   398                                  
   399                                    .to_upper:
   400                                           ;初始化中断描述符表IDT，并为32个异常以及224个中断安装门描述符
   401                                  
   402                                           ;为32个异常创建通用处理过程的中断门
   403 00000DDD 4C8B0D(08000000)                 mov r9, [rel position]
   404 00000DE4 498D81[240A0000]                 lea rax, [r9 + general_exception_handler];得到通用异常处理过程的线性地址
   405 00000DEB E84EF3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   406                                  
   407 00000DF0 4D31C0                           xor r8, r8
   408                                    .idt0:
   409 00000DF3 E8A7F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   410 00000DF8 49FFC0                           inc r8
   411 00000DFB 4983F81F                         cmp r8, 31
   412 00000DFF 7EF2                             jle .idt0
   413                                  
   414                                           ;创建并安装对应于其它中断的通用处理过程的中断门
   415 00000E01 498D81[220A0000]                 lea rax, [r9 + general_interrupt_handler];得到通用中断处理过程的线性地址
   416 00000E08 E831F3FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   417                                  
   418 00000E0D 41B820000000                     mov r8, 32
   419                                    .idt1:
   420 00000E13 E887F3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   421 00000E18 49FFC0                           inc r8
   422 00000E1B 4981F8FF000000                   cmp r8, 255
   423 00000E22 7EEF                             jle .idt1
   424                                  
   425 00000E24 48B800E000000080FF-              mov rax, UPPER_IDT_LINEAR                ;中断描述符表IDT的高端线性地址
   425 00000E2D FF                 
   426 00000E2E 48BB007E00000080FF-              mov rbx, UPPER_SDA_LINEAR                ;系统数据区SDA的高端线性地址
   426 00000E37 FF                 
   427 00000E38 4889430E                         mov qword [rbx + 0x0e], rax
   428 00000E3C 66C7430CFF0F                     mov word [rbx + 0x0c], 256 * 16 - 1
   429                                  
   430 00000E42 0F015B0C                         lidt [rbx + 0x0c]                        ;只有在64位模式下才能加载64位线性地址部分
   431                                  
   432                                           ;初始化8259中断控制器，包括重新设置中断向量号
   433 00000E46 E874F3FFFF                       call init_8259
   434                                  
   435                                           ;创建并安装16个8259中断处理过程的中断门，向量0x20--0x2f
   436 00000E4B 498D81[590A0000]                 lea rax, [r9 + general_8259ints_handler] ;得到通用8259中断处理过程的线性地址
   437 00000E52 E8E7F2FFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   438                                  
   439 00000E57 41B820000000                     mov r8, 0x20
   440                                    .8259:
   441 00000E5D E83DF3FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   442 00000E62 49FFC0                           inc r8
   443 00000E65 4983F82F                         cmp r8, 0x2f
   444 00000E69 7EF2                             jle .8259
   445                                  
   446 00000E6B FB                               sti                                      ;开放硬件中断
   447                                  
   448                                           ;在64位模式下显示的第一条信息!
   449 00000E6C 4C8B3D(08000000)                 mov r15, [rel position]
   450 00000E73 498D9F[35010000]                 lea rbx, [r15 + welcome]
   451 00000E7A E881F1FFFF                       call put_string64                        ;位于core_utils64.wid
   452                                           ;----------------------------------------------------------------------
   453                                           ;安装系统服务所需要的代码段和栈段描述符
   454 00000E7F 4883EC10                         sub rsp, 16                              ;开辟16字节的空间操作GDT和GDTR
   455 00000E83 0F010424                         sgdt [rsp]
   456 00000E87 4831DB                           xor rbx, rbx
   457 00000E8A 668B1C24                         mov bx, [rsp]                            ;得到GDT的界限值
   458 00000E8E 66FFC3                           inc bx                                   ;得到GDT的长度（字节数）
   459 00000E91 48035C2402                       add rbx, [rsp + 2]
   460                                           ;以下，处理器不支持从64位立即数到内存之间的传送!!!
   461 00000E96 C703FFFF0000                     mov dword [rbx], 0x0000ffff
   462 00000E9C C743040092CF00                   mov dword [rbx + 4], 0x00cf9200          ;数据段描述符，DPL=00
   463 00000EA3 C7430800000000                   mov dword [rbx + 8], 0                   ;保留的描述符槽位
   464 00000EAA C7430C00000000                   mov dword [rbx + 12], 0
   465 00000EB1 C74310FFFF0000                   mov dword [rbx + 16], 0x0000ffff         ;数据段描述符，DPL=11
   466 00000EB8 C7431400F2CF00                   mov dword [rbx + 20], 0x00cff200
   467 00000EBF C74318FFFF0000                   mov dword [rbx + 24], 0x0000ffff         ;代码段描述符，DPL=11
   468 00000EC6 C7431C00F8AF00                   mov dword [rbx + 28], 0x00aff800
   469                                  
   470                                           ;安装任务状态段TSS的描述符
   471 00000ECD B968000000                       mov rcx, 104                             ;TSS的标准长度
   472 00000ED2 E88DF9FFFF                       call core_memory_allocate
   473 00000ED7 4C892D(51010000)                 mov [rel tss_ptr], r13
   474 00000EDE 4C89E8                           mov rax, r13
   475 00000EE1 E890F2FFFF                       call make_tss_descriptor
   476 00000EE6 48897320                         mov qword [rbx + 32], rsi                ;TSS描述符的低64位
   477 00000EEA 48897B28                         mov qword [rbx + 40], rdi                ;TSS描述符的高64位
   478                                  
   479 00000EEE 6683042430                       add word [rsp], 48                       ;4个段描述符和1个TSS描述符的总字节数
   480 00000EF3 0F011424                         lgdt [rsp]
   481 00000EF7 4883C410                         add rsp, 16                              ;恢复栈平衡
   482                                  
   483 00000EFB 66B94000                         mov cx, 0x0040                           ;TSS描述符的选择子
   484 00000EFF 0F00D9                           ltr cx
   485                                  
   486                                           ;为快速系统调用SYSCALL和SYSRET准备参数
   487 00000F02 B9800000C0                       mov ecx, 0x0c0000080                     ;指定型号专属寄存器IA32_EFER
   488 00000F07 0F32                             rdmsr
   489 00000F09 0FBAE800                         bts eax, 0                               ;设置SCE位，允许SYSCALL指令
   490 00000F0D 0F30                             wrmsr
   491                                  
   492 00000F0F B9810000C0                       mov ecx, 0xc0000081                      ;STAR
   493 00000F14 BA18002B00                       mov edx, (RESVD_DESC_SEL << 16) | CORE_CODE64_SEL
   494 00000F19 31C0                             xor eax, eax
   495 00000F1B 0F30                             wrmsr
   496                                  
   497 00000F1D B9820000C0                       mov ecx, 0xc0000082                      ;LSTAR
   498 00000F22 488B05(08000000)                 mov rax, [rel position]
   499 00000F29 488D80[6E0D0000]                 lea rax, [rax + syscall_procedure]       ;只用EAX部分
   500 00000F30 4889C2                           mov rdx, rax
   501 00000F33 48C1EA20                         shr rdx, 32                              ;使用EDX部分
   502 00000F37 0F30                             wrmsr
   503                                  
   504 00000F39 B9840000C0                       mov ecx, 0xc0000084                      ;FMASK
   505 00000F3E 31D2                             xor edx, edx
   506 00000F40 B800770400                       mov eax, 0x00047700                      ;要求TF=IF=DF=AC=0；IOPL=00
   507 00000F45 0F30                             wrmsr
   508                                  
   509                                           ;以下初始化高级可编程中断控制器APIC。在计算机启动后，BIOS已经对LAPIC和IOAPIC做了
   510                                           ;初始化并创建了相关的高级配置和电源管理接口（ACPI）表项。可以从中获取多处理器和
   511                                           ;APIC信息。英特尔架构的个人计算机（IA-PC）从1MB物理内存中搜索获取；启用可扩展固件
   512                                           ;接口（EFI或者叫UEFI）的计算机需使用EFI传递的EFI系统表指针定位相关表格并从中获取
   513                                           ;多处理器和APIC信息。为简单起见，我们采用前一种传统的方式。请注意虚拟机的配置！
   514                                  
   515                                           ;ACPI申领的内存区域已经保存在我们的系统数据区（SDA），以下将其读出。此内存区可能
   516                                           ;位于分页系统尚未映射的部分，故以下先将这部分内存进行一一映射（线性地址=物理地址）
   517 00000F47 66833C25167E000000               cmp word [SDA_PHY_ADDR + 0x16], 0
   518 00000F50 7411                             jz .acpi_err                             ;不正确的ACPI数据，可能不支持ACPI
   519 00000F52 BE187E0000                       mov rsi, SDA_PHY_ADDR + 0x18             ;系统数据区：地址范围描述结构的起始地址
   520                                    .looking:
   521 00000F57 837E1003                         cmp dword [rsi + 16], 3                  ;3:ACPI申领的内存（AddressRangeACPI）
   522 00000F5B 741B                             jz .looked
   523 00000F5D 4883C620                         add rsi, 32                              ;32:每个地址范围描述结构的长度
   524 00000F61 E2F4                             loop .looking
   525                                  
   526                                    .acpi_err:
   527 00000F63 4C8B3D(08000000)                 mov r15, [rel position]
   528 00000F6A 498D9F[00000000]                 lea rbx, [r15 + acpi_error]
   529 00000F71 E88AF0FFFF                       call put_string64                        ;位于core_utils64_mp.wid
   530 00000F76 FA                               cli
   531 00000F77 F4                               hlt
   532                                  
   533                                    .looked:
   534 00000F78 488B1E                           mov rbx, [rsi]                           ;ACPI申领的起始物理地址
   535 00000F7B 488B4E08                         mov rcx, [rsi + 8]                       ;ACPI申领的内存数量，以字节计
   536 00000F7F 4801D9                           add rcx, rbx                             ;ACPI申领的内存上边界
   537 00000F82 48C7C200F0FFFF                   mov rdx, 0xffff_ffff_ffff_f000           ;用于生成页地址的掩码
   538                                    .maping:
   539 00000F89 4989DD                           mov r13, rbx                             ;R13:本次映射的线性地址
   540 00000F8C 4889D8                           mov rax, rbx
   541 00000F8F 4821D0                           and rax, rdx
   542 00000F92 4883C807                         or rax, 0x07                             ;RAX:本次映射的物理地址及属性
   543 00000F96 E805F8FFFF                       call mapping_laddr_to_page
   544 00000F9B 4881C300100000                   add rbx, 0x1000
   545 00000FA2 4839CB                           cmp rbx, rcx
   546 00000FA5 7EE2                             jle .maping
   547                                  
   548                                           ;从物理地址0x60000开始，搜索根系统描述指针结构（RSDP）
   549 00000FA7 BB00000600                       mov rbx, 0x60000
   550 00000FAC 48B952534420505452-              mov rcx, 'RSD PTR '                      ;结构的起始标记（注意尾部的空格）
   550 00000FB5 20                 
   551                                    .searc:
   552 00000FB6 48390B                           cmp qword [rbx], rcx
   553 00000FB9 740F                             je .finda
   554 00000FBB 4883C310                         add rbx, 16                              ;结构的标记总是位于16字节边界处
   555 00000FBF 4881FBF0FF0F00                   cmp rbx, 0xffff0                         ;低端1MB物理内存的上边界
   556 00000FC6 7CEE                             jl .searc
   557 00000FC8 EB99                             jmp .acpi_err                            ;未找到RSDP，报错停机处理。
   558                                  
   559                                    .finda:
   560                                           ;RSDT和XSDT都指向MADT，但RSDT给出的是32位物理地址，而XDST给出64位物理地址。
   561                                           ;只有VCPI 2.0及更高版本才有XSDT。典型地，VBox支持ACPI 2.0而Bochs仅支持1.0
   562 00000FCA 807B0F02                         cmp byte [rbx + 15], 2                   ;检测ACPI的版本是否为2
   563 00000FCE 752B                             jne .acpi_1
   564 00000FD0 488B5B18                         mov rbx, [rbx + 24]                      ;得到扩展的系统描述表（XSDT）的物理地址
   565                                  
   566                                           ;以下，开始在XSDT中遍历搜索多APIC描述表（MADT）
   567 00000FD4 4831FF                           xor rdi, rdi
   568 00000FD7 8B7B04                           mov edi, [rbx + 4]                       ;获得XSDT的长度（以字节计）
   569 00000FDA 4801DF                           add rdi, rbx                             ;计算XSDT上边界的物理位置
   570 00000FDD 4883C324                         add rbx, 36                              ;XSDT尾部数组的物理位置
   571                                    .madt0:
   572 00000FE1 4C8B1B                           mov r11, [rbx]
   573 00000FE4 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   574 00000FEB 7436                             je .findm
   575 00000FED 4883C308                         add rbx, 8                               ;下一个元素
   576 00000FF1 4839FB                           cmp rbx, rdi
   577 00000FF4 7CEB                             jl .madt0
   578 00000FF6 E968FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   579                                  
   580                                           ;以下按VCPI 1.0处理，开始在RSDT中遍历搜索多APIC描述表（MADT）
   581                                    .acpi_1:
   582 00000FFB 8B5B10                           mov ebx, [rbx + 16]                      ;得到根系统描述表（RSDT）的物理地址
   583                                           ;以下，开始在RSDT中遍历搜索多APIC描述表（MADT）
   584 00000FFE 678B7B04                         mov edi, [ebx + 4]                       ;获得RSDT的长度（以字节计）
   585 00001002 01DF                             add edi, ebx                             ;计算RSDT末端的物理位置
   586 00001004 83C324                           add ebx, 36                              ;RSDT尾部数组的物理位置
   587 00001007 4D31DB                           xor r11, r11
   588                                    .madt1:
   589 0000100A 67448B1B                         mov r11d, [ebx]
   590 0000100E 41813B41504943                   cmp dword [r11], 'APIC'                  ;MADT表的标记
   591 00001015 740C                             je .findm
   592 00001017 83C304                           add ebx, 4                               ;下一个元素
   593 0000101A 39FB                             cmp ebx, edi
   594 0000101C 7CEC                             jl .madt1
   595 0000101E E940FFFFFF                       jmp .acpi_err                            ;未找到MADT，报错停机处理。
   596                                  
   597                                    .findm:
   598                                           ;此时，R11是MADT的物理地址
   599 00001023 418B5324                         mov edx, [r11 + 36]                      ;预置的LAPIC物理地址
   600 00001027 8915(28010000)                   mov [rel lapic_addr], edx
   601                                  
   602                                           ;以下开始遍历系统中的逻辑处理器（其LAPID ID）和I/O APIC。
   603 0000102D 4C8B3D(08000000)                 mov r15, [rel position]                  ;为访问cpu_list准备线性地址
   604 00001034 4D8DBF[28000000]                 lea r15, [r15 + cpu_list]
   605                                  
   606 0000103B 4831FF                           xor rdi, rdi
   607 0000103E 418B7B04                         mov edi, [r11 + 4]                       ;EDI:MADT的长度，以字节计
   608 00001042 4C01DF                           add rdi, r11                             ;RDI:MADT尾部边界的物理地址
   609 00001045 4983C32C                         add r11, 44                              ;R11:指向MADT尾部的中断控制器结构列表
   610                                    .enumd:
   611 00001049 41803B00                         cmp byte [r11], 0                        ;列表项类型：Processor Local APIC
   612 0000104D 7408                             je .l_apic
   613 0000104F 41803B01                         cmp byte [r11], 1                        ;列表项类型：I/O APIC
   614 00001053 741B                             je .ioapic
   615 00001055 EB2D                             jmp .m_end
   616                                    .l_apic:
   617 00001057 41837B0400                       cmp dword [r11 + 4], 0                   ;Local APIC Flags
   618 0000105C 7426                             jz .m_end
   619 0000105E 418A4303                         mov al, [r11 + 3]                        ;local APIC ID
   620 00001062 418807                           mov [r15], al                            ;保存local APIC ID到cpu_list
   621 00001065 49FFC7                           inc r15
   622 00001068 FE05(27000000)                   inc byte [rel num_cpus]                  ;可用的CPU数量递增
   623 0000106E EB14                             jmp .m_end
   624                                    .ioapic:
   625 00001070 418A4302                         mov al, [r11 + 2]                        ;取出I/O APIC ID
   626 00001074 8805(30010000)                   mov [rel ioapic_id], al                  ;保存I/O APIC ID
   627 0000107A 418B4304                         mov eax, [r11 + 4]                       ;取出I/O APIC物理地址
   628 0000107E 8905(2C010000)                   mov [rel ioapic_addr], eax               ;保存I/O APIC物理地址
   629                                     .m_end:
   630 00001084 4831C0                           xor rax, rax
   631 00001087 418A4301                         mov al, [r11 + 1]
   632 0000108B 4901C3                           add r11, rax                             ;计算下一个中断控制器结构列表项的地址
   633 0000108E 4939FB                           cmp r11, rdi
   634 00001091 7CB6                             jl .enumd
   635                                  
   636                                           ;将Local APIC的物理地址映射到预定义的线性地址LAPIC_START_ADDR
   637 00001093 49BD00E0FFFF7FFFFF-              mov r13, LAPIC_START_ADDR                ;在global_defs.wid中定义
   637 0000109C FF                 
   638 0000109D 4831C0                           xor rax, rax
   639 000010A0 8B05(28010000)                   mov eax, [rel lapic_addr]                ;取出LAPIC的物理地址
   640 000010A6 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   641 000010A9 E8F2F6FFFF                       call mapping_laddr_to_page
   642                                  
   643                                           ;将I/O APIC的物理地址映射到预定义的线性地址IOAPIC_START_ADDR
   644 000010AE 49BD00D0FFFF7FFFFF-              mov r13, IOAPIC_START_ADDR               ;在global_defs.wid中定义
   644 000010B7 FF                 
   645 000010B8 4831C0                           xor rax, rax
   646 000010BB 8B05(2C010000)                   mov eax, [rel ioapic_addr]               ;取出I/O APIC的物理地址
   647 000010C1 83C81F                           or eax, 0x1f                             ;PCD=PWT=U/S=R/W=P=1，强不可缓存
   648 000010C4 E8D7F6FFFF                       call mapping_laddr_to_page
   649                                  
   650                                           ;以下测量当前处理器在1毫秒的时间里经历多少时钟周期，作为后续的定时基准。
   651 000010C9 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   651 000010D2 FF                 
   652                                  
   653 000010D3 C78620030000000001-              mov dword [rsi + 0x320], 0x10000         ;定时器的本地向量表入口寄存器。单次击发（one shot）模式
   653 000010DC 00                 
   654 000010DD C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;定时器的分频配置寄存器：1分频（不分频）
   654 000010E6 00                 
   655                                  
   656 000010E7 B00B                             mov al, 0x0b                             ;RTC寄存器B
   657 000010E9 0C80                             or al, 0x80                              ;阻断NMI
   658 000010EB E670                             out 0x70, al
   659 000010ED B052                             mov al, 0x52                             ;设置寄存器B，开放周期性中断，开放更
   660 000010EF E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   661                                  
   662 000010F1 B08A                             mov al, 0x8a                             ;CMOS寄存器A
   663 000010F3 E670                             out 0x70, al
   664                                           ;in al, 0x71
   665 000010F5 B02D                             mov al, 0x2d                             ;32kHz，125ms的周期性中断
   666 000010F7 E671                             out 0x71, al                             ;写回CMOS寄存器A
   667                                  
   668 000010F9 B08C                             mov al, 0x8c
   669 000010FB E670                             out 0x70, al
   670 000010FD E471                             in al, 0x71                              ;读寄存器C
   671                                    .w0:
   672 000010FF E471                             in al, 0x71                              ;读寄存器C
   673 00001101 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   674 00001106 73F7                             jnc .w0
   675 00001108 C78680030000FFFFFF-              mov dword [rsi + 0x380], 0xffff_ffff     ;定时器初始计数寄存器：置初值并开始计数
   675 00001111 FF                 
   676                                    .w1:
   677 00001112 E471                             in al, 0x71                              ;读寄存器C
   678 00001114 480FBAE006                       bt rax, 6                                ;更新周期结束中断已发生？
   679 00001119 73F7                             jnc .w1
   680 0000111B 8B9690030000                     mov edx, [rsi + 0x390]                   ;定时器当前计数寄存器：读当前计数值
   681                                  
   682 00001121 B8FFFFFFFF                       mov eax, 0xffff_ffff
   683 00001126 29D0                             sub eax, edx
   684 00001128 31D2                             xor edx, edx
   685 0000112A BB7D000000                       mov ebx, 125                             ;125毫秒
   686 0000112F F7F3                             div ebx                                  ;EAX=当前处理器在1ms内的时钟数
   687                                  
   688 00001131 8905(31010000)                   mov [rel clocks_1ms], eax                ;登记起来用于其它定时的场合
   689                                  
   690 00001137 B00B                             mov al, 0x0b                             ;RTC寄存器B
   691 00001139 0C80                             or al, 0x80                              ;阻断NMI
   692 0000113B E670                             out 0x70, al
   693 0000113D B012                             mov al, 0x12                             ;设置寄存器B，只允许更新周期结束中断
   694 0000113F E671                             out 0x71, al
   695                                  
   696                                           ;以下安装用于任务切换的中断处理过程
   697 00001141 4C8B0D(08000000)                 mov r9, [rel position]
   698 00001148 498D81[630A0000]                 lea rax, [r9 + rtm_interrupt_handle]     ;得到中断处理过程的线性地址
   699 0000114F E8EAEFFFFF                       call make_interrupt_gate                 ;位于core_utils64.wid
   700                                  
   701 00001154 FA                               cli
   702                                  
   703 00001155 41B828000000                     mov r8, 0x28                             ;任务切换使用的中断向量
   704 0000115B E83FF0FFFF                       call mount_idt_entry                     ;位于core_utils64.wid
   705                                  
   706                                           ;设置和时钟中断相关的硬件
   707 00001160 B00B                             mov al, 0x0b                             ;RTC寄存器B
   708 00001162 0C80                             or al, 0x80                              ;阻断NMI
   709 00001164 E670                             out 0x70, al
   710 00001166 B012                             mov al, 0x12                             ;设置寄存器B，禁止周期性中断，开放更
   711 00001168 E671                             out 0x71, al                             ;新结束后中断，BCD码，24小时制
   712                                  
   713 0000116A E4A1                             in al, 0xa1                              ;读8259从片的IMR寄存器
   714 0000116C 24FE                             and al, 0xfe                             ;清除bit 0(此位连接RTC)
   715 0000116E E6A1                             out 0xa1, al                             ;写回此寄存器
   716                                  
   717 00001170 FB                               sti
   718                                  
   719 00001171 B00C                             mov al, 0x0c
   720 00001173 E670                             out 0x70, al
   721 00001175 E471                             in al, 0x71                              ;读RTC寄存器C，复位未决的中断状态
   722                                  
   723                                           ;计算机启动后，默认使用经由LINT0的虚拟线模式。所以，第6章实际上工作在这种模式下。
   724                                           ;LVT LINT0寄存器的默认值：0x700，不屏蔽LINT0，ExtINT投递模式
   725                                           ;LVT LINT1寄存器的默认值：0x400，不屏蔽LINT1，NMI投递模式
   726                                  
   727                                  
   728                                           ;如果不使用8259A PIC，直接使用I/O APIC，则应当屏蔽LVT LINT0或者8259A PIC的输入。
   729                                           ;以下两种方式可以选择一种即可。建议选择第二种，即，屏蔽8259A的全部中断输入。
   730                                           ;mov rsi, LAPIC_START_ADDR
   731                                           ;mov dword [rsi + 0x350], 0x10000         ;屏蔽LINT0的中断信号
   732                                  
   733 00001177 B0FF                             mov al, 0xff                             ;屏蔽所有发往8259A主芯片的中断信号
   734 00001179 E621                             out 0x21, al                             ;多处理器环境下不再使用8259芯片
   735                                  
   736                                  
   737 0000117B 48BF00D0FFFF7FFFFF-              mov rdi, IOAPIC_START_ADDR               ;I/O APIC的线性地址
   737 00001184 FF                 
   738                                  
   739                                           ;根据图纸可知，若选择RTC定时器，需要设置I/O APIC的I/O重定向表寄存器8（IOREDTBL8）
   740                                           ;mov dword [rdi], 0x20                    ;对应RTC。
   741                                           ;mov dword [rdi + 0x10], 0x00000028       ;不屏蔽；物理模式；固定模式；向量0x28
   742                                           ;mov dword [rdi], 0x21
   743                                           ;mov dword [rdi + 0x10], 0x00000000       ;Local APIC ID：0
   744                                  
   745                                           ;如果想加快任务切换速度，可选择8254定时器。对应I/O APIC的IOREDTBL2
   746                                           ;mov dword [rdi], 0x14                    ;对应8254定时器。
   747                                           ;mov dword [rdi + 0x10], 0x00000028       ;不屏蔽；物理模式；固定模式；向量0x28
   748                                           ;mov dword [rdi], 0x15
   749                                           ;mov dword [rdi + 0x10], 0x00000000       ;Local APIC ID：0
   750                                  
   751                                  
   752                                           ;也可以使用Local APIC内部的定时器，更加灵活。
   753 00001185 8B05(31010000)                   mov eax, [rel clocks_1ms]
   754 0000118B BBB80B0000                       mov ebx, 3000
   755 00001190 F7E3                             mul ebx
   756 00001192 48BE00E0FFFF7FFFFF-              mov rsi, LAPIC_START_ADDR                ;Local APIC的线性地址
   756 0000119B FF                 
   757 0000119C C786E00300000B0000-              mov dword [rsi + 0x3e0], 0x0b            ;1分频（不分频）
   757 000011A5 00                 
   758 000011A6 C78620030000280002-              mov dword [rsi + 0x320], 0x20028         ;周期性模式；固定模式；中断向量：0x28
   758 000011AF 00                 
   759 000011B0 898680030000                     mov dword [rsi + 0x380], eax             ;初始计数值
   760                                  
   761                                           ;以下开始创建系统外壳任务（进程）
   762 000011B6 41B832000000                     mov r8, 50
   763 000011BC E884FAFFFF                       call create_process
   764                                  
   765 000011C1 488B1D(89010000)                 mov rbx, [rel pcb_ptr]                   ;得到外壳任务PCB的线性地址
   766 000011C8 488B4338                         mov rax, [rbx + 56]                      ;从PCB中取出CR3
   767 000011CC 0F22D8                           mov cr3, rax                             ;切换到新进程的地址空间
   768                                  
   769 000011CF 48891D(91010000)                 mov [rel cur_pcb], rbx                   ;设置当前任务的PCB。
   770 000011D6 48C7431001000000                 mov qword [rbx + 16], 1                  ;设置任务状态为“忙”。
   771                                  
   772 000011DE 488B4320                         mov rax, [rbx + 32]                      ;从PCB中取出RSP0
   773 000011E2 488B15(51010000)                 mov rdx, [rel tss_ptr]                   ;得到TSS的线性地址
   774 000011E9 48894204                         mov [rdx + 4], rax                       ;在TSS中填写RSP0
   775                                  
   776 000011ED FFB3D0000000                     push qword [rbx + 208]                   ;用户程序的SS
   777 000011F3 FF7378                           push qword [rbx + 120]                   ;用户程序的RSP
   778 000011F6 9C                               pushfq
   779 000011F7 FFB3C8000000                     push qword [rbx + 200]                   ;用户程序的CS
   780 000011FD FFB3C0000000                     push qword [rbx + 192]                   ;用户程序的RIP
   781                                  
   782 00001203 48CF                             iretq                                    ;返回当前任务的私有空间执行
   783                                  
   784                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   785                                  core_end:
