     1                                  ;文件core_utils64.wid是供64位内核使用的函数集。
     2                                  ;创建时间：2021-11-07 10:15，李忠
     3                                  ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，
     4                                  ;方便内核代码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
     5                                  ;2022-5-5：在例程mapping_laddr_to_page和setup_paging_for_laddr中用到了RCX，但未
     6                                  ;予以保存和恢复，已经修正。
     7                                  
     8                                  %include "..\common\global_defs.wid"
     9                              <1> ;系统全局使用的常量定义，2021-09-05
    10                              <1> 
    11                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    12                              <1> 
    13                              <1> %ifndef _GLOBAL_DEFS_
    14                              <1>    %define _GLOBAL_DEFS_
    15                              <1> 
    16                              <1>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    17                              <1>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    18                              <1>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    19                              <1>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    20                              <1>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    21                              <1>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    22                              <1>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    23                              <1>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    24                              <1>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    25                              <1>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    26                              <1>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    27                              <1> 
    28                              <1>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    29                              <1>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    30                              <1> 
    31                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    32                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    33                              <1> 
    34                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    35                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    36                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    37                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    38                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    39                              <1> 
    40                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    41                              <1>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    42                              <1>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    43                              <1>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    44                              <1>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    45                              <1>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    46                              <1> 
    47                              <1>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    48                              <1>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    49                              <1>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    50                              <1> 
    51                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并对这个页做初始化操作，这需要一个线性地址
    52                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    53                              <1> 
    54                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    55                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    56                              <1> 
    57                              <1>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    58                              <1> 
    59                              <1>    SUGG_PREEM_SLICE    equ     50                      ;推荐的任务/线程抢占时间片长度（毫秒）
    60                              <1> 
    61                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    62                              <1>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
    63                              <1>             %%spin_lock:
    64                              <1>                        cmp %2, 0                       ;锁是释放状态吗？
    65                              <1>                        je %%get_lock                   ;获取锁
    66                              <1>                        pause
    67                              <1>                        jmp %%spin_lock                 ;继续尝试获取锁
    68                              <1>             %%get_lock:
    69                              <1>                        mov %1, 1
    70                              <1>                        xchg %1, %2
    71                              <1>                        cmp %1, 0                       ;交换前为零？
    72                              <1>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
    73                              <1>    %endmacro
    74                              <1> 
    75                              <1> %endif
     9                                  
    10                                           bits 64
    11                                  
    12                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    13                                  put_string64:                                     ;显示0终止的字符串并移动光标
    14                                                                                    ;输入：RBX=字符串的线性地址
    15 00000000 FA                               cli
    16                                  
    17 00000001 53                               push rbx
    18 00000002 51                               push rcx
    19                                  
    20                                    .getc:
    21 00000003 8A0B                             mov cl, [rbx]
    22 00000005 08C9                             or cl, cl                                ;检测串结束标志（0）
    23 00000007 740A                             jz .exit                                 ;显示完毕，返回
    24 00000009 E809000000                       call put_char
    25 0000000E 48FFC3                           inc rbx
    26 00000011 EBF0                             jmp .getc
    27                                  
    28                                    .exit:
    29 00000013 59                               pop rcx
    30 00000014 5B                               pop rbx
    31                                  
    32 00000015 FB                               sti
    33                                  
    34 00000016 C3                               ret                                      ;段内返回
    35                                  
    36                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    37                                  put_char:                                         ;在当前光标处显示一个字符,并推进
    38                                                                                    ;光标。
    39                                                                                    ;输入：CL=字符ASCII码
    40 00000017 50                               push rax
    41 00000018 53                               push rbx
    42 00000019 51                               push rcx
    43 0000001A 52                               push rdx
    44 0000001B 56                               push rsi
    45 0000001C 57                               push rdi
    46                                  
    47                                           ;以下取当前光标位置
    48 0000001D 66BAD403                         mov dx, 0x3d4
    49 00000021 B00E                             mov al, 0x0e
    50 00000023 EE                               out dx, al
    51 00000024 66FFC2                           inc dx                                   ;0x3d5
    52 00000027 EC                               in al, dx                                ;高字
    53 00000028 88C4                             mov ah, al
    54                                  
    55 0000002A 66FFCA                           dec dx                                   ;0x3d4
    56 0000002D B00F                             mov al, 0x0f
    57 0000002F EE                               out dx, al
    58 00000030 66FFC2                           inc dx                                   ;0x3d5
    59 00000033 EC                               in al, dx                                ;低字
    60 00000034 6689C3                           mov bx, ax                               ;BX=代表光标位置的16位数
    61 00000037 4881E3FFFF0000                   and rbx, 0x000000000000ffff              ;准备使用64位寻址方式访问显存
    62                                  
    63 0000003E 80F90D                           cmp cl, 0x0d                             ;回车符？
    64 00000041 750E                             jnz .put_0a
    65 00000043 6689D8                           mov ax, bx
    66 00000046 B350                             mov bl, 80
    67 00000048 F6F3                             div bl
    68 0000004A F6E3                             mul bl
    69 0000004C 6689C3                           mov bx, ax
    70 0000004F EB6C                             jmp .set_cursor
    71                                  
    72                                    .put_0a:
    73 00000051 80F90A                           cmp cl, 0x0a                             ;换行符？
    74 00000054 7506                             jnz .put_other
    75 00000056 6683C350                         add bx, 80
    76 0000005A EB16                             jmp .roll_screen
    77                                  
    78                                    .put_other:                                     ;正常显示字符
    79 0000005C 66D1E3                           shl bx, 1
    80 0000005F 48B800800B000080FF-              mov rax, UPPER_TEXT_VIDEO                ;在global_defs.wid中定义
    80 00000068 FF                 
    81 00000069 880C18                           mov [rax + rbx], cl
    82                                  
    83                                           ;以下将光标位置推进一个字符
    84 0000006C 66D1EB                           shr bx, 1
    85 0000006F 66FFC3                           inc bx
    86                                  
    87                                    .roll_screen:
    88 00000072 6681FBD007                       cmp bx, 2000                             ;光标超出屏幕？滚屏
    89 00000077 7C44                             jl .set_cursor
    90                                  
    91 00000079 6653                             push bx
    92                                  
    93 0000007B FC                               cld
    94 0000007C 48BEA0800B000080FF-              mov rsi, UPPER_TEXT_VIDEO + 0xa0         ;小心！64位模式下movsq
    94 00000085 FF                 
    95 00000086 48BF00800B000080FF-              mov rdi, UPPER_TEXT_VIDEO                ;使用的是rsi/rdi/rcx
    95 0000008F FF                 
    96 00000090 B9E0010000                       mov rcx, 480
    97 00000095 F348A5                           rep movsq
    98 00000098 66BB000F                         mov bx, 3840                             ;清除屏幕最底一行
    99 0000009C B950000000                       mov rcx, 80                              ;64位程序应该使用RCX
   100                                    .cls:
   101 000000A1 48B800800B000080FF-              mov rax, UPPER_TEXT_VIDEO
   101 000000AA FF                 
   102 000000AB 66C704182007                     mov word[rax + rbx], 0x0720
   103 000000B1 6683C302                         add bx, 2
   104 000000B5 E2EA                             loop .cls
   105                                  
   106 000000B7 665B                             pop bx
   107 000000B9 6683EB50                         sub bx, 80
   108                                  
   109                                    .set_cursor:
   110 000000BD 66BAD403                         mov dx, 0x3d4
   111 000000C1 B00E                             mov al, 0x0e
   112 000000C3 EE                               out dx, al
   113 000000C4 66FFC2                           inc dx                                   ;0x3d5
   114 000000C7 88F8                             mov al, bh
   115 000000C9 EE                               out dx, al
   116 000000CA 66FFCA                           dec dx                                   ;0x3d4
   117 000000CD B00F                             mov al, 0x0f
   118 000000CF EE                               out dx, al
   119 000000D0 66FFC2                           inc dx                                   ;0x3d5
   120 000000D3 88D8                             mov al, bl
   121 000000D5 EE                               out dx, al
   122                                  
   123 000000D6 5F                               pop rdi
   124 000000D7 5E                               pop rsi
   125 000000D8 5A                               pop rdx
   126 000000D9 59                               pop rcx
   127 000000DA 5B                               pop rbx
   128 000000DB 58                               pop rax
   129                                  
   130 000000DC C3                               ret
   131                                  
   132                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   133                                  ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符
   134                                  put_cstringxy64:                                  ;输入：RBX=字符串首地址
   135                                                                                    ;DH=行，DL=列
   136                                                                                    ;R9B=颜色属性
   137 000000DD FA                               cli
   138                                  
   139 000000DE 50                               push rax
   140 000000DF 53                               push rbx
   141 000000E0 51                               push rcx
   142 000000E1 52                               push rdx
   143 000000E2 4150                             push r8
   144                                  
   145                                           ;指定坐标位置在显存内的偏移量
   146 000000E4 88F0                             mov al, dh
   147 000000E6 B5A0                             mov ch, 160                              ;每一行80个字符，占用160个字节
   148 000000E8 F6E5                             mul ch
   149 000000EA D0E2                             shl dl, 1                                ;每个字符（列）占用2个字节，要乘以2
   150 000000EC 6681E2FF00                       and dx, 0x00ff
   151 000000F1 6601D0                           add ax, dx                               ;得到指定坐标位置在显存内的偏移量
   152 000000F4 4825FFFF0000                     and rax, 0x000000000000ffff
   153                                  
   154 000000FA 49B800800B000080FF-              mov r8, UPPER_TEXT_VIDEO                 ;显存的起始线性地址
   154 00000103 FF                 
   155                                    .nextc:
   156 00000104 8A13                             mov dl, [rbx]                            ;取得将要显示的字符
   157 00000106 08D2                             or dl, dl
   158 00000108 7412                             jz .exit
   159 0000010A 41881400                         mov byte [r8 + rax], dl
   160 0000010E 45884C0001                       mov byte [r8 + rax + 1], r9b             ;字符颜色
   161 00000113 48FFC3                           inc rbx
   162 00000116 4883C002                         add rax, 2                               ;增加一个字符的位置（2个字节）
   163 0000011A EBE8                             jmp .nextc
   164                                    .exit:
   165 0000011C 4158                             pop r8
   166 0000011E 5A                               pop rdx
   167 0000011F 59                               pop rcx
   168 00000120 5B                               pop rbx
   169 00000121 58                               pop rax
   170                                  
   171 00000122 FB                               sti
   172                                  
   173 00000123 C3                               ret
   174                                  
   175                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   176                                  make_call_gate:                                   ;创建64位的调用门
   177                                                                                    ;输入：RAX=例程的线性地址
   178                                                                                    ;输出：RDI:RSI=调用门
   179 00000124 4889C7                           mov rdi, rax
   180 00000127 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   181                                  
   182 0000012B 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   183 0000012C 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   184 00000133 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   185 00000137 66C7442404008C                   mov word [rsp + 4], 0x8c00               ;添加P=1，TYPE=64位调用门
   186 0000013E 5E                               pop rsi
   187                                  
   188 0000013F C3                               ret
   189                                  
   190                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   191                                  make_interrupt_gate:                              ;创建64位的中断门
   192                                                                                    ;输入：RAX=例程的线性地址
   193                                                                                    ;输出：RDI:RSI=中断门
   194 00000140 4889C7                           mov rdi, rax
   195 00000143 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   196                                  
   197 00000147 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   198 00000148 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   199 0000014F 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   200 00000153 66C7442404008E                   mov word [rsp + 4], 0x8e00               ;添加P=1，TYPE=64位中断门
   201 0000015A 5E                               pop rsi
   202                                  
   203 0000015B C3                               ret
   204                                  
   205                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   206                                  make_trap_gate:                                   ;创建64位的陷阱门
   207                                                                                    ;输入：RAX=例程的线性地址
   208                                                                                    ;输出：RDI:RSI=陷阱门
   209 0000015C 4889C7                           mov rdi, rax
   210 0000015F 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   211                                  
   212 00000163 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   213 00000164 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   214 0000016B 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   215 0000016F 66C7442404008F                   mov word [rsp + 4], 0x8f00               ;添加P=1，TYPE=64位陷阱门
   216 00000176 5E                               pop rsi
   217                                  
   218 00000177 C3                               ret
   219                                  
   220                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   221                                  make_tss_descriptor:                              ;创建64位的TSS描述符
   222                                                                                    ;输入：RAX=TSS的线性地址
   223                                                                                    ;输出：RDI:RSI=TSS描述符
   224 00000178 50                               push rax
   225                                  
   226 00000179 4889C7                           mov rdi, rax
   227 0000017C 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   228                                  
   229 00000180 50                               push rax                                 ;先将部分线性地址移到适当位置
   230 00000181 48C1242410                       shl qword [rsp], 16                      ;将线性地址的位23~00移到正确位置
   231 00000186 66C704246800                     mov word [rsp], 104                      ;段界限的标准长度
   232 0000018C 8A442405                         mov al, [rsp + 5]
   233 00000190 88442407                         mov [rsp + 7], al                        ;将线性地址的位31~24移到正确位置
   234 00000194 C644240589                       mov byte [rsp + 5], 0x89                 ;P=1，DPL=00，TYPE=1001（64位TSS）
   235 00000199 C644240600                       mov byte [rsp + 6], 0                    ;G、0、0、AVL和limit
   236 0000019E 5E                               pop rsi                                  ;门的低64位
   237                                  
   238 0000019F 58                               pop rax
   239                                  
   240 000001A0 C3                               ret
   241                                  
   242                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   243                                  mount_idt_entry:                                  ;在中断描述符表IDT中安装门描述符
   244                                                                                    ;R8=中断向量
   245                                                                                    ;RDI:RSI=门描述符
   246 000001A1 4150                             push r8
   247 000001A3 4151                             push r9
   248                                  
   249 000001A5 49C1E004                         shl r8, 4                                ;中断号乘以16，得到表内偏移
   250 000001A9 49B900E000000080FF-              mov r9, UPPER_IDT_LINEAR                 ;中断描述符表的高端线性地址
   250 000001B2 FF                 
   251 000001B3 4B893401                         mov [r9 + r8], rsi
   252 000001B7 4B897C0108                       mov [r9 + r8 + 8], rdi
   253                                  
   254 000001BC 4159                             pop r9
   255 000001BE 4158                             pop r8
   256                                  
   257 000001C0 C3                               ret
   258                                  
   259                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   260                                  init_8259:                                        ;初始化8259中断控制器，包括重新设置向量号
   261 000001C1 50                               push rax
   262                                  
   263 000001C2 B011                             mov al, 0x11
   264 000001C4 E620                             out 0x20, al                             ;ICW1：边沿触发/级联方式
   265 000001C6 B020                             mov al, 0x20
   266 000001C8 E621                             out 0x21, al                             ;ICW2:起始中断向量（避开前31个异常的向量）
   267 000001CA B004                             mov al, 0x04
   268 000001CC E621                             out 0x21, al                             ;ICW3:从片级联到IR2
   269 000001CE B001                             mov al, 0x01
   270 000001D0 E621                             out 0x21, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   271                                  
   272 000001D2 B011                             mov al, 0x11
   273 000001D4 E6A0                             out 0xa0, al                             ;ICW1：边沿触发/级联方式
   274 000001D6 B028                             mov al, 0x28
   275 000001D8 E6A1                             out 0xa1, al                             ;ICW2:起始中断向量-->0x28
   276 000001DA B002                             mov al, 0x02
   277 000001DC E6A1                             out 0xa1, al                             ;ICW3:从片识别标志，级联到主片IR2
   278 000001DE B001                             mov al, 0x01
   279 000001E0 E6A1                             out 0xa1, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   280                                  
   281 000001E2 58                               pop rax
   282 000001E3 C3                               ret
   283                                  
   284                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   285                                  read_hard_disk_0:                                 ;从硬盘读取一个逻辑扇区
   286                                                                                    ;RAX=逻辑扇区号
   287                                                                                    ;RBX=目标缓冲区线性地址
   288                                                                                    ;返回：RBX=RBX+512
   289 000001E4 FA                               cli
   290                                  
   291 000001E5 50                               push rax
   292 000001E6 51                               push rcx
   293 000001E7 52                               push rdx
   294                                  
   295 000001E8 50                               push rax
   296                                  
   297 000001E9 66BAF201                         mov dx, 0x1f2
   298 000001ED B001                             mov al, 1
   299 000001EF EE                               out dx, al                               ;读取的扇区数
   300                                  
   301 000001F0 66FFC2                           inc dx                                   ;0x1f3
   302 000001F3 58                               pop rax
   303 000001F4 EE                               out dx, al                               ;LBA地址7~0
   304                                  
   305 000001F5 66FFC2                           inc dx                                   ;0x1f4
   306 000001F8 B108                             mov cl, 8
   307 000001FA 48D3E8                           shr rax, cl
   308 000001FD EE                               out dx, al                               ;LBA地址15~8
   309                                  
   310 000001FE 66FFC2                           inc dx                                   ;0x1f5
   311 00000201 48D3E8                           shr rax, cl
   312 00000204 EE                               out dx, al                               ;LBA地址23~16
   313                                  
   314 00000205 66FFC2                           inc dx                                   ;0x1f6
   315 00000208 48D3E8                           shr rax, cl
   316 0000020B 0CE0                             or al, 0xe0                              ;第一硬盘  LBA地址27~24
   317 0000020D EE                               out dx, al
   318                                  
   319 0000020E 66FFC2                           inc dx                                   ;0x1f7
   320 00000211 B020                             mov al, 0x20                             ;读命令
   321 00000213 EE                               out dx, al
   322                                  
   323                                    .waits:
   324 00000214 EC                               in al, dx
   325 00000215 2488                             and al, 0x88
   326 00000217 3C08                             cmp al, 0x08
   327 00000219 75F9                             jnz .waits                               ;不忙，且硬盘已准备好数据传输
   328                                  
   329 0000021B B900010000                       mov rcx, 256                             ;总共要读取的字数
   330 00000220 66BAF001                         mov dx, 0x1f0
   331                                    .readw:
   332 00000224 66ED                             in ax, dx
   333 00000226 668903                           mov [rbx], ax
   334 00000229 4883C302                         add rbx, 2
   335 0000022D E2F5                             loop .readw
   336                                  
   337 0000022F 5A                               pop rdx
   338 00000230 59                               pop rcx
   339 00000231 58                               pop rax
   340                                  
   341 00000232 FB                               sti
   342 00000233 C3                               ret
   343                                  
   344                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   345 00000234 FF<rep 40h>               _page_bit_map times 2*1024/4/8 db 0xff          ;对应物理内存的前512个页面（2MB）
   346 00000274 00<rep 3C0h>                      times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 ;对应后续的页面
   347                                    _page_map_len  equ $ - _page_bit_map
   348                                  
   349                                  allocate_a_4k_page:                               ;分配一个4KB的页
   350                                                                                    ;输入：无
   351                                                                                    ;输出：RAX=页的物理地址
   352 00000634 4831C0                           xor rax, rax
   353                                    .b1:
   354 00000637 480FAB05F5FBFFFF                 bts [rel _page_bit_map], rax
   355 0000063F 730B                             jnc .b2
   356 00000641 48FFC0                           inc rax
   357 00000644 483D00200000                     cmp rax, _page_map_len * 8               ;立即数符号扩展到64位进行比较
   358 0000064A 7CEB                             jl .b1
   359                                  
   360                                           ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的
   361                                           ;系统来说，如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注
   362                                           ;销的页面，或者执行页面的换入和换出。
   363                                  
   364                                    .b2:
   365 0000064C 48C1E00C                         shl rax, 12                              ;乘以4096（0x1000）
   366                                  
   367 00000650 C3                               ret
   368                                  
   369                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   370                                  lin_to_lin_of_pml4e:                              ;返回指定的线性地址所对应的4级头表项的线性地址
   371                                                                                    ;输入：R13=线性地址
   372                                                                                    ;输出：R14=对应的4级头表项的线性地址
   373 00000651 4155                             push r13
   374                                  
   375 00000653 49BE0000000080FF00-              mov r14, 0x0000_ff80_0000_0000           ;保留4级头表索引部分
   375 0000065C 00                 
   376 0000065D 4D21F5                           and r13, r14
   377 00000660 49C1ED24                         shr r13, 36                              ;原4级头表索引变成页内偏移
   378                                  
   379 00000664 49C7C600F0FFFF                   mov r14, 0xffff_ffff_ffff_f000           ;访问4级头表所用的地址前缀
   380 0000066B 4D01EE                           add r14, r13
   381                                  
   382 0000066E 415D                             pop r13
   383                                  
   384 00000670 C3                               ret
   385                                  
   386                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   387                                  lin_to_lin_of_pdpte:                              ;返回指定的线性地址所对应的页目录指针项的线性地址
   388                                                                                    ;输入：R13=线性地址
   389                                                                                    ;输出：R14=对应的页目录指针项的线性地址
   390 00000671 4155                             push r13
   391                                  
   392 00000673 49BE000000C0FFFF00-              mov r14, 0x0000_ffff_c000_0000           ;保留4级头表索引和页目录指针表索引部分
   392 0000067C 00                 
   393 0000067D 4D21F5                           and r13, r14
   394 00000680 49C1ED1B                         shr r13, 27                              ;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   395                                  
   396 00000684 49C7C60000E0FF                   mov r14, 0xffff_ffff_ffe0_0000           ;访问页目录指针表所用的地址前缀
   397 0000068B 4D01EE                           add r14, r13
   398                                  
   399 0000068E 415D                             pop r13
   400                                  
   401 00000690 C3                               ret
   402                                  
   403                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   404                                  lin_to_lin_of_pdte:                               ;返回指定的线性地址所对应的页目录项的线性地址
   405                                                                                    ;输入：R13=线性地址
   406                                                                                    ;输出：R14=对应的页目录项的线性地址
   407 00000691 4155                             push r13
   408                                  
   409 00000693 49BE0000E0FFFFFF00-              mov r14, 0x0000_ffff_ffe0_0000           ;保留4级头表索引、页目录指针表索引和页目录表索引部分
   409 0000069C 00                 
   410 0000069D 4D21F5                           and r13, r14
   411 000006A0 49C1ED12                         shr r13, 18                              ;原4级头表索引变成页目录表索引，原页目录指针表索引变
   412                                                                                    ;页表索引，原页目录表索引变页内偏移
   413 000006A4 49C7C6000000C0                   mov r14, 0xffff_ffff_c000_0000           ;访问页目录表所用的地址前缀
   414 000006AB 4D01EE                           add r14, r13
   415                                  
   416 000006AE 415D                             pop r13
   417                                  
   418 000006B0 C3                               ret
   419                                  
   420                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   421                                  lin_to_lin_of_pte:                                ;返回指定的线性地址所对应的页表项的线性地址
   422                                                                                    ;输入：R13=线性地址
   423                                                                                    ;输出：R14=对应的页表项的线性地址
   424 000006B1 4155                             push r13
   425                                  
   426 000006B3 49BE00F0FFFFFFFF00-              mov r14, 0x0000_ffff_ffff_f000           ;保留4级头表、页目录指针表、页目录表和页表的索引部分
   426 000006BC 00                 
   427 000006BD 4D21F5                           and r13, r14
   428 000006C0 49C1ED09                         shr r13, 9                               ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   429                                                                                    ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   430 000006C4 49BE0000000080FFFF-              mov r14, 0xffff_ff80_0000_0000           ;访问页表所用的地址前缀
   430 000006CD FF                 
   431 000006CE 4D01EE                           add r14, r13
   432                                  
   433 000006D1 415D                             pop r13
   434                                  
   435 000006D3 C3                               ret
   436                                  
   437                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   438                                  setup_paging_for_laddr:                           ;为指定的线性地址安装分页系统（表项）
   439                                                                                    ;输入：R13=线性地址
   440 000006D4 51                               push rcx
   441 000006D5 50                               push rax
   442 000006D6 4156                             push r14
   443                                  
   444                                           ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   445                                           ;检查该线性地址所对应的4级头表项是否存在
   446 000006D8 E874FFFFFF                       call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   447 000006DD 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   448 000006E4 752B                             jnz .b0
   449                                  
   450                                           ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   451 000006E6 E849FFFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   452 000006EB 4883C807                         or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   453 000006EF 498906                           mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   454                                  
   455                                           ;清空刚分配的页目录指针表
   456 000006F2 E87AFFFFFF                       call lin_to_lin_of_pdpte
   457 000006F7 49C1EE0C                         shr r14, 12
   458 000006FB 49C1E60C                         shl r14, 12                              ;得到页目录指针表的线性地址
   459 000006FF B900020000                       mov rcx, 512
   460                                    .cls0:
   461 00000704 49C70600000000                   mov qword [r14], 0
   462 0000070B 4983C608                         add r14, 8
   463 0000070F E2F3                             loop .cls0
   464                                  ;-------------------------------------------------
   465                                    .b0:
   466                                           ;检查该线性地址所对应的页目录指针项是否存在
   467 00000711 E85BFFFFFF                       call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   468 00000716 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   469 0000071D 752B                             jnz .b1                                  ;页目录指针项是存在的，转.b1
   470                                  
   471                                           ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   472 0000071F E810FFFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录表
   473 00000724 4883C807                         or rax, 0x07                             ;添加属性位
   474 00000728 498906                           mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   475                                  
   476                                           ;清空刚分配的页目录表
   477 0000072B E861FFFFFF                       call lin_to_lin_of_pdte
   478 00000730 49C1EE0C                         shr r14, 12
   479 00000734 49C1E60C                         shl r14, 12                             ;得到页目录表的线性地址
   480 00000738 B900020000                       mov rcx, 512
   481                                    .cls1:
   482 0000073D 49C70600000000                   mov qword [r14], 0
   483 00000744 4983C608                         add r14, 8
   484 00000748 E2F3                             loop .cls1
   485                                  ;-------------------------------------------------
   486                                    .b1:
   487                                           ;检查该线性地址所对应的页目录项是否存在
   488 0000074A E842FFFFFF                       call lin_to_lin_of_pdte
   489 0000074F 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   490 00000756 752B                             jnz .b2                                  ;页目录项已存在，转.b2
   491                                  
   492                                           ;创建并安装该线性地址所对应的页目录项（分配页表）
   493 00000758 E8D7FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页表
   494 0000075D 4883C807                         or rax, 0x07                             ;添加属性位
   495 00000761 498906                           mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   496                                  
   497                                           ;清空刚分配的页表
   498 00000764 E848FFFFFF                       call lin_to_lin_of_pte
   499 00000769 49C1EE0C                         shr r14, 12
   500 0000076D 49C1E60C                         shl r14, 12                             ;得到页表的线性地址
   501 00000771 B900020000                       mov rcx, 512
   502                                    .cls2:
   503 00000776 49C70600000000                   mov qword [r14], 0
   504 0000077D 4983C608                         add r14, 8
   505 00000781 E2F3                             loop .cls2
   506                                  ;-------------------------------------------------
   507                                    .b2:
   508                                           ;检查该线性地址所对应的页表项是否存在
   509 00000783 E829FFFFFF                       call lin_to_lin_of_pte
   510 00000788 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   511 0000078F 750C                             jnz .b3                                  ;页表项已经存在，转.b3
   512                                  
   513                                           ;创建并安装该线性地址所对应的页表项（分配最终的页）
   514 00000791 E89EFEFFFF                       call allocate_a_4k_page                  ;分配一个页
   515 00000796 4883C807                         or rax, 0x07                             ;添加属性位
   516 0000079A 498906                           mov [r14], rax                           ;在页表中登记页表项（页的地址）
   517                                  
   518                                    .b3:
   519 0000079D 415E                             pop r14
   520 0000079F 58                               pop rax
   521 000007A0 59                               pop rcx
   522                                  
   523 000007A1 C3                               ret
   524                                  
   525                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   526                                  mapping_laddr_to_page:                            ;建立线性地址到物理页的映射
   527                                                                                    ;即，为指定的线性地址安装指定的物理页
   528                                                                                    ;输入：R13=线性地址
   529                                                                                    ;      RAX=页的物理地址（含属性）
   530 000007A2 51                               push rcx
   531 000007A3 4156                             push r14
   532 000007A5 50                               push rax
   533                                  
   534                                           ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   535                                           ;检查该线性地址所对应的4级头表项是否存在
   536 000007A6 E8A6FEFFFF                       call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   537 000007AB 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   538 000007B2 752B                             jnz .b0
   539                                  
   540                                           ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   541 000007B4 E87BFEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   542 000007B9 4883C807                         or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   543 000007BD 498906                           mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   544                                  
   545                                           ;清空刚分配的页目录指针表
   546 000007C0 E8ACFEFFFF                       call lin_to_lin_of_pdpte
   547 000007C5 49C1EE0C                         shr r14, 12
   548 000007C9 49C1E60C                         shl r14, 12                              ;得到页目录指针表的线性地址
   549 000007CD B900020000                       mov rcx, 512
   550                                    .cls0:
   551 000007D2 49C70600000000                   mov qword [r14], 0
   552 000007D9 4983C608                         add r14, 8
   553 000007DD E2F3                             loop .cls0
   554                                  ;-------------------------------------------------
   555                                    .b0:
   556                                           ;检查该线性地址所对应的页目录指针项是否存在
   557 000007DF E88DFEFFFF                       call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   558 000007E4 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   559 000007EB 752B                             jnz .b1                                  ;页目录指针项是存在的，转.b1
   560                                  
   561                                           ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   562 000007ED E842FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录表
   563 000007F2 4883C807                         or rax, 0x07                             ;添加属性位
   564 000007F6 498906                           mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   565                                  
   566                                           ;清空刚分配的页目录表
   567 000007F9 E893FEFFFF                       call lin_to_lin_of_pdte
   568 000007FE 49C1EE0C                         shr r14, 12
   569 00000802 49C1E60C                         shl r14, 12                             ;得到页目录表的线性地址
   570 00000806 B900020000                       mov rcx, 512
   571                                    .cls1:
   572 0000080B 49C70600000000                   mov qword [r14], 0
   573 00000812 4983C608                         add r14, 8
   574 00000816 E2F3                             loop .cls1
   575                                  ;-------------------------------------------------
   576                                    .b1:
   577                                           ;检查该线性地址所对应的页目录项是否存在
   578 00000818 E874FEFFFF                       call lin_to_lin_of_pdte
   579 0000081D 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   580 00000824 752B                             jnz .b2                                  ;页目录项已存在，转.b2
   581                                  
   582                                           ;创建并安装该线性地址所对应的页目录项（分配页表）
   583 00000826 E809FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页表
   584 0000082B 4883C807                         or rax, 0x07                             ;添加属性位
   585 0000082F 498906                           mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   586                                  
   587                                           ;清空刚分配的页表
   588 00000832 E87AFEFFFF                       call lin_to_lin_of_pte
   589 00000837 49C1EE0C                         shr r14, 12
   590 0000083B 49C1E60C                         shl r14, 12                              ;得到页表的线性地址
   591 0000083F B900020000                       mov rcx, 512
   592                                    .cls2:
   593 00000844 49C70600000000                   mov qword [r14], 0
   594 0000084B 4983C608                         add r14, 8
   595 0000084F E2F3                             loop .cls2
   596                                  ;-------------------------------------------------
   597                                    .b2:
   598 00000851 E85BFEFFFF                       call lin_to_lin_of_pte                   ;得到页表项的线性地址
   599 00000856 58                               pop rax
   600 00000857 498906                           mov [r14], rax                           ;在页表中登记页表项（页的地址）
   601                                  
   602 0000085A 415E                             pop r14
   603 0000085C 59                               pop rcx
   604                                  
   605 0000085D C3                               ret
   606                                  
   607                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   608 0000085E 000020000080FFFF          _core_next_linear  dq CORE_ALLOC_START          ;下一次分配时可用的起始线性地址
   609                                  
   610                                  core_memory_allocate:                             ;在虚拟地址空间的高端（内核）分配内存
   611                                                                                    ;输入：RCX=请求分配的字节数
   612                                                                                    ;输出：R13=本次分配的起始线性地址
   613                                                                                    ;      R14=下次分配的起始线性地址
   614 00000866 4C8B2DF1FFFFFF                   mov r13, [rel _core_next_linear]         ;获得本次分配的起始线性地址
   615 0000086D 4D8D740D00                       lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   616                                  
   617 00000872 49F7C607000000                   test r14, 0x07                           ;最低3位是000吗（是否按8字节对齐）？
   618 00000879 740C                             jz .algn
   619 0000087B 4983C608                         add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   620 0000087F 49C1EE03                         shr r14, 3
   621 00000883 49C1E603                         shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   622                                  
   623                                    .algn:
   624 00000887 4C8935D0FFFFFF                   mov [rel _core_next_linear], r14         ;写回。
   625                                  
   626 0000088E 4155                             push r13
   627 00000890 4156                             push r14
   628                                  
   629                                           ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   630 00000892 49C1ED0C                         shr r13, 12
   631 00000896 49C1E50C                         shl r13, 12                              ;清除掉页内偏移部分
   632 0000089A 49C1EE0C                         shr r14, 12
   633 0000089E 49C1E60C                         shl r14, 12                              ;too
   634                                    .next:
   635 000008A2 E82DFEFFFF                       call setup_paging_for_laddr              ;安装当前线性地址所在的页
   636 000008A7 4981C500100000                   add r13, 0x1000                          ;+4096
   637 000008AE 4D39F5                           cmp r13, r14
   638 000008B1 7EEF                             jle .next
   639                                  
   640 000008B3 415E                             pop r14
   641 000008B5 415D                             pop r13
   642                                  
   643 000008B7 C3                               ret
   644                                  
   645                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   646                                  user_memory_allocate:                             ;在用户任务的私有空间（低端）分配内存
   647                                                                                    ;输入：R11=任务控制块PCB的线性地址
   648                                                                                    ;      RCX=希望分配的字节数
   649                                                                                    ;输出：R13=本次分配的起始线性地址
   650                                                                                    ;      R14=下次分配的起始线性地址
   651                                           ;获得本次内存分配的起始线性地址
   652 000008B8 4D8B6B18                         mov r13, [r11 + 24]                      ;获得本次分配的起始线性地址
   653 000008BC 4D8D740D00                       lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   654                                  
   655 000008C1 49F7C607000000                   test r14, 0x07                           ;能够被8整除吗（是否按8字节对齐）？
   656 000008C8 740C                             jz .algn
   657 000008CA 49C1EE03                         shr r14, 3
   658 000008CE 49C1E603                         shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   659 000008D2 4983C608                         add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   660                                  
   661                                    .algn:
   662 000008D6 4D897318                         mov [r11 + 24], r14                      ;写回PCB中。
   663                                  
   664 000008DA 4155                             push r13
   665 000008DC 4156                             push r14
   666                                  
   667                                           ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   668 000008DE 49C1ED0C                         shr r13, 12
   669 000008E2 49C1E50C                         shl r13, 12                              ;清除掉页内偏移部分
   670 000008E6 49C1EE0C                         shr r14, 12
   671 000008EA 49C1E60C                         shl r14, 12                              ;too
   672                                    .next:
   673 000008EE E8E1FDFFFF                       call setup_paging_for_laddr              ;安装当前线性地址所在的页
   674 000008F3 4981C500100000                   add r13, 0x1000                          ;+4096
   675 000008FA 4D39F5                           cmp r13, r14
   676 000008FD 7EEF                             jle .next
   677                                  
   678 000008FF 415E                             pop r14
   679 00000901 415D                             pop r13
   680                                  
   681 00000903 C3                               ret
   682                                  
   683                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   684                                  copy_current_pml4:                                ;创建新的4级头表，并复制当前4级头表的内容
   685                                                                                    ;输入：无
   686                                                                                    ;输出：RAX=新4级头表的物理地址及属性
   687 00000904 56                               push rsi
   688 00000905 57                               push rdi
   689 00000906 4155                             push r13
   690 00000908 51                               push rcx
   691                                  
   692 00000909 E826FDFFFF                       call allocate_a_4k_page                  ;分配一个物理页
   693 0000090E 4883C807                         or rax, 0x07                             ;立即数符号扩展到64位参与操作
   694 00000912 49BD00F0FFFF7FFFFF-              mov r13, NEW_PML4_LINEAR                 ;用指定的线性地址映射和访问这个页
   694 0000091B FF                 
   695 0000091C E881FEFFFF                       call mapping_laddr_to_page
   696                                  
   697                                           ;相关表项在修改前存在遗留，本次修改必须刷新。
   698 00000921 410F017D00                       invlpg [r13]
   699                                  
   700 00000926 48C7C600F0FFFF                   mov rsi, 0xffff_ffff_ffff_f000           ;RSI->当前活动4级头表的线性地址
   701 0000092D 4C89EF                           mov rdi, r13                             ;RDI->新4级头表的线性地址
   702 00000930 B900020000                       mov rcx, 512                             ;RCX=要复制的目录项数
   703 00000935 FC                               cld
   704 00000936 F348A5                           repe movsq
   705                                  
   706 00000939 498985F80F0000                   mov [r13 + 0xff8], rax                   ;新4级头表的511号表项指向它自己
   707 00000940 410F01BDF80F0000                 invlpg [r13 + 0xff8]
   708                                  
   709 00000948 59                               pop rcx
   710 00000949 415D                             pop r13
   711 0000094B 5F                               pop rdi
   712 0000094C 5E                               pop rsi
   713                                  
   714 0000094D C3                               ret
   715                                  
   716                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   717 0000094E 0000                    _gdt_info dw 0
   718 00000950 0000000000000000                  dq 0
   719                                  
   720                                  append_segd_to_gdt:                               ;在GDT中添加段描述符
   721                                                                                    ;输入：RSI=段描述符
   722                                                                                    ;输出：CX=段描述符选择子
   723 00000958 4150                             push r8
   724                                  
   725 0000095A 0F0105EDFFFFFF                   sgdt [rel _gdt_info]
   726                                  
   727 00000961 4C8B05E8FFFFFF                   mov r8, [rel _gdt_info + 2]
   728 00000968 480FB70DDEFFFFFF                 movzx rcx, word [rel _gdt_info]
   729 00000970 4989740801                       mov [r8 + rcx + 1], rsi
   730                                  
   731 00000975 4883C108                         add rcx, 8
   732 00000979 66890DCEFFFFFF                   mov [rel _gdt_info], cx
   733                                  
   734 00000980 0F0115C7FFFFFF                   lgdt [rel _gdt_info]
   735                                  
   736 00000987 66C1E903                         shr cx, 3                                ;除以8（消除余数）
   737 0000098B 66C1E103                         shl cx, 3                                ;将索引号移到正确位置
   738                                           ;and cx, 0xfff8
   739 0000098F 4158                             pop r8
   740                                  
   741 00000991 C3                               ret
   742                                  
   743                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   744                                  get_cmos_time:                                    ;从CMOS中获取当前时间
   745                                                                                    ;输入：RBX=缓冲区线性地址
   746 00000992 50                               push rax
   747                                  
   748                                    .w0:
   749 00000993 B08A                             mov al, 0x8a
   750 00000995 E670                             out 0x70, al
   751 00000997 E471                             in al, 0x71                              ;读寄存器A
   752 00000999 A880                             test al, 0x80                            ;测试第7位UIP，等待更新周期结束。
   753 0000099B 75F6                             jnz .w0
   754                                  
   755 0000099D B084                             mov al, 0x84
   756 0000099F E670                             out 0x70, al
   757 000009A1 E471                             in al, 0x71                              ;读RTC当前时间(时)
   758 000009A3 88C4                             mov ah, al
   759                                  
   760 000009A5 C0EC04                           shr ah, 4
   761 000009A8 80E40F                           and ah, 0x0f
   762 000009AB 80C430                           add ah, 0x30
   763 000009AE 8823                             mov [rbx], ah
   764                                  
   765 000009B0 240F                             and al, 0x0f
   766 000009B2 0430                             add al, 0x30
   767 000009B4 884301                           mov [rbx + 1], al
   768                                  
   769 000009B7 C643023A                         mov byte [rbx + 2], ':'
   770                                  
   771 000009BB B082                             mov al, 0x82
   772 000009BD E670                             out 0x70, al
   773 000009BF E471                             in al, 0x71                              ;读RTC当前时间(分)
   774 000009C1 88C4                             mov ah, al
   775                                  
   776 000009C3 C0EC04                           shr ah, 4
   777 000009C6 80E40F                           and ah, 0x0f
   778 000009C9 80C430                           add ah, 0x30
   779 000009CC 886303                           mov [rbx + 3], ah
   780                                  
   781 000009CF 240F                             and al, 0x0f
   782 000009D1 0430                             add al, 0x30
   783 000009D3 884304                           mov [rbx + 4], al
   784                                  
   785 000009D6 C643053A                         mov byte [rbx + 5], ':'
   786                                  
   787 000009DA B080                             mov al, 0x80
   788 000009DC E670                             out 0x70, al
   789 000009DE E471                             in al, 0x71                              ;读RTC当前时间(秒)
   790 000009E0 88C4                             mov ah, al                               ;分拆成两个数字
   791                                  
   792 000009E2 C0EC04                           shr ah, 4                                ;逻辑右移4位
   793 000009E5 80E40F                           and ah, 0x0f
   794 000009E8 80C430                           add ah, 0x30
   795 000009EB 886306                           mov [rbx + 6], ah
   796                                  
   797 000009EE 240F                             and al, 0x0f                             ;仅保留低4位
   798 000009F0 0430                             add al, 0x30                             ;转换成ASCII
   799 000009F2 884307                           mov [rbx + 7], al
   800                                  
   801 000009F5 C6430800                         mov byte [rbx + 8], 0                    ;空字符终止
   802                                  
   803 000009F9 58                               pop rax
   804                                  
   805 000009FA C3                               ret
   806                                  
   807                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   808 000009FB 0000000000000000          _process_id dq 0
   809                                  
   810                                  generate_process_id:                              ;生成唯一的进程标识
   811                                                                                    ;返回：RAX=进程标识
   812 00000A03 FA                               cli
   813 00000A04 488B05F0FFFFFF                   mov rax, [rel _process_id]
   814 00000A0B 48FF05E9FFFFFF                   inc qword [rel _process_id]
   815 00000A12 FB                               sti
   816 00000A13 C3                               ret
   817                                  
   818                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   819                                  ;  _thread_id dq 0
   820                                  
   821                                  ;generate_thread_id:                               ;生成唯一的线程标识
   822                                                                                    ;返回：RAX=线程标识
   823                                  ;         mov rax, [rel _thread_id]
   824                                  ;         inc qword [rel _thread_id]
   825                                  ;         ret
   826                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   827 00000A14 08                        _screen_row db 8
   828                                  
   829                                  get_screen_row:                                   ;返回下一个屏幕坐标行的行号
   830                                                                                    ;返回：DH=行号
   831 00000A15 FA                               cli
   832 00000A16 8A35F8FFFFFF                     mov dh, [rel _screen_row]
   833 00000A1C FE05F2FFFFFF                     inc byte [rel _screen_row]
   834 00000A22 FB                               sti
   835 00000A23 C3                               ret
   836                                  
   837                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   838                                  
