     1                                  ;文件core_utils64_mp.wid是供64位内核使用的函数集，多处理器环境专用。
     2                                  ;创建时间：2022，李忠
     3                                  ;此文件是内核程序的一部分，包含了内核使用的例程，主要是为了减小内核程序的体积，
     4                                  ;方便内核代码的阅读和讲解。在内核程序中，必须用预处理指令%include引入本文件。
     5                                  
     6                                  %include "..\common\global_defs.wid"
     7                              <1> ;系统全局使用的常量定义，2021-09-05
     8                              <1> 
     9                              <1> ;定义地址的，至少按16字节对齐！！！与分页有关的地址必须按4KB对齐！！！
    10                              <1> 
    11                              <1> %ifndef _GLOBAL_DEFS_
    12                              <1>    %define _GLOBAL_DEFS_
    13                              <1> 
    14                              <1>    SDA_PHY_ADDR        equ     0x00007e00              ;系统数据区的起始物理地址
    15                              <1>    PML5_PHY_ADDR       equ     0x00009000              ;内核5级头表物理地址
    16                              <1>    PML4_PHY_ADDR       equ     0x0000a000              ;内核4级头表物理地址
    17                              <1>    PDPT_PHY_ADDR       equ     0x0000b000              ;对应于低端2MB的内核页目录指针表物理地址
    18                              <1>    PDT_PHY_ADDR        equ     0x0000c000              ;对应于低端2MB的页目录表物理地址
    19                              <1>    PT_PHY_ADDR         equ     0x0000d000              ;对应于低端2MB的内核页表的物理地址
    20                              <1>    IDT_PHY_ADDR        equ     0x0000e000              ;中断描述符表的物理地址
    21                              <1>    LDR_PHY_ADDR        equ     0x0000f000              ;用于安装内核加载器的起始物理地址
    22                              <1>    GDT_PHY_ADDR        equ     0x00010000              ;全局描述符表GDT的物理地址
    23                              <1>    CORE_PHY_ADDR       equ     0x00020000              ;内核的起始物理地址
    24                              <1>    COR_PDPT_ADDR       equ     0x00100000              ;从这个物理地址开始的1MB是内核的254个页目录指针表
    25                              <1> 
    26                              <1>    LDR_START_SECTOR    equ     1                       ;内核加载器在硬盘上的起始逻辑扇区号
    27                              <1>    COR_START_SECTOR    equ     9                       ;内核程序在硬盘上的起始逻辑扇区号
    28                              <1> 
    29                              <1>    ;虚拟内存空间的高端起始于线性地址0xffff800000000000
    30                              <1>    UPPER_LINEAR_START  equ     0xffff800000000000
    31                              <1> 
    32                              <1>    UPPER_CORE_LINEAR   equ     UPPER_LINEAR_START + CORE_PHY_ADDR     ;内核的高端线性地址
    33                              <1>    UPPER_TEXT_VIDEO    equ     UPPER_LINEAR_START + 0x000b8000        ;文本显示缓冲区的高端起始线性地址
    34                              <1>    UPPER_SDA_LINEAR    equ     UPPER_LINEAR_START + SDA_PHY_ADDR      ;系统数据区的高端线性地址
    35                              <1>    UPPER_GDT_LINEAR    equ     UPPER_LINEAR_START + GDT_PHY_ADDR      ;GDT的高端线性地址
    36                              <1>    UPPER_IDT_LINEAR    equ     UPPER_LINEAR_START + IDT_PHY_ADDR      ;IDT的高端线性地址
    37                              <1> 
    38                              <1>    ;与全局描述符表有关的选择子定义，及内存管理有关的常量定义
    39                              <1>    CORE_CODE64_SEL     equ     0x0018                  ;内核代码段的描述符选择子（RPL=00）
    40                              <1>    CORE_STACK64_SEL    equ     0x0020                  ;内核栈段的描述符选择子（RPL=00）
    41                              <1>    RESVD_DESC_SEL      equ     0x002b                  ;保留的描述符选择子
    42                              <1>    USER_CODE64_SEL     equ     0x003b                  ;3特权级代码段的描述符选择子（RPL=11）
    43                              <1>    USER_STACK64_SEL    equ     0x0033                  ;3特权级栈段的描述符选择子（RPL=11）
    44                              <1> 
    45                              <1>    PHY_MEMORY_SIZE     equ     32                      ;物理内存大小（MB），要求至少3MB
    46                              <1>    CORE_ALLOC_START    equ     0xffff800000200000      ;在虚拟地址空间高端（内核）分配内存时的起始地址
    47                              <1>    USER_ALLOC_START    equ     0x0000000000000000      ;在每个任务虚拟地址空间低端分配内存时的起始地址
    48                              <1> 
    49                              <1>    ;创建任务时，需要分配一个物理页作为新任务的4级头表，并分配一个临时的线性地址来初始化这个页
    50                              <1>    NEW_PML4_LINEAR     equ     0xffffff7ffffff000      ;用来映射新任务4级头表的线性地址
    51                              <1> 
    52                              <1>    LAPIC_START_ADDR    equ     0xffffff7fffffe000      ;LOCAL APIC寄存器的起始线性地址
    53                              <1>    IOAPIC_START_ADDR   equ     0xffffff7fffffd000      ;I/O APIC寄存器的起始线性地址
    54                              <1> 
    55                              <1>    AP_START_UP_ADDR    equ     0x0000f000              ;应用处理器（AP）启动代码的物理地址
    56                              <1> 
    57                              <1>    SUGG_PREEM_SLICE    equ     1000                      ;推荐的任务/线程抢占时间片长度（毫秒）
    58                              <1> 
    59                              <1>    ;多处理器环境下的自旋锁加锁宏。需要两个参数：寄存器，以及一个对应宽度的锁变量
    60                              <1>    %macro   SET_SPIN_LOCK 2                            ;两个参数，分别是寄存器%1和锁变量%2
    61                              <1>             %%spin_lock:
    62                              <1>                        cmp %2, 0                       ;锁是释放状态吗？
    63                              <1>                        je %%get_lock                   ;获取锁
    64                              <1>                        pause
    65                              <1>                        jmp %%spin_lock                 ;继续尝试获取锁
    66                              <1>             %%get_lock:
    67                              <1>                        mov %1, 1
    68                              <1>                        xchg %1, %2
    69                              <1>                        cmp %1, 0                       ;交换前为零？
    70                              <1>                        jne %%spin_lock                 ;已有程序抢先加锁，失败重来
    71                              <1>    %endmacro
    72                              <1> 
    73                              <1> %endif
     7                                  
     8                                           bits 64
     9                                  
    10                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    11 00000000 0000000000000000        _prn_str_locker dq 0                              ;打印锁
    12                                  
    13                                  put_string64:                                     ;显示0终止的字符串并移动光标
    14                                                                                    ;输入：RBX=字符串的线性地址
    15 00000008 53                               push rbx
    16 00000009 51                               push rcx
    17                                  
    18 0000000A 9C                               pushfq                                   ;-->A
    19 0000000B FA                               cli
    20                                           SET_SPIN_LOCK rcx, qword [rel _prn_str_locker]
    61                              <1>  %%spin_lock:
    62 0000000C 48833DECFFFFFF00    <1>  cmp %2, 0
    63 00000014 7404                <1>  je %%get_lock
    64 00000016 F390                <1>  pause
    65 00000018 EBF2                <1>  jmp %%spin_lock
    66                              <1>  %%get_lock:
    67 0000001A B901000000          <1>  mov %1, 1
    68 0000001F 48870DDAFFFFFF      <1>  xchg %1, %2
    69 00000026 4883F900            <1>  cmp %1, 0
    70 0000002A 75E0                <1>  jne %%spin_lock
    21                                  
    22                                    .getc:
    23 0000002C 8A0B                             mov cl, [rbx]
    24 0000002E 08C9                             or cl, cl                                ;检测串结束标志（0）
    25 00000030 740A                             jz .exit                                 ;显示完毕，返回
    26 00000032 E814000000                       call put_char
    27 00000037 48FFC3                           inc rbx
    28 0000003A EBF0                             jmp .getc
    29                                  
    30                                    .exit:
    31 0000003C 48C705B9FFFFFF0000-              mov qword [rel _prn_str_locker], 0       ;释放锁
    31 00000045 0000               
    32 00000047 9D                               popfq                                    ;A
    33                                  
    34 00000048 59                               pop rcx
    35 00000049 5B                               pop rbx
    36                                  
    37 0000004A C3                               ret                                      ;段内返回
    38                                  
    39                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    40                                  put_char:                                         ;在当前光标处显示一个字符,并推进
    41                                                                                    ;光标。
    42                                                                                    ;输入：CL=字符ASCII码
    43 0000004B 50                               push rax
    44 0000004C 53                               push rbx
    45 0000004D 51                               push rcx
    46 0000004E 52                               push rdx
    47 0000004F 56                               push rsi
    48 00000050 57                               push rdi
    49                                  
    50                                           ;以下取当前光标位置
    51 00000051 66BAD403                         mov dx, 0x3d4
    52 00000055 B00E                             mov al, 0x0e
    53 00000057 EE                               out dx, al
    54 00000058 66FFC2                           inc dx                                   ;0x3d5
    55 0000005B EC                               in al, dx                                ;高字
    56 0000005C 88C4                             mov ah, al
    57                                  
    58 0000005E 66FFCA                           dec dx                                   ;0x3d4
    59 00000061 B00F                             mov al, 0x0f
    60 00000063 EE                               out dx, al
    61 00000064 66FFC2                           inc dx                                   ;0x3d5
    62 00000067 EC                               in al, dx                                ;低字
    63 00000068 6689C3                           mov bx, ax                               ;BX=代表光标位置的16位数
    64 0000006B 4881E3FFFF0000                   and rbx, 0x000000000000ffff              ;准备使用64位寻址方式访问显存
    65                                  
    66 00000072 80F90D                           cmp cl, 0x0d                             ;回车符？
    67 00000075 750E                             jnz .put_0a
    68 00000077 6689D8                           mov ax, bx
    69 0000007A B350                             mov bl, 80
    70 0000007C F6F3                             div bl
    71 0000007E F6E3                             mul bl
    72 00000080 6689C3                           mov bx, ax
    73 00000083 EB6C                             jmp .set_cursor
    74                                  
    75                                    .put_0a:
    76 00000085 80F90A                           cmp cl, 0x0a                             ;换行符？
    77 00000088 7506                             jnz .put_other
    78 0000008A 6683C350                         add bx, 80
    79 0000008E EB16                             jmp .roll_screen
    80                                  
    81                                    .put_other:                                     ;正常显示字符
    82 00000090 66D1E3                           shl bx, 1
    83 00000093 48B800800B000080FF-              mov rax, UPPER_TEXT_VIDEO                ;在global_defs.wid中定义
    83 0000009C FF                 
    84 0000009D 880C18                           mov [rax + rbx], cl
    85                                  
    86                                           ;以下将光标位置推进一个字符
    87 000000A0 66D1EB                           shr bx, 1
    88 000000A3 66FFC3                           inc bx
    89                                  
    90                                    .roll_screen:
    91 000000A6 6681FBD007                       cmp bx, 2000                             ;光标超出屏幕？滚屏
    92 000000AB 7C44                             jl .set_cursor
    93                                  
    94 000000AD 6653                             push bx
    95                                  
    96 000000AF FC                               cld
    97 000000B0 48BEA0800B000080FF-              mov rsi, UPPER_TEXT_VIDEO + 0xa0         ;小心！64位模式下movsq
    97 000000B9 FF                 
    98 000000BA 48BF00800B000080FF-              mov rdi, UPPER_TEXT_VIDEO                ;使用的是rsi/rdi/rcx
    98 000000C3 FF                 
    99 000000C4 B9E0010000                       mov rcx, 480
   100 000000C9 F348A5                           rep movsq
   101 000000CC 66BB000F                         mov bx, 3840                             ;清除屏幕最底一行
   102 000000D0 B950000000                       mov rcx, 80                              ;64位程序应该使用RCX
   103                                    .cls:
   104 000000D5 48B800800B000080FF-              mov rax, UPPER_TEXT_VIDEO
   104 000000DE FF                 
   105 000000DF 66C704182007                     mov word[rax + rbx], 0x0720
   106 000000E5 6683C302                         add bx, 2
   107 000000E9 E2EA                             loop .cls
   108                                  
   109 000000EB 665B                             pop bx
   110 000000ED 6683EB50                         sub bx, 80
   111                                  
   112                                    .set_cursor:
   113 000000F1 66BAD403                         mov dx, 0x3d4
   114 000000F5 B00E                             mov al, 0x0e
   115 000000F7 EE                               out dx, al
   116 000000F8 66FFC2                           inc dx                                   ;0x3d5
   117 000000FB 88F8                             mov al, bh
   118 000000FD EE                               out dx, al
   119 000000FE 66FFCA                           dec dx                                   ;0x3d4
   120 00000101 B00F                             mov al, 0x0f
   121 00000103 EE                               out dx, al
   122 00000104 66FFC2                           inc dx                                   ;0x3d5
   123 00000107 88D8                             mov al, bl
   124 00000109 EE                               out dx, al
   125                                  
   126 0000010A 5F                               pop rdi
   127 0000010B 5E                               pop rsi
   128 0000010C 5A                               pop rdx
   129 0000010D 59                               pop rcx
   130 0000010E 5B                               pop rbx
   131 0000010F 58                               pop rax
   132                                  
   133 00000110 C3                               ret
   134                                  
   135                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   136                                  ;在指定位置用指定颜色显示0终止的字符串，只适用于打印图形字符。由于各程序打印时的
   137                                  ;坐标位置不同，互不干扰，不需要加锁和互斥。
   138 00000111 0000000000000000        _prnxy_locker dq 0
   139                                  
   140                                  put_cstringxy64:                                  ;输入：RBX=字符串首地址
   141                                                                                    ;DH=行，DL=列
   142                                                                                    ;R9B=颜色属性
   143 00000119 50                               push rax
   144 0000011A 53                               push rbx
   145 0000011B 51                               push rcx
   146 0000011C 52                               push rdx
   147 0000011D 4150                             push r8
   148                                  
   149                                           ;指定坐标位置在显存内的偏移量
   150 0000011F 88F0                             mov al, dh
   151 00000121 B5A0                             mov ch, 160                              ;每一行80个字符，占用160个字节
   152 00000123 F6E5                             mul ch
   153 00000125 D0E2                             shl dl, 1                                ;每个字符（列）占用2个字节，要乘以2
   154 00000127 6681E2FF00                       and dx, 0x00ff
   155 0000012C 6601D0                           add ax, dx                               ;得到指定坐标位置在显存内的偏移量
   156 0000012F 4825FFFF0000                     and rax, 0x000000000000ffff
   157                                  
   158 00000135 9C                               pushfq                                   ;-->A
   159 00000136 FA                               cli
   160                                           SET_SPIN_LOCK r8, qword [rel _prnxy_locker]
    61                              <1>  %%spin_lock:
    62 00000137 48833DD2FFFFFF00    <1>  cmp %2, 0
    63 0000013F 7404                <1>  je %%get_lock
    64 00000141 F390                <1>  pause
    65 00000143 EBF2                <1>  jmp %%spin_lock
    66                              <1>  %%get_lock:
    67 00000145 41B801000000        <1>  mov %1, 1
    68 0000014B 4C8705BFFFFFFF      <1>  xchg %1, %2
    69 00000152 4983F800            <1>  cmp %1, 0
    70 00000156 75DF                <1>  jne %%spin_lock
   161                                  
   162 00000158 49B800800B000080FF-              mov r8, UPPER_TEXT_VIDEO                 ;显存的起始线性地址
   162 00000161 FF                 
   163                                    .nextc:
   164 00000162 8A13                             mov dl, [rbx]                            ;取得将要显示的字符
   165 00000164 08D2                             or dl, dl
   166 00000166 7412                             jz .exit
   167 00000168 41881400                         mov byte [r8 + rax], dl
   168 0000016C 45884C0001                       mov byte [r8 + rax + 1], r9b             ;字符颜色
   169 00000171 48FFC3                           inc rbx
   170 00000174 4883C002                         add rax, 2                               ;增加一个字符的位置（2个字节）
   171 00000178 EBE8                             jmp .nextc
   172                                    .exit:
   173 0000017A 4D31C0                           xor r8, r8
   174                                  
   175 0000017D 48C70589FFFFFF0000-              mov qword [rel _prnxy_locker], 0         ;释放锁
   175 00000186 0000               
   176 00000188 9D                               popfq                                    ;A
   177                                  
   178 00000189 4158                             pop r8
   179 0000018B 5A                               pop rdx
   180 0000018C 59                               pop rcx
   181 0000018D 5B                               pop rbx
   182 0000018E 58                               pop rax
   183                                  
   184 0000018F C3                               ret
   185                                  
   186                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   187                                  make_call_gate:                                   ;创建64位的调用门
   188                                                                                    ;输入：RAX=例程的线性地址
   189                                                                                    ;输出：RDI:RSI=调用门
   190 00000190 4889C7                           mov rdi, rax
   191 00000193 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   192                                  
   193 00000197 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   194 00000198 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   195 0000019F 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   196 000001A3 66C7442404008C                   mov word [rsp + 4], 0x8c00               ;添加P=1，TYPE=64位调用门
   197 000001AA 5E                               pop rsi
   198                                  
   199 000001AB C3                               ret
   200                                  
   201                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   202                                  make_interrupt_gate:                              ;创建64位的中断门
   203                                                                                    ;输入：RAX=例程的线性地址
   204                                                                                    ;输出：RDI:RSI=中断门
   205 000001AC 4889C7                           mov rdi, rax
   206 000001AF 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   207                                  
   208 000001B3 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   209 000001B4 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   210 000001BB 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   211 000001BF 66C7442404008E                   mov word [rsp + 4], 0x8e00               ;添加P=1，TYPE=64位中断门
   212 000001C6 5E                               pop rsi
   213                                  
   214 000001C7 C3                               ret
   215                                  
   216                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   217                                  make_trap_gate:                                   ;创建64位的陷阱门
   218                                                                                    ;输入：RAX=例程的线性地址
   219                                                                                    ;输出：RDI:RSI=陷阱门
   220 000001C8 4889C7                           mov rdi, rax
   221 000001CB 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   222                                  
   223 000001CF 50                               push rax                                 ;构造数据结构，并预置线性地址的位15~0
   224 000001D0 66C74424021800                   mov word [rsp + 2], CORE_CODE64_SEL      ;预置段选择子部分
   225 000001D7 89442404                         mov [rsp + 4], eax                       ;预置线性地址的位31~16
   226 000001DB 66C7442404008F                   mov word [rsp + 4], 0x8f00               ;添加P=1，TYPE=64位陷阱门
   227 000001E2 5E                               pop rsi
   228                                  
   229 000001E3 C3                               ret
   230                                  
   231                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   232                                  make_tss_descriptor:                              ;创建64位的TSS描述符
   233                                                                                    ;输入：RAX=TSS的线性地址
   234                                                                                    ;输出：RDI:RSI=TSS描述符
   235 000001E4 50                               push rax
   236                                  
   237 000001E5 4889C7                           mov rdi, rax
   238 000001E8 48C1EF20                         shr rdi, 32                              ;得到门的高64位，在RDI中
   239                                  
   240 000001EC 50                               push rax                                 ;先将部分线性地址移到适当位置
   241 000001ED 48C1242410                       shl qword [rsp], 16                      ;将线性地址的位23~00移到正确位置
   242 000001F2 66C704246800                     mov word [rsp], 104                      ;段界限的标准长度
   243 000001F8 8A442405                         mov al, [rsp + 5]
   244 000001FC 88442407                         mov [rsp + 7], al                        ;将线性地址的位31~24移到正确位置
   245 00000200 C644240589                       mov byte [rsp + 5], 0x89                 ;P=1，DPL=00，TYPE=1001（64位TSS）
   246 00000205 C644240600                       mov byte [rsp + 6], 0                    ;G、0、0、AVL和limit
   247 0000020A 5E                               pop rsi                                  ;门的低64位
   248                                  
   249 0000020B 58                               pop rax
   250                                  
   251 0000020C C3                               ret
   252                                  
   253                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   254                                  mount_idt_entry:                                  ;在中断描述符表IDT中安装门描述符
   255                                                                                    ;R8=中断向量
   256                                                                                    ;RDI:RSI=门描述符
   257 0000020D 4150                             push r8
   258 0000020F 4151                             push r9
   259                                  
   260 00000211 49C1E004                         shl r8, 4                                ;中断号乘以16，得到表内偏移
   261 00000215 49B900E000000080FF-              mov r9, UPPER_IDT_LINEAR                 ;中断描述符表的高端线性地址
   261 0000021E FF                 
   262 0000021F 4B893401                         mov [r9 + r8], rsi
   263 00000223 4B897C0108                       mov [r9 + r8 + 8], rdi
   264                                  
   265 00000228 4159                             pop r9
   266 0000022A 4158                             pop r8
   267                                  
   268 0000022C C3                               ret
   269                                  
   270                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   271                                  init_8259:                                        ;初始化8259中断控制器，包括重新设置向量号
   272 0000022D 50                               push rax
   273                                  
   274 0000022E B011                             mov al, 0x11
   275 00000230 E620                             out 0x20, al                             ;ICW1：边沿触发/级联方式
   276 00000232 B020                             mov al, 0x20
   277 00000234 E621                             out 0x21, al                             ;ICW2:起始中断向量（避开前31个异常的向量）
   278 00000236 B004                             mov al, 0x04
   279 00000238 E621                             out 0x21, al                             ;ICW3:从片级联到IR2
   280 0000023A B001                             mov al, 0x01
   281 0000023C E621                             out 0x21, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   282                                  
   283 0000023E B011                             mov al, 0x11
   284 00000240 E6A0                             out 0xa0, al                             ;ICW1：边沿触发/级联方式
   285 00000242 B028                             mov al, 0x28
   286 00000244 E6A1                             out 0xa1, al                             ;ICW2:起始中断向量-->0x28
   287 00000246 B002                             mov al, 0x02
   288 00000248 E6A1                             out 0xa1, al                             ;ICW3:从片识别标志，级联到主片IR2
   289 0000024A B001                             mov al, 0x01
   290 0000024C E6A1                             out 0xa1, al                             ;ICW4:非总线缓冲，全嵌套，正常EOI
   291                                  
   292 0000024E 58                               pop rax
   293 0000024F C3                               ret
   294                                  
   295                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   296 00000250 0000000000000000        _read_hdd_locker dq 0                              ;读硬盘锁
   297                                  
   298                                  read_hard_disk_0:                                 ;从硬盘读取一个逻辑扇区
   299                                                                                    ;RAX=逻辑扇区号
   300                                                                                    ;RBX=目标缓冲区线性地址
   301                                                                                    ;返回：RBX=RBX+512
   302 00000258 50                               push rax
   303 00000259 51                               push rcx
   304 0000025A 52                               push rdx
   305                                  
   306 0000025B 9C                               pushfq                                   ;-->A
   307 0000025C FA                               cli
   308                                           SET_SPIN_LOCK rdx, qword [rel _read_hdd_locker]
    61                              <1>  %%spin_lock:
    62 0000025D 48833DEBFFFFFF00    <1>  cmp %2, 0
    63 00000265 7404                <1>  je %%get_lock
    64 00000267 F390                <1>  pause
    65 00000269 EBF2                <1>  jmp %%spin_lock
    66                              <1>  %%get_lock:
    67 0000026B BA01000000          <1>  mov %1, 1
    68 00000270 488715D9FFFFFF      <1>  xchg %1, %2
    69 00000277 4883FA00            <1>  cmp %1, 0
    70 0000027B 75E0                <1>  jne %%spin_lock
   309                                  
   310 0000027D 50                               push rax
   311                                  
   312 0000027E 66BAF201                         mov dx, 0x1f2
   313 00000282 B001                             mov al, 1
   314 00000284 EE                               out dx, al                               ;读取的扇区数
   315                                  
   316 00000285 66FFC2                           inc dx                                   ;0x1f3
   317 00000288 58                               pop rax
   318 00000289 EE                               out dx, al                               ;LBA地址7~0
   319                                  
   320 0000028A 66FFC2                           inc dx                                   ;0x1f4
   321 0000028D B108                             mov cl, 8
   322 0000028F 48D3E8                           shr rax, cl
   323 00000292 EE                               out dx, al                               ;LBA地址15~8
   324                                  
   325 00000293 66FFC2                           inc dx                                   ;0x1f5
   326 00000296 48D3E8                           shr rax, cl
   327 00000299 EE                               out dx, al                               ;LBA地址23~16
   328                                  
   329 0000029A 66FFC2                           inc dx                                   ;0x1f6
   330 0000029D 48D3E8                           shr rax, cl
   331 000002A0 0CE0                             or al, 0xe0                              ;第一硬盘  LBA地址27~24
   332 000002A2 EE                               out dx, al
   333                                  
   334 000002A3 66FFC2                           inc dx                                   ;0x1f7
   335 000002A6 B020                             mov al, 0x20                             ;读命令
   336 000002A8 EE                               out dx, al
   337                                  
   338                                    .waits:
   339 000002A9 EC                               in al, dx
   340                                           ;and al, 0x88
   341                                           ;cmp al, 0x08
   342 000002AA A808                             test al, 8
   343 000002AC 74FB                             jz .waits                               ;不忙，且硬盘已准备好数据传输
   344                                  
   345 000002AE B900010000                       mov rcx, 256                             ;总共要读取的字数
   346 000002B3 66BAF001                         mov dx, 0x1f0
   347                                    .readw:
   348 000002B7 66ED                             in ax, dx
   349 000002B9 668903                           mov [rbx], ax
   350 000002BC 4883C302                         add rbx, 2
   351 000002C0 E2F5                             loop .readw
   352                                  
   353 000002C2 48C70583FFFFFF0000-              mov qword [rel _read_hdd_locker], 0      ;释放锁
   353 000002CB 0000               
   354 000002CD 9D                               popfq                                    ;A
   355                                  
   356 000002CE 5A                               pop rdx
   357 000002CF 59                               pop rcx
   358 000002D0 58                               pop rax
   359                                  
   360 000002D1 C3                               ret
   361                                  
   362                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   363 000002D2 FF<rep 40h>               _page_bit_map times 2*1024/4/8 db 0xff          ;对应物理内存的前512个页面（2MB）
   364 00000312 00<rep 3C0h>                      times (PHY_MEMORY_SIZE-2)*1024/4/8 db 0 ;对应后续的页面
   365                                    _page_map_len  equ $ - _page_bit_map
   366                                  
   367                                  allocate_a_4k_page:                               ;分配一个4KB的页
   368                                                                                    ;输入：无
   369                                                                                    ;输出：RAX=页的物理地址
   370 000006D2 4831C0                           xor rax, rax
   371                                    .b1:
   372 000006D5 F0480FAB05F4FBFFFF               lock bts [rel _page_bit_map], rax
   373 000006DE 730B                             jnc .b2
   374 000006E0 48FFC0                           inc rax
   375 000006E3 483D00200000                     cmp rax, _page_map_len * 8               ;立即数符号扩展到64位进行比较
   376 000006E9 7CEA                             jl .b1
   377                                  
   378                                           ;对我们这个简单的系统来说，通常不存在页面不够分配的情况。对于一个流行的
   379                                           ;系统来说，如果页面不够分配，需要在这里执行虚拟内存管理，即，回收已经注
   380                                           ;销的页面，或者执行页面的换入和换出。
   381                                  
   382                                    .b2:
   383 000006EB 48C1E00C                         shl rax, 12                              ;乘以4096（0x1000）
   384                                  
   385 000006EF C3                               ret
   386                                  
   387                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   388                                  lin_to_lin_of_pml4e:                              ;返回指定的线性地址所对应的4级头表项的线性地址
   389                                                                                    ;输入：R13=线性地址
   390                                                                                    ;输出：R14=对应的4级头表项的线性地址
   391 000006F0 4155                             push r13
   392                                  
   393 000006F2 49BE0000000080FF00-              mov r14, 0x0000_ff80_0000_0000           ;保留4级头表索引部分
   393 000006FB 00                 
   394 000006FC 4D21F5                           and r13, r14
   395 000006FF 49C1ED24                         shr r13, 36                              ;原4级头表索引变成页内偏移
   396                                  
   397 00000703 49C7C600F0FFFF                   mov r14, 0xffff_ffff_ffff_f000           ;访问4级头表所用的地址前缀
   398 0000070A 4D01EE                           add r14, r13
   399                                  
   400 0000070D 415D                             pop r13
   401                                  
   402 0000070F C3                               ret
   403                                  
   404                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   405                                  lin_to_lin_of_pdpte:                              ;返回指定的线性地址所对应的页目录指针项的线性地址
   406                                                                                    ;输入：R13=线性地址
   407                                                                                    ;输出：R14=对应的页目录指针项的线性地址
   408 00000710 4155                             push r13
   409                                  
   410 00000712 49BE000000C0FFFF00-              mov r14, 0x0000_ffff_c000_0000           ;保留4级头表索引和页目录指针表索引部分
   410 0000071B 00                 
   411 0000071C 4D21F5                           and r13, r14
   412 0000071F 49C1ED1B                         shr r13, 27                              ;原4级头表索引变成页表索引，原页目录指针表索引变页内偏移
   413                                  
   414 00000723 49C7C60000E0FF                   mov r14, 0xffff_ffff_ffe0_0000           ;访问页目录指针表所用的地址前缀
   415 0000072A 4D01EE                           add r14, r13
   416                                  
   417 0000072D 415D                             pop r13
   418                                  
   419 0000072F C3                               ret
   420                                  
   421                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   422                                  lin_to_lin_of_pdte:                               ;返回指定的线性地址所对应的页目录项的线性地址
   423                                                                                    ;输入：R13=线性地址
   424                                                                                    ;输出：R14=对应的页目录项的线性地址
   425 00000730 4155                             push r13
   426                                  
   427 00000732 49BE0000E0FFFFFF00-              mov r14, 0x0000_ffff_ffe0_0000           ;保留4级头表索引、页目录指针表索引和页目录表索引部分
   427 0000073B 00                 
   428 0000073C 4D21F5                           and r13, r14
   429 0000073F 49C1ED12                         shr r13, 18                              ;原4级头表索引变成页目录表索引，原页目录指针表索引变
   430                                                                                    ;页表索引，原页目录表索引变页内偏移
   431 00000743 49C7C6000000C0                   mov r14, 0xffff_ffff_c000_0000           ;访问页目录表所用的地址前缀
   432 0000074A 4D01EE                           add r14, r13
   433                                  
   434 0000074D 415D                             pop r13
   435                                  
   436 0000074F C3                               ret
   437                                  
   438                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   439                                  lin_to_lin_of_pte:                                ;返回指定的线性地址所对应的页表项的线性地址
   440                                                                                    ;输入：R13=线性地址
   441                                                                                    ;输出：R14=对应的页表项的线性地址
   442 00000750 4155                             push r13
   443                                  
   444 00000752 49BE00F0FFFFFFFF00-              mov r14, 0x0000_ffff_ffff_f000           ;保留4级头表、页目录指针表、页目录表和页表的索引部分
   444 0000075B 00                 
   445 0000075C 4D21F5                           and r13, r14
   446 0000075F 49C1ED09                         shr r13, 9                               ;原4级头表索引变成页目录指针表索引，原页目录指针表索引变
   447                                                                                    ;页目录表索引，原页目录表索引变页表索引，原页表索引变页内偏移
   448 00000763 49BE0000000080FFFF-              mov r14, 0xffff_ff80_0000_0000           ;访问页表所用的地址前缀
   448 0000076C FF                 
   449 0000076D 4D01EE                           add r14, r13
   450                                  
   451 00000770 415D                             pop r13
   452                                  
   453 00000772 C3                               ret
   454                                  
   455                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   456 00000773 0000000000000000        _spaging_locker dq 0
   457                                  
   458                                  setup_paging_for_laddr:                           ;为指定的线性地址安装分页系统（表项）
   459                                                                                    ;输入：R13=线性地址
   460 0000077B 51                               push rcx
   461 0000077C 50                               push rax
   462 0000077D 4156                             push r14
   463                                  
   464 0000077F 9C                               pushfq                                   ;-->A
   465 00000780 FA                               cli
   466                                           SET_SPIN_LOCK r14, qword [rel _spaging_locker]
    61                              <1>  %%spin_lock:
    62 00000781 48833DEAFFFFFF00    <1>  cmp %2, 0
    63 00000789 7404                <1>  je %%get_lock
    64 0000078B F390                <1>  pause
    65 0000078D EBF2                <1>  jmp %%spin_lock
    66                              <1>  %%get_lock:
    67 0000078F 41BE01000000        <1>  mov %1, 1
    68 00000795 4C8735D7FFFFFF      <1>  xchg %1, %2
    69 0000079C 4983FE00            <1>  cmp %1, 0
    70 000007A0 75DF                <1>  jne %%spin_lock
   467                                  
   468                                           ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   469                                           ;检查该线性地址所对应的4级头表项是否存在
   470 000007A2 E849FFFFFF                       call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   471 000007A7 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   472 000007AE 752B                             jnz .b0
   473                                  
   474                                           ;创建并安装该线性地址所对应的4级头表项（创建页目录指针表）
   475 000007B0 E81DFFFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   476 000007B5 4883C807                         or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   477 000007B9 498906                           mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   478                                  
   479                                           ;清空刚分配的页目录指针表
   480 000007BC E84FFFFFFF                       call lin_to_lin_of_pdpte
   481 000007C1 49C1EE0C                         shr r14, 12
   482 000007C5 49C1E60C                         shl r14, 12                              ;得到页目录指针表的线性地址
   483 000007C9 B900020000                       mov rcx, 512
   484                                    .cls0:
   485 000007CE 49C70600000000                   mov qword [r14], 0
   486 000007D5 4983C608                         add r14, 8
   487 000007D9 E2F3                             loop .cls0
   488                                  ;-------------------------------------------------
   489                                    .b0:
   490                                           ;检查该线性地址所对应的页目录指针项是否存在
   491 000007DB E830FFFFFF                       call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   492 000007E0 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   493 000007E7 752B                             jnz .b1                                  ;页目录指针项是存在的，转.b1
   494                                  
   495                                           ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   496 000007E9 E8E4FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录表
   497 000007EE 4883C807                         or rax, 0x07                             ;添加属性位
   498 000007F2 498906                           mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   499                                  
   500                                           ;清空刚分配的页目录表
   501 000007F5 E836FFFFFF                       call lin_to_lin_of_pdte
   502 000007FA 49C1EE0C                         shr r14, 12
   503 000007FE 49C1E60C                         shl r14, 12                             ;得到页目录表的线性地址
   504 00000802 B900020000                       mov rcx, 512
   505                                    .cls1:
   506 00000807 49C70600000000                   mov qword [r14], 0
   507 0000080E 4983C608                         add r14, 8
   508 00000812 E2F3                             loop .cls1
   509                                  ;-------------------------------------------------
   510                                    .b1:
   511                                           ;检查该线性地址所对应的页目录项是否存在
   512 00000814 E817FFFFFF                       call lin_to_lin_of_pdte
   513 00000819 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   514 00000820 752B                             jnz .b2                                  ;页目录项已存在，转.b2
   515                                  
   516                                           ;创建并安装该线性地址所对应的页目录项（分配页表）
   517 00000822 E8ABFEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页表
   518 00000827 4883C807                         or rax, 0x07                             ;添加属性位
   519 0000082B 498906                           mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   520                                  
   521                                           ;清空刚分配的页表
   522 0000082E E81DFFFFFF                       call lin_to_lin_of_pte
   523 00000833 49C1EE0C                         shr r14, 12
   524 00000837 49C1E60C                         shl r14, 12                             ;得到页表的线性地址
   525 0000083B B900020000                       mov rcx, 512
   526                                    .cls2:
   527 00000840 49C70600000000                   mov qword [r14], 0
   528 00000847 4983C608                         add r14, 8
   529 0000084B E2F3                             loop .cls2
   530                                  ;-------------------------------------------------
   531                                    .b2:
   532                                           ;检查该线性地址所对应的页表项是否存在
   533 0000084D E8FEFEFFFF                       call lin_to_lin_of_pte
   534 00000852 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   535 00000859 750C                             jnz .b3                                  ;页表项已经存在，转.b3
   536                                  
   537                                           ;创建并安装该线性地址所对应的页表项（分配最终的页）
   538 0000085B E872FEFFFF                       call allocate_a_4k_page                  ;分配一个页
   539 00000860 4883C807                         or rax, 0x07                             ;添加属性位
   540 00000864 498906                           mov [r14], rax                           ;在页表中登记页表项（页的地址）
   541                                  
   542                                    .b3:
   543 00000867 48C70501FFFFFF0000-              mov qword [rel _spaging_locker], 0
   543 00000870 0000               
   544 00000872 9D                               popfq                                    ;A
   545                                  
   546 00000873 415E                             pop r14
   547 00000875 58                               pop rax
   548 00000876 59                               pop rcx
   549                                  
   550 00000877 C3                               ret
   551                                  
   552                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   553 00000878 0000000000000000        _mapping_locker dq 0
   554                                  
   555                                  mapping_laddr_to_page:                            ;建立线性地址到物理页的映射
   556                                                                                    ;即，为指定的线性地址安装指定的物理页
   557                                                                                    ;输入：R13=线性地址
   558                                                                                    ;      RAX=页的物理地址（含属性）
   559 00000880 51                               push rcx
   560 00000881 4156                             push r14
   561                                  
   562 00000883 9C                               pushfq
   563 00000884 FA                               cli
   564                                           SET_SPIN_LOCK r14, qword [rel _mapping_locker]
    61                              <1>  %%spin_lock:
    62 00000885 48833DEBFFFFFF00    <1>  cmp %2, 0
    63 0000088D 7404                <1>  je %%get_lock
    64 0000088F F390                <1>  pause
    65 00000891 EBF2                <1>  jmp %%spin_lock
    66                              <1>  %%get_lock:
    67 00000893 41BE01000000        <1>  mov %1, 1
    68 00000899 4C8735D8FFFFFF      <1>  xchg %1, %2
    69 000008A0 4983FE00            <1>  cmp %1, 0
    70 000008A4 75DF                <1>  jne %%spin_lock
   565                                  
   566 000008A6 50                               push rax
   567                                  
   568                                           ;在当前活动的4级分页体系中，所有线性地址对应的4级头表始终是存在的。
   569                                           ;检查该线性地址所对应的4级头表项是否存在
   570 000008A7 E844FEFFFF                       call lin_to_lin_of_pml4e                 ;得到4级头表项的线性地址
   571 000008AC 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   572 000008B3 752B                             jnz .b0
   573                                  
   574                                           ;创建并安装该线性地址所对应的4级头表项（分配页目录指针表）
   575 000008B5 E818FEFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录指针表
   576 000008BA 4883C807                         or rax, 0x07                             ;添加属性位 U/S=R/W=P=1
   577 000008BE 498906                           mov [r14], rax                           ;在4级头表中登记4级头表项（页目录指针表地址）
   578                                  
   579                                           ;清空刚分配的页目录指针表
   580 000008C1 E84AFEFFFF                       call lin_to_lin_of_pdpte
   581 000008C6 49C1EE0C                         shr r14, 12
   582 000008CA 49C1E60C                         shl r14, 12                              ;得到页目录指针表的线性地址
   583 000008CE B900020000                       mov rcx, 512
   584                                    .cls0:
   585 000008D3 49C70600000000                   mov qword [r14], 0
   586 000008DA 4983C608                         add r14, 8
   587 000008DE E2F3                             loop .cls0
   588                                  ;-------------------------------------------------
   589                                    .b0:
   590                                           ;检查该线性地址所对应的页目录指针项是否存在
   591 000008E0 E82BFEFFFF                       call lin_to_lin_of_pdpte                 ;得到页目录指针项的线性地址
   592 000008E5 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   593 000008EC 752B                             jnz .b1                                  ;页目录指针项是存在的，转.b1
   594                                  
   595                                           ;创建并安装该线性地址所对应的页目录指针项（分配页目录表）
   596 000008EE E8DFFDFFFF                       call allocate_a_4k_page                  ;分配一个页做为页目录表
   597 000008F3 4883C807                         or rax, 0x07                             ;添加属性位
   598 000008F7 498906                           mov [r14], rax                           ;在页目录指针表中登记页目录指针项（页目录表地址）
   599                                  
   600                                           ;清空刚分配的页目录表
   601 000008FA E831FEFFFF                       call lin_to_lin_of_pdte
   602 000008FF 49C1EE0C                         shr r14, 12
   603 00000903 49C1E60C                         shl r14, 12                             ;得到页目录表的线性地址
   604 00000907 B900020000                       mov rcx, 512
   605                                    .cls1:
   606 0000090C 49C70600000000                   mov qword [r14], 0
   607 00000913 4983C608                         add r14, 8
   608 00000917 E2F3                             loop .cls1
   609                                  ;-------------------------------------------------
   610                                    .b1:
   611                                           ;检查该线性地址所对应的页目录项是否存在
   612 00000919 E812FEFFFF                       call lin_to_lin_of_pdte
   613 0000091E 49F70601000000                   test qword [r14], 1                      ;P位是否为“1”。表项是否存在？
   614 00000925 752B                             jnz .b2                                  ;页目录项已存在，转.b2
   615                                  
   616                                           ;创建并安装该线性地址所对应的页目录项（分配页表）
   617 00000927 E8A6FDFFFF                       call allocate_a_4k_page                  ;分配一个页做为页表
   618 0000092C 4883C807                         or rax, 0x07                             ;添加属性位
   619 00000930 498906                           mov [r14], rax                           ;在页目录表中登记页目录项（页表地址）
   620                                  
   621                                           ;清空刚分配的页表
   622 00000933 E818FEFFFF                       call lin_to_lin_of_pte
   623 00000938 49C1EE0C                         shr r14, 12
   624 0000093C 49C1E60C                         shl r14, 12                              ;得到页表的线性地址
   625 00000940 B900020000                       mov rcx, 512
   626                                    .cls2:
   627 00000945 49C70600000000                   mov qword [r14], 0
   628 0000094C 4983C608                         add r14, 8
   629 00000950 E2F3                             loop .cls2
   630                                  ;-------------------------------------------------
   631                                    .b2:
   632 00000952 E8F9FDFFFF                       call lin_to_lin_of_pte                   ;得到页表项的线性地址
   633 00000957 58                               pop rax
   634 00000958 498906                           mov [r14], rax                           ;在页表中登记页表项（页的地址）
   635                                  
   636 0000095B 48C70512FFFFFF0000-              mov qword [rel _mapping_locker], 0
   636 00000964 0000               
   637 00000966 9D                               popfq
   638                                  
   639 00000967 415E                             pop r14
   640 00000969 59                               pop rcx
   641                                  
   642 0000096A C3                               ret
   643                                  
   644                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   645 0000096B 000020000080FFFF          _core_next_linear  dq CORE_ALLOC_START          ;下一次分配时可用的起始线性地址
   646 00000973 0000000000000000          _core_alloc_locker dq 0
   647                                  
   648                                  core_memory_allocate:                             ;在虚拟地址空间的高端（内核）分配内存
   649                                                                                    ;输入：RCX=请求分配的字节数
   650                                                                                    ;输出：R13=本次分配的起始线性地址
   651                                                                                    ;      R14=下次分配的起始线性地址
   652 0000097B 9C                               pushfq                                   ;A-->
   653 0000097C FA                               cli
   654                                           SET_SPIN_LOCK r14, qword [rel _core_alloc_locker]
    61                              <1>  %%spin_lock:
    62 0000097D 48833DEEFFFFFF00    <1>  cmp %2, 0
    63 00000985 7404                <1>  je %%get_lock
    64 00000987 F390                <1>  pause
    65 00000989 EBF2                <1>  jmp %%spin_lock
    66                              <1>  %%get_lock:
    67 0000098B 41BE01000000        <1>  mov %1, 1
    68 00000991 4C8735DBFFFFFF      <1>  xchg %1, %2
    69 00000998 4983FE00            <1>  cmp %1, 0
    70 0000099C 75DF                <1>  jne %%spin_lock
   655                                  
   656 0000099E 4C8B2DC6FFFFFF                   mov r13, [rel _core_next_linear]         ;获得本次分配的起始线性地址
   657 000009A5 4D8D740D00                       lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   658                                  
   659 000009AA 49F7C607000000                   test r14, 0x07                           ;最低3位是000吗（是否按8字节对齐）？
   660 000009B1 740C                             jz .algn
   661 000009B3 4983C608                         add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   662 000009B7 49C1EE03                         shr r14, 3
   663 000009BB 49C1E603                         shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   664                                  
   665                                    .algn:
   666 000009BF 4C8935A5FFFFFF                   mov [rel _core_next_linear], r14         ;写回。
   667                                  
   668 000009C6 48C705A2FFFFFF0000-              mov qword [rel _core_alloc_locker], 0    ;释放锁
   668 000009CF 0000               
   669 000009D1 9D                               popfq                                    ;A
   670                                  
   671 000009D2 4155                             push r13
   672 000009D4 4156                             push r14
   673                                  
   674                                           ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   675 000009D6 49C1ED0C                         shr r13, 12
   676 000009DA 49C1E50C                         shl r13, 12                              ;清除掉页内偏移部分
   677 000009DE 49C1EE0C                         shr r14, 12
   678 000009E2 49C1E60C                         shl r14, 12                              ;too
   679                                    .next:
   680 000009E6 E890FDFFFF                       call setup_paging_for_laddr              ;安装当前线性地址所在的页
   681 000009EB 4981C500100000                   add r13, 0x1000                          ;+4096
   682 000009F2 4D39F5                           cmp r13, r14
   683 000009F5 7EEF                             jle .next
   684                                  
   685 000009F7 415E                             pop r14
   686 000009F9 415D                             pop r13
   687                                  
   688 000009FB C3                               ret
   689                                  
   690                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   691                                  user_memory_allocate:                             ;在用户任务的私有空间（低端）分配内存
   692                                                                                    ;输入：R11=任务控制块PCB的线性地址
   693                                                                                    ;      RCX=希望分配的字节数
   694                                                                                    ;输出：R13=本次分配的起始线性地址
   695                                                                                    ;      R14=下次分配的起始线性地址
   696                                           ;获得本次内存分配的起始线性地址
   697 000009FC 4D8B6B18                         mov r13, [r11 + 24]                      ;获得本次分配的起始线性地址
   698 00000A00 4D8D740D00                       lea r14, [r13 + rcx]                     ;下次分配时的起始线性地址
   699                                  
   700 00000A05 49F7C607000000                   test r14, 0x07                           ;能够被8整除吗（是否按8字节对齐）？
   701 00000A0C 740C                             jz .algn
   702 00000A0E 49C1EE03                         shr r14, 3
   703 00000A12 49C1E603                         shl r14, 3                               ;最低3个比特变成0，强制按8字节对齐。
   704 00000A16 4983C608                         add r14, 0x08                            ;注：立即数符号扩展到64位参与操作
   705                                  
   706                                    .algn:
   707 00000A1A 4D897318                         mov [r11 + 24], r14                      ;写回PCB中。
   708                                  
   709 00000A1E 4155                             push r13
   710 00000A20 4156                             push r14
   711                                  
   712                                           ;以下为请求的内存分配页。R13为本次分配的线性地址；R14为下次分配的线性地址
   713 00000A22 49C1ED0C                         shr r13, 12
   714 00000A26 49C1E50C                         shl r13, 12                              ;清除掉页内偏移部分
   715 00000A2A 49C1EE0C                         shr r14, 12
   716 00000A2E 49C1E60C                         shl r14, 12                              ;too
   717                                    .next:
   718 00000A32 E844FDFFFF                       call setup_paging_for_laddr              ;安装当前线性地址所在的页
   719 00000A37 4981C500100000                   add r13, 0x1000                          ;+4096
   720 00000A3E 4D39F5                           cmp r13, r14
   721 00000A41 7EEF                             jle .next
   722                                  
   723 00000A43 415E                             pop r14
   724 00000A45 415D                             pop r13
   725                                  
   726 00000A47 C3                               ret
   727                                  
   728                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   729 00000A48 0000000000000000        _copy_locker dq 0
   730                                  
   731                                  copy_current_pml4:                                ;创建新的4级头表，并复制当前4级头表的内容
   732                                                                                    ;输入：无
   733                                                                                    ;输出：RAX=新4级头表的物理地址及属性
   734 00000A50 56                               push rsi
   735 00000A51 57                               push rdi
   736 00000A52 4155                             push r13
   737 00000A54 51                               push rcx
   738                                  
   739 00000A55 9C                               pushfq                                   ;-->A
   740 00000A56 FA                               cli
   741                                           SET_SPIN_LOCK rcx, qword [rel _copy_locker]
    61                              <1>  %%spin_lock:
    62 00000A57 48833DE9FFFFFF00    <1>  cmp %2, 0
    63 00000A5F 7404                <1>  je %%get_lock
    64 00000A61 F390                <1>  pause
    65 00000A63 EBF2                <1>  jmp %%spin_lock
    66                              <1>  %%get_lock:
    67 00000A65 B901000000          <1>  mov %1, 1
    68 00000A6A 48870DD7FFFFFF      <1>  xchg %1, %2
    69 00000A71 4883F900            <1>  cmp %1, 0
    70 00000A75 75E0                <1>  jne %%spin_lock
   742                                  
   743 00000A77 E856FCFFFF                       call allocate_a_4k_page                  ;分配一个物理页
   744 00000A7C 4883C807                         or rax, 0x07                             ;立即数符号扩展到64位参与操作
   745 00000A80 49BD00F0FFFF7FFFFF-              mov r13, NEW_PML4_LINEAR                 ;用指定的线性地址映射和访问这个页
   745 00000A89 FF                 
   746 00000A8A E8F1FDFFFF                       call mapping_laddr_to_page
   747                                  
   748                                           ;相关表项在修改前存在遗留，本次修改必须刷新。
   749 00000A8F 410F017D00                       invlpg [r13]
   750                                  
   751 00000A94 48C7C600F0FFFF                   mov rsi, 0xffff_ffff_ffff_f000           ;RSI->当前活动4级头表的线性地址
   752 00000A9B 4C89EF                           mov rdi, r13                             ;RDI->新4级头表的线性地址
   753 00000A9E B900020000                       mov rcx, 512                             ;RCX=要复制的目录项数
   754 00000AA3 FC                               cld
   755 00000AA4 F348A5                           repe movsq
   756                                  
   757 00000AA7 498985F80F0000                   mov [r13 + 0xff8], rax                   ;新4级头表的511号表项指向它自己
   758 00000AAE 410F01BDF80F0000                 invlpg [r13 + 0xff8]
   759                                  
   760 00000AB6 48C70587FFFFFF0000-              mov qword [rel _copy_locker], 0
   760 00000ABF 0000               
   761 00000AC1 9D                               popfq                                    ;A
   762                                  
   763 00000AC2 59                               pop rcx
   764 00000AC3 415D                             pop r13
   765 00000AC5 5F                               pop rdi
   766 00000AC6 5E                               pop rsi
   767                                  
   768 00000AC7 C3                               ret
   769                                  
   770                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   771                                  get_cmos_time:                                    ;从CMOS中获取当前时间
   772                                                                                    ;输入：RBX=缓冲区线性地址
   773 00000AC8 50                               push rax
   774                                  
   775 00000AC9 9C                               pushfq                                   ;-->A
   776 00000ACA FA                               cli
   777                                  
   778                                    .w0:
   779 00000ACB B08A                             mov al, 0x8a
   780 00000ACD E670                             out 0x70, al
   781 00000ACF E471                             in al, 0x71                              ;读寄存器A
   782 00000AD1 A880                             test al, 0x80                            ;测试第7位UIP，等待更新周期结束。
   783 00000AD3 75F6                             jnz .w0
   784                                  
   785 00000AD5 B084                             mov al, 0x84
   786 00000AD7 E670                             out 0x70, al
   787 00000AD9 E471                             in al, 0x71                              ;读RTC当前时间(时)
   788 00000ADB 88C4                             mov ah, al
   789                                  
   790 00000ADD C0EC04                           shr ah, 4
   791 00000AE0 80E40F                           and ah, 0x0f
   792 00000AE3 80C430                           add ah, 0x30
   793 00000AE6 8823                             mov [rbx], ah
   794                                  
   795 00000AE8 240F                             and al, 0x0f
   796 00000AEA 0430                             add al, 0x30
   797 00000AEC 884301                           mov [rbx + 1], al
   798                                  
   799 00000AEF C643023A                         mov byte [rbx + 2], ':'
   800                                  
   801 00000AF3 B082                             mov al, 0x82
   802 00000AF5 E670                             out 0x70, al
   803 00000AF7 E471                             in al, 0x71                              ;读RTC当前时间(分)
   804 00000AF9 88C4                             mov ah, al
   805                                  
   806 00000AFB C0EC04                           shr ah, 4
   807 00000AFE 80E40F                           and ah, 0x0f
   808 00000B01 80C430                           add ah, 0x30
   809 00000B04 886303                           mov [rbx + 3], ah
   810                                  
   811 00000B07 240F                             and al, 0x0f
   812 00000B09 0430                             add al, 0x30
   813 00000B0B 884304                           mov [rbx + 4], al
   814                                  
   815 00000B0E C643053A                         mov byte [rbx + 5], ':'
   816                                  
   817 00000B12 B080                             mov al, 0x80
   818 00000B14 E670                             out 0x70, al
   819 00000B16 E471                             in al, 0x71                              ;读RTC当前时间(秒)
   820 00000B18 88C4                             mov ah, al                               ;分拆成两个数字
   821                                  
   822 00000B1A C0EC04                           shr ah, 4                                ;逻辑右移4位
   823 00000B1D 80E40F                           and ah, 0x0f
   824 00000B20 80C430                           add ah, 0x30
   825 00000B23 886306                           mov [rbx + 6], ah
   826                                  
   827 00000B26 240F                             and al, 0x0f                             ;仅保留低4位
   828 00000B28 0430                             add al, 0x30                             ;转换成ASCII
   829 00000B2A 884307                           mov [rbx + 7], al
   830                                  
   831 00000B2D C6430800                         mov byte [rbx + 8], 0                    ;空字符终止
   832                                  
   833 00000B31 9D                               popfq                                    ;A
   834                                  
   835 00000B32 58                               pop rax
   836                                  
   837 00000B33 C3                               ret
   838                                  
   839                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   840 00000B34 0000000000000000          _process_id        dq 0
   841                                  generate_process_id:                              ;生成唯一的进程标识
   842                                                                                    ;返回：RAX=进程标识
   843 00000B3C B801000000                       mov rax, 1
   844 00000B41 F0480FC105EAFFFFFF               lock xadd qword [rel _process_id], rax
   845                                  
   846 00000B4A C3                               ret
   847                                  
   848                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   849                                  ;  _thread_id dq 0
   850                                  
   851                                  ;generate_thread_id:                               ;生成唯一的线程标识
   852                                                                                    ;返回：RAX=线程标识
   853                                  ;         mov rax, 1
   854                                  ;         lock xadd qword [rel _thread_id], rax
   855                                  
   856                                  ;         ret
   857                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   858 00000B4B 08                        _screen_row        db 8
   859                                  get_screen_row:                                   ;返回下一个屏幕坐标行的行号
   860                                                                                    ;返回：DH=行号
   861 00000B4C B601                             mov dh, 1
   862 00000B4E F00FC035F5FFFFFF                 lock xadd byte [rel _screen_row], dh
   863                                  
   864 00000B56 C3                               ret
   865                                  
   866                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   867                                  get_cpu_number:                                   ;返回当前处理器的编号
   868                                                                                    ;返回：RAX=处理器编号
   869 00000B57 9C                               pushfq
   870 00000B58 FA                               cli
   871 00000B59 0F01F8                           swapgs
   872 00000B5C 65488B042510000000               mov rax, [gs:16]                         ;从处理器专属数据区取回
   873 00000B65 0F01F8                           swapgs
   874 00000B68 9D                               popfq
   875 00000B69 C3                               ret
   876                                  ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   877                                  
